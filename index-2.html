<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenClaw Command Center</title>
<meta name="description" content="Multi-agent AI command center for OpenClaw. Manage agent teams, org structures, tasks, campaigns, cron jobs, and more from a single glass-panel dashboard.">
<meta name="author" content="OpenClaw">
<meta property="og:title" content="OpenClaw Command Center">
<meta property="og:description" content="Multi-agent AI command center â€” manage agent teams, org structures, tasks, campaigns, and analytics from a single dashboard.">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="OpenClaw Command Center">
<meta name="twitter:description" content="Multi-agent AI command center with glass-panel UI. Single HTML file, zero dependencies.">
<meta name="theme-color" content="#0a84ff">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦ž</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   OPENCLAW COMMAND CENTER â€” Glass Panel Theme
   iOS-inspired glassmorphism with dark/light modes
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ THEME: DARK (default) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root, [data-theme="dark"] {
  --bg-deep: #000000;
  --bg-base: rgba(28,28,30,.92);
  --bg-surface: rgba(44,44,46,.72);
  --bg-elevated: rgba(58,58,60,.65);
  --bg-glass: rgba(44,44,46,.45);
  --bg-solid-base: #1c1c1e;
  --bg-solid-surface: #2c2c2e;
  --border: rgba(255,255,255,.08);
  --border-active: rgba(255,255,255,.18);
  --text-primary: #f5f5f7;
  --text-secondary: rgba(235,235,245,.6);
  --text-muted: rgba(235,235,245,.3);
  --accent-tint: rgba(10,132,255,.12);
  --accent-green: #30d158;
  --accent-blue: #0a84ff;
  --accent-orange: #ff9f0a;
  --accent-purple: #bf5af2;
  --accent-red: #ff453a;
  --accent-yellow: #ffd60a;
  --shadow-sm: 0 1px 3px rgba(0,0,0,.3);
  --shadow-md: 0 4px 16px rgba(0,0,0,.4);
  --shadow-lg: 0 8px 32px rgba(0,0,0,.5);
  --shadow-glow: none;
  --blur-standard: blur(40px) saturate(180%);
  --blur-light: blur(20px) saturate(150%);
  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 20px;
  --radius-xl: 28px;
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
  --font-mono: 'SF Mono', 'Menlo', 'Consolas', monospace;
  --font-display: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  --modal-bg: rgba(0,0,0,.5);
  --warroom-bg: radial-gradient(ellipse at 50% 50%, #111113 0%, #000000 70%);
  --warroom-grid-color: rgba(255,255,255,.02);
  --nexus-ring: rgba(48,209,88,.08);
  --nexus-glow: rgba(48,209,88,.04);
}

/* â”€â”€ THEME: LIGHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
[data-theme="light"] {
  --bg-deep: #f2f2f7;
  --bg-base: rgba(255,255,255,.82);
  --bg-surface: rgba(255,255,255,.6);
  --bg-elevated: rgba(255,255,255,.7);
  --bg-glass: rgba(255,255,255,.45);
  --bg-solid-base: #ffffff;
  --bg-solid-surface: #f2f2f7;
  --border: rgba(0,0,0,.06);
  --border-active: rgba(0,0,0,.15);
  --text-primary: #1d1d1f;
  --text-secondary: rgba(60,60,67,.6);
  --text-muted: rgba(60,60,67,.3);
  --accent-tint: rgba(0,122,255,.08);
  --accent-green: #34c759;
  --accent-blue: #007aff;
  --accent-orange: #ff9500;
  --accent-purple: #af52de;
  --accent-red: #ff3b30;
  --accent-yellow: #ffcc00;
  --shadow-sm: 0 1px 3px rgba(0,0,0,.06);
  --shadow-md: 0 4px 16px rgba(0,0,0,.08);
  --shadow-lg: 0 8px 32px rgba(0,0,0,.1);
  --shadow-glow: none;
  --blur-standard: blur(40px) saturate(180%);
  --blur-light: blur(20px) saturate(150%);
  --modal-bg: rgba(0,0,0,.3);
  --warroom-bg: radial-gradient(ellipse at 50% 50%, #e8e8ed 0%, #f2f2f7 70%);
  --warroom-grid-color: rgba(0,0,0,.02);
  --nexus-ring: rgba(52,199,89,.1);
  --nexus-glow: rgba(52,199,89,.05);
}

* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; overflow: hidden; }
body {
  font-family: var(--font-sans);
  background: var(--bg-deep);
  color: var(--text-primary);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  transition: background .4s ease, color .3s ease;
}

/* Scrollbar */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border-active); border-radius: 4px; }

/* Animations */
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: .35; } }
@keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes typing { 0%,80%,100% { transform: translateY(0); } 40% { transform: translateY(-5px); } }
@keyframes glow { 0%,100% { box-shadow: 0 0 4px var(--accent-green); } 50% { box-shadow: 0 0 12px var(--accent-green); } }
@keyframes speakPulse { 0%,100% { border-color: transparent; transform: scale(1); } 50% { transform: scale(1.1); } }
@keyframes fadeOut { from { opacity:1; transform:translateY(0); } to { opacity:0; transform:translateY(-8px); } }
.animate-in { animation: slideUp .4s ease-out both; }

/* â”€â”€ LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#app { display: flex; height: 100vh; }

/* Sidebar */
#sidebar {
  width: 64px;
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  -webkit-backdrop-filter: var(--blur-standard);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px 0;
  flex-shrink: 0;
  z-index: 10;
}
#sidebar .logo {
  width: 36px; height: 36px;
  display: flex; align-items: center; justify-content: center;
  font-size: 22px;
  margin-bottom: 24px;
  cursor: default;
}
.nav-btn {
  width: 40px; height: 40px;
  display: flex; align-items: center; justify-content: center;
  border: none; background: none;
  color: var(--text-muted);
  font-size: 16px;
  cursor: pointer;
  border-radius: var(--radius-sm);
  margin-bottom: 4px;
  transition: all .2s ease;
  position: relative;
}
.nav-btn:hover { color: var(--text-secondary); background: var(--bg-surface); }
.nav-btn.active {
  color: var(--accent-blue);
  background: var(--accent-tint);
}
.nav-btn.active::before {
  content: '';
  position: absolute; left: -10px;
  width: 3px; height: 20px;
  background: var(--accent-blue);
  border-radius: 0 3px 3px 0;
}
.nav-btn .tooltip {
  display: none; position: absolute; left: 56px; top: 50%;
  transform: translateY(-50%);
  background: var(--bg-elevated); 
  backdrop-filter: var(--blur-light);
  border: 1px solid var(--border);
  padding: 6px 12px; border-radius: var(--radius-sm);
  font-size: 11px; color: var(--text-primary);
  font-weight: 500;
  white-space: nowrap; z-index: 100;
  box-shadow: var(--shadow-md);
}
.nav-btn:hover .tooltip { display: block; }

/* Add agent button */
.add-agent-btn {
  font-size: 20px !important; font-weight: 300;
  color: var(--accent-green) !important;
  margin-bottom: 12px !important;
  border: 1px dashed var(--border) !important;
  border-radius: 10px !important;
  transition: all .2s;
}
.add-agent-btn:hover {
  background: rgba(52,199,89,.1) !important;
  border-color: var(--accent-green) !important;
  color: var(--accent-green) !important;
}

/* Agent modal */
.agent-modal-body {
  display: flex; flex-direction: column; gap: 14px;
}
.am-row { display: flex; gap: 12px; }
.am-row > .vault-field { flex: 1; }
.am-color-grid {
  display: flex; flex-wrap: wrap; gap: 6px;
}
.am-color-swatch {
  width: 28px; height: 28px; border-radius: 8px;
  border: 2px solid transparent; cursor: pointer;
  transition: all .15s;
}
.am-color-swatch:hover { transform: scale(1.15); }
.am-color-swatch.selected { border-color: var(--text-primary); box-shadow: 0 0 0 2px var(--bg-base); }
.am-color-swatch.taken { opacity: .25; pointer-events: none; }
.am-skill-tags {
  display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px;
}
.am-skill-tag {
  display: inline-flex; align-items: center; gap: 4px;
  padding: 4px 10px; border-radius: 12px;
  background: var(--accent-tint); border: 1px solid var(--border);
  font-size: 11px; font-weight: 600; color: var(--text-primary);
}
.am-skill-tag .am-skill-x {
  cursor: pointer; opacity: .5; font-size: 10px;
}
.am-skill-tag .am-skill-x:hover { opacity: 1; color: var(--accent-red); }
.am-skill-input {
  flex: 1; min-width: 100px;
  background: none !important; border: none !important;
  font-size: 11px; color: var(--text-primary);
  outline: none; padding: 4px 0 !important;
}
.am-model-select {
  width: 100%; box-sizing: border-box;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 12px;
  font-family: var(--font-sans);
  font-size: 12px; color: var(--text-primary);
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' fill='%238e8e93'%3E%3Cpath d='M1 1l5 5 5-5'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
  cursor: pointer;
}
.am-model-select:focus { outline: none; border-color: var(--accent-blue); }
.am-model-select optgroup { font-weight: 700; color: var(--text-muted); }
.am-model-select option { font-weight: 400; color: var(--text-primary); padding: 4px; }
.am-danger-zone {
  margin-top: 10px; padding-top: 14px;
  border-top: 1px solid rgba(255,59,48,.2);
}
.am-delete-btn {
  width: 100%; padding: 10px;
  background: rgba(255,59,48,.08);
  border: 1px solid rgba(255,59,48,.2);
  border-radius: var(--radius-sm);
  color: var(--accent-red); font-weight: 700;
  font-size: 12px; cursor: pointer;
  font-family: var(--font-sans);
  transition: all .15s;
}
.am-delete-btn:hover { background: rgba(255,59,48,.15); border-color: var(--accent-red); }

/* Org node edit/delete overlay */
.org-node-actions {
  position: absolute; top: -8px; right: -8px;
  display: flex; gap: 3px;
  opacity: 0; transition: opacity .15s;
  z-index: 6;
}
.org-node:hover .org-node-actions { opacity: 1; }
.org-node-act {
  width: 20px; height: 20px; border-radius: 6px;
  border: 1px solid var(--border);
  background: var(--bg-elevated);
  backdrop-filter: var(--blur-light);
  display: flex; align-items: center; justify-content: center;
  font-size: 10px; cursor: pointer;
  color: var(--text-muted);
  transition: all .15s;
}
.org-node-act:hover { color: var(--text-primary); border-color: var(--border-active); }
.org-node-act.danger:hover { color: var(--accent-red); border-color: var(--accent-red); background: rgba(255,59,48,.08); }

#sidebar .spacer { flex: 1; }

/* Theme toggle */
#theme-toggle {
  width: 32px; height: 32px;
  display: flex; align-items: center; justify-content: center;
  border: none; background: var(--bg-surface);
  border-radius: 50%;
  font-size: 14px; cursor: pointer;
  margin-bottom: 8px;
  transition: all .2s;
  color: var(--text-secondary);
}
#theme-toggle:hover { background: var(--bg-elevated); transform: scale(1.1); }

/* Connection indicator */
#conn-status {
  width: 8px; height: 8px; border-radius: 50%;
  margin-bottom: 8px;
  transition: all .3s;
}
#conn-status.connected { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); animation: pulse 3s infinite; }
#conn-status.disconnected { background: var(--accent-red); box-shadow: 0 0 6px rgba(255,69,58,.3); }
#conn-status.connecting { background: var(--accent-yellow); animation: pulse 1s infinite; }

/* Main content area */
#main { flex: 1; overflow: hidden; display: flex; flex-direction: column; }
#topbar {
  height: 52px;
  display: flex; align-items: center;
  padding: 0 24px;
  border-bottom: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  -webkit-backdrop-filter: var(--blur-standard);
  flex-shrink: 0;
}
#topbar .view-title {
  font-family: var(--font-display);
  font-size: 17px; font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -.2px;
}
#topbar .view-sub {
  font-size: 11px; color: var(--text-muted);
  margin-left: 12px; letter-spacing: .5px;
  font-weight: 500;
}
#topbar .right { margin-left: auto; display: flex; align-items: center; gap: 16px; }
#topbar .agent-pills { display: flex; gap: 6px; overflow-x: auto; max-width: 60vw; scrollbar-width: none; }
#topbar .agent-pills::-webkit-scrollbar { display: none; }
.agent-pill {
  display: flex; align-items: center; gap: 5px;
  padding: 3px 10px; border-radius: 20px;
  font-size: 10px; font-weight: 500;
  border: 1px solid transparent;
  letter-spacing: .3px;
}
.agent-pill .dot {
  width: 6px; height: 6px; border-radius: 50%;
}

#content { flex: 1; overflow: hidden; }
.view-panel { display: none; height: 100%; }
.view-panel.active { display: flex; flex-direction: column; }

/* â”€â”€ SHARED COMPONENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panel-header {
  padding: 18px 24px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.panel-header .label {
  font-size: 11px; color: var(--text-muted);
  letter-spacing: .5px; text-transform: uppercase;
  font-weight: 600;
}
.panel-header .title {
  font-family: var(--font-display);
  font-size: 20px; font-weight: 700;
  color: var(--text-primary); margin-top: 2px;
  letter-spacing: -.3px;
}
.btn {
  padding: 7px 16px;
  border: 1px solid var(--border);
  background: var(--bg-surface);
  backdrop-filter: var(--blur-light);
  color: var(--text-secondary);
  font-family: var(--font-sans);
  font-size: 12px; font-weight: 500;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all .2s;
}
.btn:hover { border-color: var(--border-active); color: var(--text-primary); background: var(--bg-elevated); }
.btn.primary {
  background: var(--accent-blue);
  border-color: transparent;
  color: #fff;
}
.btn.primary:hover { opacity: .85; }

.card {
  background: var(--bg-surface);
  backdrop-filter: var(--blur-light);
  -webkit-backdrop-filter: var(--blur-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-sm);
  transition: all .25s ease;
}
.card:hover { box-shadow: var(--shadow-md); border-color: var(--border-active); }
.card.selected { border-color: var(--accent-blue); background: var(--accent-tint); }

.tag {
  display: inline-block;
  padding: 2px 8px; border-radius: 6px;
  font-size: 10px; font-weight: 600;
  letter-spacing: .3px;
}

input, select, textarea {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-size: 13px; border-radius: var(--radius-sm);
  padding: 10px 14px; outline: none;
  transition: all .2s;
}
input:focus, select:focus, textarea:focus { border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(10,132,255,.15); }
input::placeholder { color: var(--text-muted); }
select option { background: var(--bg-solid-base); }

/* â”€â”€ SETTINGS MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#settings-overlay {
  display: none; position: fixed; inset: 0;
  background: var(--modal-bg);
  backdrop-filter: blur(8px);
  z-index: 1000;
  align-items: center; justify-content: center;
}
#settings-overlay.open { display: flex; }
#settings-modal {
  width: 440px; padding: 28px;
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
}
#settings-modal h3 {
  font-family: var(--font-display);
  font-size: 18px; font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 20px;
  letter-spacing: -.2px;
}
#settings-modal label {
  display: block; font-size: 11px;
  color: var(--text-muted); font-weight: 600;
  letter-spacing: .3px;
  margin-bottom: 5px; margin-top: 14px;
}
#settings-modal input, #settings-modal select {
  width: 100%;
}
#settings-modal .actions {
  display: flex; gap: 10px; margin-top: 22px;
}
#settings-modal .actions .btn { flex: 1; padding: 12px; }

/* â”€â”€ ORG STRUCTURE NODE GRAPH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#org-canvas {
  flex: 1; position: relative;
  background: var(--warroom-bg);
  overflow: hidden;
  cursor: grab;
}
#org-canvas.panning { cursor: grabbing; }
#org-world {
  position: absolute;
  inset: 0;
  transform-origin: 0 0;
  width: 4000px; height: 4000px;
  will-change: transform;
}
#org-world .grid-overlay {
  position: absolute; inset: 0;
  background-image:
    linear-gradient(var(--warroom-grid-color) 1px, transparent 1px),
    linear-gradient(90deg, var(--warroom-grid-color) 1px, transparent 1px);
  background-size: 40px 40px;
  pointer-events: none;
}

/* Agent node cards */
.org-node {
  position: absolute;
  width: 200px;
  background: var(--bg-glass);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  backdrop-filter: var(--blur-standard);
  -webkit-backdrop-filter: var(--blur-standard);
  box-shadow: var(--shadow-md);
  cursor: grab;
  z-index: 3;
  transition: box-shadow .2s, border-color .2s;
  user-select: none;
}
.org-node:hover { box-shadow: var(--shadow-lg); }
.org-node.dragging { cursor: grabbing; z-index: 10; box-shadow: 0 12px 40px rgba(0,0,0,.4); }
.org-node.selected { border-color: var(--accent-blue); }
.org-node-body { padding: 14px 16px; }
.org-node-header {
  display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
}
.org-node-dot {
  width: 8px; height: 8px; border-radius: 50%;
  flex-shrink: 0;
}
.org-node-name { font-size: 13px; font-weight: 700; letter-spacing: -.1px; }
.org-node-status {
  margin-left: auto; font-size: 8px; font-weight: 600; letter-spacing: .5px;
}
.org-node-role {
  font-size: 10px; color: var(--text-muted); font-weight: 600; letter-spacing: .3px;
  text-transform: uppercase; margin-bottom: 8px;
}
.org-node-skills {
  display: flex; flex-wrap: wrap; gap: 4px;
}
.org-node-skill {
  font-size: 9px; padding: 2px 6px;
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 4px; color: var(--text-secondary);
  font-weight: 500;
}
.org-node-stats {
  display: flex; gap: 12px; margin-top: 8px; padding-top: 8px;
  border-top: 1px solid var(--border);
  font-size: 10px; color: var(--text-muted);
}

/* Connection ports */
.org-port {
  position: absolute;
  width: 14px; height: 14px;
  border-radius: 50%;
  background: var(--bg-solid-surface);
  border: 2px solid var(--border-active);
  cursor: crosshair;
  z-index: 6;
  transition: all .2s;
  display: flex; align-items: center; justify-content: center;
}
.org-port::after {
  content: ''; width: 4px; height: 4px; border-radius: 50%;
  background: transparent; transition: all .15s;
}
.org-port:hover { transform: scale(1.3); border-color: var(--accent-blue); }
.org-port:hover::after { background: var(--accent-blue); }
.org-port.connected { border-color: var(--accent-green); }
.org-port.connected::after { background: var(--accent-green); }
.org-port.port-top { left: 50%; top: -8px; transform: translateX(-50%); }
.org-port.port-bottom { left: 50%; bottom: -8px; transform: translateX(-50%); }
.org-port.port-left { top: 50%; left: -8px; transform: translateY(-50%); }
.org-port.port-right { top: 50%; right: -8px; transform: translateY(-50%); }
.org-port.port-top:hover, .org-port.port-bottom:hover { transform: translateX(-50%) scale(1.3); }
.org-port.port-left:hover, .org-port.port-right:hover { transform: translateY(-50%) scale(1.3); }

/* Wires */
#org-wires .wire {
  fill: none;
  stroke-width: 2;
  stroke-linecap: round;
  transition: stroke .2s;
}
#org-wires .wire:hover { stroke-width: 3; }
#org-wires .wire-glow {
  fill: none; stroke-width: 6;
  stroke-linecap: round; opacity: .15;
}
#org-wire-preview path {
  fill: none; stroke: var(--accent-blue);
  stroke-width: 2; stroke-dasharray: 6 4;
  opacity: .6;
}

/* Wire delete buttons */
.wire-del-btn {
  position: absolute; z-index: 4;
  transform: translate(-50%, -50%);
  width: 22px; height: 22px;
  border-radius: 50%;
  background: var(--accent-red);
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  opacity: 0;
  transition: opacity .2s, transform .2s;
  box-shadow: 0 1px 4px rgba(0,0,0,.35);
}
.wire-del-btn:hover {
  opacity: 1 !important;
  transform: translate(-50%, -50%) scale(1.2);
}
.wire-del-btn .wire-del-icon {
  color: #fff; font-size: 16px; font-weight: 700; line-height: 1;
  margin-top: -1px;
}
.wire-del-btn .wire-del-label {
  display: none;
  position: absolute; top: -24px; left: 50%; transform: translateX(-50%);
  white-space: nowrap;
  font-size: 9px; font-weight: 600; color: var(--text-primary);
  background: var(--bg-base); border: 1px solid var(--border);
  border-radius: 4px; padding: 2px 8px;
  box-shadow: var(--shadow-sm);
}
.wire-del-btn:hover .wire-del-label { display: block; }
/* Show all delete buttons on hover of canvas */
#org-world:hover .wire-del-btn { opacity: .5; }

/* Toolbar */
.org-toolbar {
  position: absolute; bottom: 16px; left: 20px; right: 20px;
  display: flex; align-items: center; gap: 8px;
  z-index: 8;
}
.org-hint {
  margin-left: auto;
  font-size: 10px; color: var(--text-muted); font-weight: 500;
}
.org-legend {
  position: absolute; top: 16px; left: 20px;
  display: flex; gap: 16px; z-index: 8;
}
.org-legend-item {
  display: flex; align-items: center; gap: 5px;
  font-size: 10px; color: var(--text-muted); font-weight: 500;
}
.org-legend-dot { width: 6px; height: 6px; border-radius: 50%; }
.org-legend-line {
  width: 20px; height: 2px; background: var(--accent-blue);
  border-radius: 1px;
}

/* â”€â”€ AGENT CHAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#chat { flex-direction: row !important; }
#chat-agents {
  width: 200px;
  border-right: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  display: flex; flex-direction: column;
  overflow-y: auto;
}
.chat-agent-btn {
  display: flex; align-items: center; gap: 10px;
  padding: 14px 16px;
  border: none; background: none;
  cursor: pointer; width: 100%;
  border-left: 3px solid transparent;
  transition: all .2s;
  font-family: var(--font-sans);
}
.chat-agent-btn:hover { background: var(--bg-surface); }
.chat-agent-btn.active { background: var(--accent-tint); }
.chat-agent-btn .agent-name { font-size: 12px; font-weight: 600; text-align: left; letter-spacing: -.1px; }
.chat-agent-btn .agent-role { font-size: 10px; color: var(--text-muted); text-align: left; }

#chat-main { flex: 1; display: flex; flex-direction: column; }
#chat-header {
  padding: 12px 24px;
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center; gap: 12px;
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  flex-shrink: 0;
}
#chat-messages { flex: 1; overflow-y: auto; padding: 18px 24px; }
.chat-bubble {
  max-width: 70%; margin-bottom: 12px;
  animation: slideUp .3s ease-out both;
}
.chat-bubble.user { margin-left: auto; }
.chat-bubble .bubble-inner {
  padding: 12px 16px;
  font-size: 13px; line-height: 1.6;
  color: var(--text-secondary);
  border-radius: 18px;
}
.chat-bubble.user .bubble-inner {
  background: var(--accent-blue);
  color: #fff;
  border-radius: 18px 18px 4px 18px;
}
.chat-bubble.agent .bubble-inner {
  background: var(--bg-surface);
  backdrop-filter: var(--blur-light);
  border: 1px solid var(--border);
  border-radius: 18px 18px 18px 4px;
}
.chat-bubble .bubble-ts {
  font-size: 9px; color: var(--text-muted);
  margin-top: 4px; text-align: right;
}
.typing-indicator {
  display: none; gap: 4px; padding: 12px 16px;
  width: fit-content;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 18px;
}
.typing-indicator.show { display: flex; }
.typing-indicator span {
  width: 6px; height: 6px; border-radius: 50%;
  background: var(--text-muted);
}
.typing-indicator span:nth-child(1) { animation: typing 1.2s infinite 0s; }
.typing-indicator span:nth-child(2) { animation: typing 1.2s infinite .2s; }
.typing-indicator span:nth-child(3) { animation: typing 1.2s infinite .4s; }

#chat-input-bar {
  padding: 14px 24px;
  border-top: 1px solid var(--border);
  display: flex; gap: 10px;
  flex-shrink: 0;
}
#chat-input-bar input { flex: 1; border-radius: 20px; padding: 10px 18px; }

/* â”€â”€ CALENDAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#calendar { flex-direction: row !important; }
#cal-grid-wrap { flex: 1; padding: 24px; overflow-y: auto; }
#cal-grid {
  display: grid; grid-template-columns: repeat(7, 1fr);
  gap: 1px; background: var(--border);
  border: 1px solid var(--border); border-radius: var(--radius-md);
  overflow: hidden;
}
.cal-header-cell {
  padding: 10px; text-align: center;
  font-size: 11px; color: var(--text-muted);
  background: var(--bg-solid-base); font-weight: 600;
  letter-spacing: .3px;
}
.cal-cell {
  min-height: 92px; padding: 8px;
  background: var(--bg-solid-base);
  cursor: pointer; transition: background .2s;
}
.cal-cell:hover { background: var(--bg-solid-surface); }
.cal-cell.selected { background: var(--accent-tint); }
.cal-cell.today .cal-day { color: var(--accent-blue); font-weight: 700; }
.cal-cell .cal-day { font-size: 12px; color: var(--text-secondary); margin-bottom: 4px; font-weight: 500; }
.cal-cell .cal-event {
  padding: 2px 6px; margin-bottom: 2px;
  font-size: 9px; color: var(--text-secondary);
  border-radius: 4px; overflow: hidden;
  text-overflow: ellipsis; white-space: nowrap;
  border-left: 2px solid;
  background: var(--bg-surface);
}

#cal-detail {
  width: 320px; border-left: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  display: flex; flex-direction: column;
}
#cal-detail .detail-scroll { flex: 1; overflow-y: auto; padding: 14px 18px; }
.cal-detail-event {
  padding: 12px; margin-bottom: 8px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
}
.cal-detail-event .ev-title { font-size: 13px; font-weight: 600; color: var(--text-primary); }
.cal-detail-event .ev-meta {
  display: flex; gap: 10px; margin-top: 6px;
  font-size: 10px; color: var(--text-muted);
}
.cal-detail-event .ev-delete {
  background: none; border: none;
  color: var(--text-muted); cursor: pointer;
  font-size: 12px; float: right;
}
.cal-detail-event .ev-delete:hover { color: var(--accent-red); }

/* â”€â”€ MARKETING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#marketing { flex-direction: row !important; }
#mktg-board { flex: 1; padding: 24px; overflow-y: auto; }
.kpi-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 24px; }
.kpi-card { padding: 16px; }
.kpi-card .kpi-label { font-size: 11px; color: var(--text-muted); font-weight: 500; }
.kpi-card .kpi-value {
  font-family: var(--font-display);
  font-size: 28px; font-weight: 700;
  color: var(--text-primary); margin-top: 4px;
  letter-spacing: -.5px;
}
.kpi-card .kpi-sub { font-size: 10px; color: var(--text-muted); margin-top: 2px; }
.campaign-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.campaign-card { padding: 16px; cursor: pointer; }
.campaign-card .camp-header {
  display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
}
.campaign-card .camp-name { font-size: 13px; font-weight: 600; letter-spacing: -.1px; }
.campaign-card .camp-metrics {
  display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px;
}
.campaign-card .metric-label { font-size: 9px; color: var(--text-muted); font-weight: 500; }
.campaign-card .metric-value { font-size: 12px; color: var(--text-secondary); font-weight: 500; }
.campaign-card .progress-bar {
  margin-top: 12px; height: 4px;
  background: var(--border); border-radius: 4px; overflow: hidden;
}
.campaign-card .progress-fill {
  height: 100%; background: var(--accent-blue);
  border-radius: 4px; transition: width .5s;
}

#mktg-detail {
  width: 380px; border-left: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  display: flex; flex-direction: column;
}
#mktg-detail .detail-scroll { flex: 1; overflow-y: auto; padding: 18px 24px; }
.task-item {
  display: flex; align-items: center; gap: 10px;
  padding: 10px 0; border-bottom: 1px solid var(--border);
  cursor: pointer;
}
.task-item .checkbox {
  width: 18px; height: 18px; border-radius: 6px;
  border: 1.5px solid var(--border-active);
  display: flex; align-items: center; justify-content: center;
  flex-shrink: 0; transition: all .2s;
}
.task-item .checkbox.checked {
  border-color: var(--accent-blue);
  background: var(--accent-blue);
}
.task-item .checkbox.checked::after { content: 'âœ“'; font-size: 11px; color: #fff; font-weight: 700; }
.task-item.done .task-text { text-decoration: line-through; color: var(--text-muted); }
.task-item .task-text { font-size: 12px; color: var(--text-secondary); }

/* â”€â”€ TASKS BOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#tasks .board-wrap { flex: 1; padding: 24px; overflow-y: auto; }
.board-columns { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; height: calc(100% - 60px); }
.board-col {
  background: var(--bg-surface);
  backdrop-filter: var(--blur-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  display: flex; flex-direction: column;
  box-shadow: var(--shadow-sm);
}
.board-col-header {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center; gap: 8px;
}
.board-col-header .col-dot { width: 8px; height: 8px; border-radius: 50%; }
.board-col-header .col-label { font-size: 11px; color: var(--text-muted); font-weight: 600; letter-spacing: .3px; }
.board-col-header .col-count { font-size: 11px; color: var(--text-muted); margin-left: auto; }
.board-col-body { flex: 1; overflow-y: auto; padding: 10px; }
.task-card {
  padding: 12px; margin-bottom: 8px;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-sm);
}
.task-card .tc-title { font-size: 12px; font-weight: 500; color: var(--text-primary); margin-bottom: 8px; }
.task-card .tc-meta {
  display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-bottom: 8px;
}
.task-card .tc-actions { display: flex; gap: 4px; }
.task-card .tc-actions .btn { padding: 4px 10px; font-size: 10px; }

/* â”€â”€ CRON JOBS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#cron .cron-wrap { flex: 1; padding: 24px; overflow-y: auto; }
.cron-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 20px;
}
.cron-count { font-size: 11px; color: var(--text-muted); font-weight: 500; }
.cron-list { display: flex; flex-direction: column; gap: 12px; }

/* Job card */
.cron-card {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  backdrop-filter: var(--blur-light);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  transition: box-shadow .2s, border-color .2s;
}
.cron-card:hover { box-shadow: var(--shadow-md); }
.cron-card.disabled { opacity: .55; }
.cron-card-main {
  display: grid; grid-template-columns: 48px 1fr 200px 180px 100px;
  align-items: center; padding: 16px 20px; gap: 16px;
}
.cron-toggle {
  width: 38px; height: 22px; border-radius: 11px;
  background: var(--bg-solid-surface); border: 1px solid var(--border);
  cursor: pointer; position: relative; transition: all .2s;
  flex-shrink: 0;
}
.cron-toggle.on { background: var(--accent-green); border-color: var(--accent-green); }
.cron-toggle .cron-toggle-knob {
  width: 16px; height: 16px; border-radius: 50%;
  background: #fff; position: absolute; top: 2px; left: 2px;
  transition: left .2s; box-shadow: 0 1px 3px rgba(0,0,0,.2);
}
.cron-toggle.on .cron-toggle-knob { left: 18px; }
.cron-info { min-width: 0; }
.cron-name { font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 3px; }
.cron-agents-line {
  display: flex; gap: 4px; flex-wrap: wrap;
}
.cron-agent-tag {
  display: inline-flex; align-items: center; gap: 3px;
  font-size: 9px; font-weight: 600; padding: 2px 6px;
  border-radius: 4px; border: 1px solid var(--border);
  background: var(--bg-elevated);
}
.cron-agent-dot { width: 5px; height: 5px; border-radius: 50%; }
.cron-schedule {
  display: flex; flex-direction: column; gap: 2px;
}
.cron-schedule-expr {
  font-family: var(--font-mono, monospace);
  font-size: 12px; color: var(--text-primary); font-weight: 500;
  letter-spacing: .5px;
}
.cron-schedule-human { font-size: 10px; color: var(--text-muted); }
.cron-timing {
  display: flex; flex-direction: column; gap: 2px;
}
.cron-timing-row {
  display: flex; justify-content: space-between; gap: 8px;
  font-size: 10px;
}
.cron-timing-label { color: var(--text-muted); }
.cron-timing-val { color: var(--text-secondary); font-weight: 500; }
.cron-actions {
  display: flex; gap: 4px; justify-content: flex-end;
}
.cron-actions .btn { padding: 5px 10px; font-size: 10px; }

/* Expandable message row */
.cron-message-row {
  padding: 0 20px 14px 84px;
  font-size: 11px; color: var(--text-secondary); line-height: 1.5;
  display: none;
}
.cron-card.expanded .cron-message-row { display: block; }
.cron-message-row .msg-label {
  font-size: 9px; font-weight: 600; color: var(--text-muted);
  letter-spacing: .3px; margin-bottom: 4px;
}
.cron-message-text {
  padding: 8px 12px;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: var(--font-sans); font-size: 11px;
  white-space: pre-wrap; color: var(--text-secondary);
}
.cron-stats-row {
  padding: 0 20px 14px 84px;
  display: none; gap: 16px;
}
.cron-card.expanded .cron-stats-row { display: flex; }
.cron-stat {
  font-size: 10px; color: var(--text-muted);
}
.cron-stat strong { color: var(--text-secondary); font-weight: 600; }

/* Modal: agent picker */
.cron-agent-picker {
  display: flex; gap: 8px; flex-wrap: wrap;
}
.cron-agent-pick {
  display: flex; align-items: center; gap: 6px;
  padding: 8px 12px; border-radius: var(--radius-sm);
  border: 1px solid var(--border); background: none;
  cursor: pointer; transition: all .2s;
  font-family: var(--font-sans); font-size: 12px; font-weight: 500;
  color: var(--text-secondary);
}
.cron-agent-pick:hover { border-color: var(--border-active); }
.cron-agent-pick.selected { border-color: var(--accent-blue); background: var(--accent-tint); color: var(--text-primary); }
.cron-agent-pick .pick-dot { width: 6px; height: 6px; border-radius: 50%; }

/* Modal: preset buttons */
.cron-preset-row { display: flex; flex-wrap: wrap; gap: 6px; }
.cron-preset {
  padding: 6px 12px; border-radius: var(--radius-sm);
  border: 1px solid var(--border); background: none;
  cursor: pointer; font-family: var(--font-sans);
  font-size: 11px; color: var(--text-secondary); transition: all .2s;
}
.cron-preset:hover { border-color: var(--border-active); }
.cron-preset.active { border-color: var(--accent-blue); background: var(--accent-tint); color: var(--text-primary); font-weight: 600; }

/* Modal: day picker */
.cron-day-picker { display: flex; gap: 4px; }
.cron-day {
  width: 36px; height: 32px; display: flex; align-items: center; justify-content: center;
  border-radius: var(--radius-sm); border: 1px solid var(--border);
  background: none; cursor: pointer; font-size: 10px; font-weight: 600;
  color: var(--text-muted); transition: all .2s;
  font-family: var(--font-sans);
}
.cron-day:hover { border-color: var(--border-active); }
.cron-day.active { border-color: var(--accent-blue); background: var(--accent-tint); color: var(--text-primary); }

/* â”€â”€ AGENT LOGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#logs { flex-direction: row !important; }
#logs-agents {
  width: 220px;
  border-right: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  display: flex; flex-direction: column;
  flex-shrink: 0;
}
#logs-agent-list { flex: 1; overflow-y: auto; }
.log-agent-btn {
  display: flex; align-items: center; gap: 10px;
  padding: 12px 16px; width: 100%;
  border: none; background: none; cursor: pointer;
  border-left: 3px solid transparent;
  transition: all .15s;
  font-family: var(--font-sans);
}
.log-agent-btn:hover { background: var(--bg-surface); }
.log-agent-btn.active { background: var(--accent-tint); }
.log-agent-btn .la-avatar {
  width: 28px; height: 28px; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; font-weight: 700; color: #fff;
  flex-shrink: 0;
}
.log-agent-btn .la-info { text-align: left; min-width: 0; flex: 1; }
.log-agent-btn .la-name { font-size: 12px; font-weight: 600; color: var(--text-primary); }
.log-agent-btn .la-role { font-size: 10px; color: var(--text-muted); }
.log-agent-btn .la-count {
  font-size: 10px; font-weight: 600; color: var(--text-muted);
  background: var(--bg-surface); border-radius: 10px;
  padding: 2px 7px; min-width: 20px; text-align: center;
}

#logs-main { flex: 1; display: flex; flex-direction: column; min-width: 0; }
#logs-toolbar {
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
  gap: 12px; flex-shrink: 0;
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
}
#logs-filters { display: flex; gap: 6px; flex-wrap: wrap; }
.log-filter-chip {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 5px 10px; border-radius: 20px;
  border: 1px solid var(--border); background: none;
  font-size: 10px; font-weight: 600; font-family: var(--font-sans);
  color: var(--text-muted); cursor: pointer;
  transition: all .15s; letter-spacing: .2px;
}
.log-filter-chip:hover { border-color: var(--border-active); }
.log-filter-chip.active { color: var(--text-primary); }
.log-filter-chip .chip-dot {
  width: 6px; height: 6px; border-radius: 50%;
  opacity: .4; transition: opacity .15s;
}
.log-filter-chip.active .chip-dot { opacity: 1; }
#logs-meta { font-size: 10px; color: var(--text-muted); font-weight: 500; white-space: nowrap; }

#logs-feed {
  flex: 1; overflow-y: auto; padding: 0;
}

/* Log entries */
.log-entry {
  display: grid;
  grid-template-columns: 72px 1fr;
  border-bottom: 1px solid var(--border);
  transition: background .1s;
}
.log-entry:hover { background: var(--bg-surface); }
.log-time-col {
  padding: 14px 0 14px 20px;
  display: flex; flex-direction: column;
  align-items: flex-end;
  gap: 2px;
}
.log-time {
  font-size: 11px; font-weight: 600; color: var(--text-secondary);
  font-variant-numeric: tabular-nums;
  font-family: var(--font-mono, monospace);
}
.log-date {
  font-size: 9px; color: var(--text-muted);
  font-variant-numeric: tabular-nums;
}
.log-body-col {
  padding: 14px 20px 14px 16px;
  display: flex; flex-direction: column; gap: 4px;
  min-width: 0;
}
.log-head {
  display: flex; align-items: center; gap: 8px;
}
.log-type-badge {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 9px; font-weight: 700; letter-spacing: .5px;
  padding: 2px 8px; border-radius: 4px;
  text-transform: uppercase; flex-shrink: 0;
}
.log-type-badge.task { background: rgba(10,132,255,.12); color: var(--accent-blue); }
.log-type-badge.cron { background: rgba(255,159,10,.12); color: var(--accent-yellow); }
.log-type-badge.comms { background: rgba(52,199,89,.12); color: var(--accent-green); }
.log-type-badge.system { background: rgba(142,142,147,.12); color: var(--text-muted); }
.log-type-badge.error { background: rgba(255,69,58,.12); color: var(--accent-red); }
.log-agent-badge {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 10px; font-weight: 600; flex-shrink: 0;
}
.log-agent-badge .lab-dot { width: 5px; height: 5px; border-radius: 50%; }
.log-desc {
  font-size: 12px; color: var(--text-secondary); line-height: 1.5;
}
.log-detail {
  font-size: 11px; color: var(--text-muted); line-height: 1.4;
  padding: 6px 10px; margin-top: 2px;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono, monospace);
  white-space: pre-wrap; word-break: break-word;
  display: none;
}
.log-entry.expanded .log-detail { display: block; }
.log-expand-hint {
  font-size: 9px; color: var(--text-muted); cursor: pointer;
  margin-left: auto; flex-shrink: 0;
}
.log-expand-hint:hover { color: var(--text-secondary); }

/* Empty state */
.log-empty {
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  flex: 1; gap: 8px; padding: 60px 20px;
  color: var(--text-muted);
}
.log-empty-icon { font-size: 32px; opacity: .3; }
.log-empty-text { font-size: 13px; font-weight: 500; }
.log-empty-sub { font-size: 11px; }

/* â”€â”€ SYSTEM PROMPTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#prompts { flex-direction: row !important; }
#sp-agents {
  width: 220px;
  border-right: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  display: flex; flex-direction: column;
  flex-shrink: 0;
}
#sp-agent-list { flex: 1; overflow-y: auto; }
.sp-agent-btn {
  display: flex; align-items: center; gap: 10px;
  padding: 14px 16px; width: 100%;
  border: none; background: none; cursor: pointer;
  border-left: 3px solid transparent;
  transition: all .15s;
  font-family: var(--font-sans);
}
.sp-agent-btn:hover { background: var(--bg-surface); }
.sp-agent-btn.active { background: var(--accent-tint); }
.sp-agent-btn .spa-avatar {
  width: 32px; height: 32px; border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  font-size: 13px; font-weight: 700; color: #fff;
  flex-shrink: 0;
}
.sp-agent-btn .spa-info { text-align: left; min-width: 0; flex: 1; }
.sp-agent-btn .spa-name { font-size: 13px; font-weight: 600; color: var(--text-primary); }
.sp-agent-btn .spa-role { font-size: 10px; color: var(--text-muted); }
.sp-agent-btn .spa-status {
  width: 7px; height: 7px; border-radius: 50%;
  flex-shrink: 0;
}

#sp-editor { flex: 1; display: flex; flex-direction: column; min-width: 0; }
#sp-header {
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
  gap: 16px; flex-shrink: 0;
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
}
#sp-agent-info {
  display: flex; align-items: center; gap: 12px;
}
.sp-info-name { font-size: 15px; font-weight: 700; color: var(--text-primary); }
.sp-info-role { font-size: 11px; color: var(--text-muted); font-weight: 500; }
.sp-info-id {
  font-size: 10px; color: var(--text-muted);
  font-family: var(--font-mono, monospace);
  background: var(--bg-surface); padding: 2px 8px;
  border-radius: 4px; border: 1px solid var(--border);
}
#sp-actions { display: flex; gap: 6px; align-items: center; }
#sp-save-status {
  font-size: 10px; font-weight: 600; margin-right: 4px;
  transition: color .3s;
}

#sp-sections {
  flex: 1; overflow-y: auto; padding: 20px 24px;
  display: flex; flex-direction: column; gap: 16px;
}

/* Section blocks */
.sp-section {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  overflow: hidden;
  backdrop-filter: var(--blur-light);
  box-shadow: var(--shadow-sm);
}
.sp-section-header {
  display: flex; align-items: center; gap: 10px;
  padding: 12px 16px;
  cursor: pointer;
  user-select: none;
  transition: background .1s;
}
.sp-section-header:hover { background: var(--bg-elevated); }
.sp-section-chevron {
  font-size: 10px; color: var(--text-muted);
  transition: transform .2s;
  width: 14px; text-align: center;
}
.sp-section.open .sp-section-chevron { transform: rotate(90deg); }
.sp-section-icon {
  font-size: 13px; width: 20px; text-align: center;
}
.sp-section-title {
  font-size: 11px; font-weight: 700;
  letter-spacing: .4px; color: var(--text-primary);
  text-transform: uppercase;
}
.sp-section-badge {
  font-size: 9px; color: var(--text-muted);
  margin-left: auto; font-weight: 500;
  font-family: var(--font-mono, monospace);
}
.sp-section-body {
  display: none;
  padding: 0 16px 16px;
}
.sp-section.open .sp-section-body { display: block; }
.sp-section-hint {
  font-size: 10px; color: var(--text-muted); line-height: 1.5;
  margin-bottom: 10px;
}

/* Textarea editor */
.sp-textarea {
  width: 100%;
  box-sizing: border-box;
  resize: vertical;
  overflow-y: auto;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 14px;
  font-family: var(--font-mono, 'SF Mono', 'Fira Code', monospace);
  font-size: 12px;
  line-height: 1.7;
  color: var(--text-primary);
  tab-size: 2;
  transition: border-color .2s;
  field-sizing: content;
  min-height: 48px;
}
.sp-textarea:focus {
  outline: none;
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 3px rgba(10,132,255,.1);
}
.sp-textarea::placeholder { color: var(--text-muted); }
.sp-textarea.readonly {
  opacity: .7; cursor: default;
  background: var(--bg-surface);
}

/* Routing section special style */
.sp-routing-auto {
  font-size: 10px; color: var(--accent-green);
  font-weight: 600; display: flex; align-items: center; gap: 4px;
}
.sp-routing-dot {
  width: 5px; height: 5px; border-radius: 50%;
  background: var(--accent-green);
}

/* Token counter */
.sp-token-bar {
  display: flex; justify-content: space-between;
  align-items: center; margin-top: 6px;
  font-size: 10px; color: var(--text-muted);
}
.sp-char-count { font-family: var(--font-mono, monospace); font-variant-numeric: tabular-nums; }

/* â”€â”€ API VAULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#vault-wrap {
  flex: 1; padding: 24px; overflow-y: auto;
  display: flex; flex-direction: column; gap: 0;
}
#vault-toolbar {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 20px;
}
#vault-list { display: flex; flex-direction: column; gap: 12px; }

/* Secret card */
.vault-card {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  backdrop-filter: var(--blur-light);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  transition: border-color .2s;
}
.vault-card:hover { border-color: var(--border-active); }

.vault-card-head {
  display: grid;
  grid-template-columns: 40px 1fr auto;
  align-items: center; gap: 12px;
  padding: 16px 20px;
  cursor: pointer;
  user-select: none;
}
.vault-card-head:hover { background: var(--bg-elevated); }
.vault-card-icon {
  width: 40px; height: 40px;
  border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  font-size: 16px;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
}
.vault-card-info { min-width: 0; }
.vault-card-name {
  font-size: 13px; font-weight: 700; color: var(--text-primary);
  display: flex; align-items: center; gap: 8px;
}
.vault-card-env {
  font-size: 10px; color: var(--text-muted);
  font-family: var(--font-mono, monospace);
  background: var(--bg-elevated); padding: 1px 6px;
  border-radius: 3px; border: 1px solid var(--border);
}
.vault-card-meta {
  font-size: 10px; color: var(--text-muted);
  display: flex; gap: 12px; margin-top: 3px;
}
.vault-card-actions {
  display: flex; gap: 6px; align-items: center;
}
.vault-act-btn {
  width: 28px; height: 28px; border-radius: 6px;
  border: 1px solid var(--border); background: none;
  color: var(--text-muted); cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; transition: all .15s;
  font-family: var(--font-sans);
}
.vault-act-btn:hover { background: var(--bg-surface); color: var(--text-primary); border-color: var(--border-active); }
.vault-act-btn.danger:hover { background: rgba(255,69,58,.1); color: var(--accent-red); border-color: var(--accent-red); }

/* Expanded body */
.vault-card-body {
  display: none;
  padding: 0 20px 16px;
  border-top: 1px solid var(--border);
}
.vault-card.open .vault-card-body { display: block; padding-top: 16px; }

/* Value display */
.vault-value-row {
  display: flex; align-items: center; gap: 6px;
}
.vault-value-display {
  flex: 1;
  font-family: var(--font-mono, monospace);
  font-size: 12px; line-height: 1.6;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  color: var(--text-primary);
  word-break: break-all;
  min-height: 20px;
}
.vault-value-display.masked { color: var(--text-muted); letter-spacing: 2px; }

/* Multi-field list */
.vault-fields-list {
  display: flex; flex-direction: column; gap: 10px;
}
.vault-field-label {
  display: flex; align-items: center; gap: 8px;
  margin-bottom: 5px;
}
.vfl-key {
  font-size: 11px; font-weight: 700; color: var(--text-primary);
}
.vfl-envkey {
  font-size: 9px; color: var(--text-muted);
  font-family: var(--font-mono, monospace);
  background: var(--bg-elevated); padding: 1px 6px;
  border-radius: 3px; border: 1px solid var(--border);
}
.vault-value-toggle {
  padding: 6px 10px; border-radius: 6px;
  border: 1px solid var(--border); background: none;
  font-size: 10px; font-weight: 600; color: var(--text-muted);
  cursor: pointer; white-space: nowrap;
  font-family: var(--font-sans);
  transition: all .15s;
}
.vault-value-toggle:hover { border-color: var(--border-active); color: var(--text-primary); }

/* Agent allow list */
.vault-allow-label {
  font-size: 10px; font-weight: 700; color: var(--text-secondary);
  letter-spacing: .4px; text-transform: uppercase;
  margin-bottom: 8px;
}
.vault-agent-grid {
  display: flex; flex-wrap: wrap; gap: 6px;
}
.vault-agent-chip {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 6px 12px; border-radius: 20px;
  border: 1px solid var(--border);
  background: none; cursor: pointer;
  font-size: 11px; font-weight: 600;
  color: var(--text-muted);
  font-family: var(--font-sans);
  transition: all .15s;
}
.vault-agent-chip:hover { border-color: var(--border-active); }
.vault-agent-chip.allowed {
  border-color: var(--accent-green);
  background: rgba(52,199,89,.08);
  color: var(--text-primary);
}
.vault-agent-chip .vac-dot {
  width: 6px; height: 6px; border-radius: 50%;
}
.vault-agent-chip .vac-check {
  font-size: 10px; color: var(--accent-green);
}

/* Add/edit modal content */
.vault-field { margin-bottom: 14px; }
.vault-field label {
  display: block; font-size: 10px; font-weight: 700;
  color: var(--text-secondary); letter-spacing: .4px;
  text-transform: uppercase; margin-bottom: 5px;
}
.vault-field input, .vault-field textarea {
  width: 100%; box-sizing: border-box;
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 12px;
  font-family: var(--font-mono, monospace);
  font-size: 12px; color: var(--text-primary);
  line-height: 1.5;
}
.vault-field textarea { resize: vertical; min-height: 60px; }
.vault-field input:focus, .vault-field textarea:focus {
  outline: none; border-color: var(--accent-blue);
}
.vault-field .vault-hint {
  font-size: 9px; color: var(--text-muted); margin-top: 4px;
}

/* Empty state */
.vault-empty {
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 80px 20px; gap: 8px;
  color: var(--text-muted);
}
.vault-empty-icon { font-size: 36px; opacity: .25; }
.vault-empty-text { font-size: 14px; font-weight: 600; }
.vault-empty-sub { font-size: 11px; }

/* â”€â”€ REVENUECAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#analytics .rc-wrap { flex: 1; padding: 24px; overflow-y: auto; display: flex; flex-direction: column; gap: 0; }
.rc-toolbar {
  display: flex; align-items: center; margin-bottom: 20px;
}
.rc-app-btn {
  display: flex; align-items: center; gap: 6px;
  padding: 8px 14px; border-radius: var(--radius-sm);
  border: 1px solid var(--border); background: none;
  cursor: pointer; transition: all .2s;
  font-family: var(--font-sans); font-size: 12px; font-weight: 600;
  color: var(--text-secondary);
}
.rc-app-btn:hover { border-color: var(--border-active); }
.rc-app-btn.active { border-color: var(--accent-blue); background: var(--accent-tint); color: var(--text-primary); }
.rc-app-btn .app-icon { font-size: 16px; }
.rc-grid { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
.rc-main { display: flex; flex-direction: column; gap: 16px; }
.rc-sidebar { display: flex; flex-direction: column; gap: 16px; }

/* KPIs */
.rc-kpis { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.rc-kpi {
  padding: 16px;
  background: var(--bg-surface);
  backdrop-filter: var(--blur-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-sm);
}
.rc-kpi .kpi-label { font-size: 11px; color: var(--text-muted); font-weight: 500; }
.rc-kpi .kpi-value {
  font-family: var(--font-display);
  font-size: 26px; font-weight: 700; letter-spacing: -.5px;
  color: var(--text-primary); margin: 4px 0 2px;
}
.rc-kpi .kpi-change {
  font-size: 11px; font-weight: 600;
}
.rc-kpi .kpi-change.up { color: var(--accent-green); }
.rc-kpi .kpi-change.down { color: var(--accent-red); }

/* Chart */
.rc-chart-card { padding: 20px; }
.rc-chart-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 16px;
}
.rc-chart-title { font-size: 11px; color: var(--text-muted); font-weight: 600; }
.rc-chart-value { font-size: 22px; font-weight: 700; color: var(--text-primary); letter-spacing: -.5px; }
.rc-chart { height: 160px; display: flex; align-items: flex-end; gap: 2px; }
.rc-bar {
  flex: 1; border-radius: 3px 3px 0 0;
  background: linear-gradient(180deg, rgba(10,132,255,.35) 0%, rgba(10,132,255,.08) 100%);
  transition: height .5s ease-out;
  min-height: 2px;
  position: relative;
}
.rc-bar:hover { background: linear-gradient(180deg, rgba(10,132,255,.5) 0%, rgba(10,132,255,.15) 100%); }
.rc-bar .rc-bar-tip {
  display: none; position: absolute; top: -28px; left: 50%; transform: translateX(-50%);
  background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 6px;
  padding: 3px 8px; font-size: 10px; color: var(--text-primary); white-space: nowrap;
  font-weight: 600; box-shadow: var(--shadow-sm); z-index: 5;
}
.rc-bar:hover .rc-bar-tip { display: block; }

/* Products */
.rc-products-card { padding: 20px; }
.rc-product-row {
  display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 60px;
  align-items: center; padding: 10px 0;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
}
.rc-product-row.header {
  font-size: 10px; color: var(--text-muted); font-weight: 600;
  border-bottom: 1px solid var(--border-active);
  padding-bottom: 8px;
}
.rc-product-name { display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--text-primary); }
.rc-product-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.rc-product-row .val { color: var(--text-secondary); }
.rc-product-row .val.money { font-weight: 600; color: var(--text-primary); }
.rc-product-bar { height: 4px; background: var(--border); border-radius: 2px; overflow: hidden; }
.rc-product-bar-fill { height: 100%; border-radius: 2px; transition: width .5s; }

/* Funnel */
.rc-funnel-card { padding: 20px; }
.rc-funnel-stages { display: flex; gap: 2px; align-items: flex-end; height: 100px; }
.rc-funnel-stage {
  flex: 1; display: flex; flex-direction: column; align-items: center; gap: 6px;
}
.rc-funnel-bar {
  width: 100%; border-radius: 4px 4px 0 0;
  background: var(--accent-blue);
  transition: height .5s;
  opacity: .8;
}
.rc-funnel-bar:nth-child(1) { opacity: .25; }
.rc-funnel-label { font-size: 9px; color: var(--text-muted); font-weight: 500; text-align: center; }
.rc-funnel-value { font-size: 14px; font-weight: 700; color: var(--text-primary); }
.rc-funnel-pct { font-size: 10px; color: var(--accent-blue); font-weight: 600; }

/* Subscriber status */
.rc-status-card { padding: 20px; }
.rc-status-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 8px 0; border-bottom: 1px solid var(--border);
}
.rc-status-label { font-size: 12px; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; }
.rc-status-dot { width: 6px; height: 6px; border-radius: 50%; }
.rc-status-val { font-size: 13px; font-weight: 600; color: var(--text-primary); }

/* Transaction feed */
.rc-feed-card { padding: 20px; flex: 1; overflow: hidden; display: flex; flex-direction: column; }
.rc-feed-scroll { flex: 1; overflow-y: auto; }
.rc-tx {
  padding: 8px 0; border-bottom: 1px solid var(--border);
  animation: slideUp .3s ease-out both;
}
.rc-tx-row { display: flex; align-items: center; gap: 8px; }
.rc-tx-icon { font-size: 14px; width: 24px; text-align: center; flex-shrink: 0; }
.rc-tx-info { flex: 1; min-width: 0; }
.rc-tx-event { font-size: 11px; font-weight: 600; color: var(--text-primary); }
.rc-tx-product { font-size: 10px; color: var(--text-muted); }
.rc-tx-amount { font-size: 12px; font-weight: 600; text-align: right; }
.rc-tx-amount.positive { color: var(--accent-green); }
.rc-tx-amount.negative { color: var(--accent-red); }
.rc-tx-amount.neutral { color: var(--text-muted); }
.rc-tx-time { font-size: 9px; color: var(--text-muted); text-align: right; min-width: 36px; }

/* â”€â”€ MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.modal-overlay {
  display: none; position: fixed; inset: 0;
  background: var(--modal-bg);
  backdrop-filter: blur(8px);
  z-index: 500;
  align-items: center; justify-content: center;
}
.modal-overlay.open { display: flex; }
.modal {
  width: 420px; padding: 28px;
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
}
.modal h3 {
  font-family: var(--font-display);
  font-size: 18px; font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 18px; letter-spacing: -.2px;
}
.modal label {
  display: block; font-size: 11px;
  color: var(--text-muted); font-weight: 600;
  letter-spacing: .3px;
  margin-bottom: 4px; margin-top: 12px;
}
.modal input, .modal select { width: 100%; }
.modal .modal-actions { display: flex; gap: 10px; margin-top: 18px; }
.modal .modal-actions .btn { flex: 1; padding: 12px; }

/* â”€â”€ 8-BIT AVATAR SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.pixel-art { image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
.avatar-tiny { width:24px; height:34px; flex-shrink:0; }
.avatar-small { width:30px; height:42px; flex-shrink:0; }
.avatar-med { width:36px; height:51px; flex-shrink:0; }
.avatar-lg { width:48px; height:68px; flex-shrink:0; }
.av-picker {
  display: flex; gap: 4px; flex-wrap: wrap;
}
.av-picker .av-swatch {
  width: 24px; height: 24px; border-radius: 6px;
  border: 2px solid transparent; cursor: pointer;
  transition: all .15s;
}
.av-picker .av-swatch:hover { transform: scale(1.15); }
.av-picker .av-swatch.active { border-color: var(--accent-blue); box-shadow: 0 0 8px rgba(10,132,255,.3); }
.av-style-picker {
  display: flex; gap: 4px; flex-wrap: wrap;
}
.av-style-picker .av-option {
  width: 34px; height: 34px; border-radius: 8px;
  border: 2px solid var(--border); cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  font-size: 11px; font-weight: 700; color: var(--text-secondary);
  font-family: var(--font-sans);
  background: var(--bg-surface); transition: all .15s;
}
.av-style-picker .av-option:hover { border-color: var(--border-active); }
.av-style-picker .av-option.active { border-color: var(--accent-blue); background: var(--accent-tint); color: var(--accent-blue); }

/* â”€â”€ BRIEFING ROOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#briefing { flex-direction: row !important; }
#br-room { display: flex; width: 100%; height: 100%; }
#br-table-area {
  flex: 1; position: relative;
  background: var(--warroom-bg);
  overflow: hidden;
  display: flex; flex-direction: column;
}
#br-table {
  position: absolute; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: 280px; height: 160px;
  border-radius: 80px;
  border: 1px solid var(--nexus-ring);
  background: var(--bg-glass);
  backdrop-filter: var(--blur-light);
  display: flex; align-items: center; justify-content: center;
  box-shadow: var(--shadow-md);
}
#br-table-inner {
  text-align: center;
}
.br-topic-label {
  font-size: 10px; color: var(--text-muted);
  letter-spacing: 2px; margin-bottom: 4px;
  font-weight: 600;
}
.br-topic-text {
  font-family: var(--font-display);
  font-size: 15px; font-weight: 600;
  color: var(--text-secondary);
  max-width: 220px;
  line-height: 1.4;
  letter-spacing: -.1px;
}
#br-seats { position: absolute; inset: 0; pointer-events: none; }
.br-seat {
  position: absolute;
  display: flex; flex-direction: column; align-items: center;
  gap: 4px; pointer-events: auto;
  transition: all .3s;
}
.br-seat .seat-avatar {
  width: 52px; height: 72px;
  display: flex; align-items: center; justify-content: center;
  border: 2px solid transparent;
  transition: all .3s;
  position: relative;
  border-radius: var(--radius-sm);
  background: var(--bg-glass);
  backdrop-filter: var(--blur-light);
}
.br-seat .seat-avatar .speaking-ring {
  position: absolute; inset: -5px;
  border-radius: var(--radius-sm);
  border: 2px solid transparent;
  animation: none;
  transition: all .3s;
}
.br-seat.speaking .seat-avatar .speaking-ring {
  animation: speakPulse 1.5s ease-in-out infinite;
}
.br-seat .seat-name {
  font-size: 10px; font-weight: 700;
  letter-spacing: .3px;
}
.br-seat .seat-role {
  font-size: 8px; color: var(--text-muted);
  font-weight: 500;
}
.br-seat .seat-status {
  font-size: 8px; letter-spacing: .5px;
  margin-top: -2px; font-weight: 600;
}
.br-seat.idle .seat-avatar { opacity: .4; }
.br-seat.thinking .seat-status { animation: pulse 1s infinite; }

#br-controls {
  position: absolute; bottom: 20px; left: 24px; right: 24px;
  display: flex; align-items: center; gap: 10px;
}
#br-status {
  animation: pulse 3s infinite;
}

/* Transcript */
#br-transcript {
  width: 400px;
  border-left: 1px solid var(--border);
  background: var(--bg-base);
  backdrop-filter: var(--blur-standard);
  display: flex; flex-direction: column;
}
#br-transcript-scroll {
  flex: 1; overflow-y: auto; padding: 14px 18px;
}
.br-msg {
  margin-bottom: 16px;
  animation: slideUp .35s ease-out both;
}
.br-msg .br-msg-header {
  display: flex; align-items: center; gap: 6px;
  margin-bottom: 4px;
}
.br-msg .br-msg-name {
  font-size: 11px; font-weight: 700; letter-spacing: .2px;
}
.br-msg .br-msg-ts {
  font-size: 9px; color: var(--text-muted); margin-left: auto;
}
.br-msg .br-msg-body {
  font-size: 12px; color: var(--text-secondary);
  line-height: 1.6; padding-left: 14px;
}
.br-msg.system-msg .br-msg-body {
  color: var(--text-muted);
  font-style: italic;
  padding-left: 0;
  text-align: center;
  font-size: 10px;
  font-weight: 500;
}
.br-msg.user-msg .br-msg-body {
  background: var(--accent-tint);
  border: 1px solid rgba(10,132,255,.15);
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  margin-left: 14px;
}

#br-typing-area {
  min-height: 20px; padding: 0 18px;
}
.br-typing {
  font-size: 10px; color: var(--text-muted);
  animation: pulse 1.2s infinite;
}
#br-input-bar {
  padding: 12px 18px;
  border-top: 1px solid var(--border);
  display: flex; gap: 8px;
}
#br-input-bar input { flex: 1; font-size: 12px; border-radius: 20px; padding: 10px 16px; }
#br-action-list {
  padding: 6px 18px 14px;
}
.br-action-item {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 0;
  font-size: 11px; color: var(--text-secondary);
  border-bottom: 1px solid var(--border);
}
.br-action-item .action-agent {
  font-size: 10px; font-weight: 700;
}

/* Agent toggle in modal */
.br-agent-toggle {
  display: flex; align-items: center; gap: 6px;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all .2s;
  background: none;
  font-family: var(--font-sans);
}
.br-agent-toggle:hover { border-color: var(--border-active); }
.br-agent-toggle.selected { border-color: var(--accent-blue); background: var(--accent-tint); }
.br-agent-toggle .toggle-dot {
  width: 8px; height: 8px; border-radius: 50%;
}
.br-agent-toggle .toggle-name { font-size: 11px; font-weight: 600; }

/* â”€â”€ TOAST NOTIFICATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#toast-container {
  position: fixed; top: 60px; right: 20px;
  z-index: 900; display: flex;
  flex-direction: column; gap: 8px;
  pointer-events: none;
}
.toast {
  padding: 12px 18px;
  background: var(--bg-elevated);
  backdrop-filter: var(--blur-standard);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  font-size: 12px; color: var(--text-secondary);
  display: flex; align-items: center; gap: 10px;
  animation: slideUp .3s ease-out both;
  pointer-events: auto;
  max-width: 380px;
  box-shadow: var(--shadow-md);
}
.toast.info { border-left: 3px solid var(--accent-blue); }
.toast.warn { border-left: 3px solid var(--accent-yellow); }
.toast.error { border-left: 3px solid var(--accent-red); }
.toast.success { border-left: 3px solid var(--accent-green); }
.toast .toast-agent { font-weight: 600; font-size: 10px; }
.toast .toast-text { flex: 1; }
.toast-fade { animation: fadeOut .3s ease-out both; }
@keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:.3; } }
</style>
</head>
<body>


<div id="toast-container"></div>

<div id="app">
  <!-- SIDEBAR NAV -->
  <nav id="sidebar">
    <div class="logo">ðŸ¦ž</div>
    <button class="nav-btn add-agent-btn" id="add-agent-btn" title="Add Agent">+<span class="tooltip">ADD AGENT</span></button>
    <button class="nav-btn active" data-view="warroom" title="Org Structure">â—ˆ<span class="tooltip">ORG STRUCTURE</span></button>
    <button class="nav-btn" data-view="chat" title="Agent Chat">â—‡<span class="tooltip">AGENT CHAT</span></button>
    <button class="nav-btn" data-view="calendar" title="Calendar">â–¦<span class="tooltip">CALENDAR</span></button>
    <button class="nav-btn" data-view="marketing" title="Marketing">â—Ž<span class="tooltip">MARKETING</span></button>
    <button class="nav-btn" data-view="tasks" title="Task Board">â˜°<span class="tooltip">TASK BOARD</span></button>
    <button class="nav-btn" data-view="cron" title="Cron Jobs">â±<span class="tooltip">CRON JOBS</span></button>
    <button class="nav-btn" data-view="analytics" title="RevenueCat">â–³<span class="tooltip">REVENUECAT</span></button>
    <button class="nav-btn" data-view="briefing" title="Briefing Room">â¬¡<span class="tooltip">BRIEFING ROOM</span></button>
    <button class="nav-btn" data-view="logs" title="Agent Logs">â–¤<span class="tooltip">AGENT LOGS</span></button>
    <button class="nav-btn" data-view="prompts" title="System Prompts">âœ<span class="tooltip">PROMPTS</span></button>
    <button class="nav-btn" data-view="vault" title="API Vault">âš¿<span class="tooltip">API VAULT</span></button>
    <div class="spacer"></div>
    <button id="theme-toggle" title="Toggle theme">â—‘</button>
    <div id="conn-status" class="disconnected" title="Gateway: disconnected"></div>
    <button class="nav-btn" id="avatar-btn" title="Character Customizer" onclick="openAvatarCustomizer()">â™Ÿ<span class="tooltip">CUSTOMIZE</span></button>
    <button class="nav-btn" id="settings-btn" title="Settings">âš™<span class="tooltip">SETTINGS</span></button>
    <div style="font-size:7px;color:var(--text-muted);text-align:center;opacity:.5;padding:4px 0;letter-spacing:.5px;" id="cc-version">v1.0.0</div>
  </nav>

  <div id="main">
    <!-- TOP BAR -->
    <div id="topbar">
      <span class="view-title" id="view-title">Organization Structure</span>
      <span class="view-sub" id="view-sub">NODE GRAPH EDITOR</span>
      <div class="right">
        <div id="save-status" title="Data status â€” click for details" style="display:flex;align-items:center;gap:4px;font-size:8px;color:var(--text-muted);margin-right:10px;cursor:pointer;user-select:none;">
          <span id="save-dot" style="width:6px;height:6px;border-radius:50%;background:var(--accent-green);transition:background .3s;"></span>
          <span id="save-text">Saved locally</span>
        </div>
        <div class="agent-pills" id="agent-pills"></div>
      </div>
    </div>

    <div id="content">
      <!-- ORGANIZATION STRUCTURE (Node Graph) -->
      <div class="view-panel active" id="warroom">
        <div id="org-canvas">
          <!-- Pannable/zoomable world -->
          <div id="org-world">
            <div class="grid-overlay"></div>
            <svg id="org-wires" style="position:absolute;inset:0;pointer-events:none;z-index:1;overflow:visible;"></svg>
            <svg id="org-wire-preview" style="position:absolute;inset:0;pointer-events:none;z-index:5;overflow:visible;"></svg>
            <div id="org-nodes" style="position:absolute;inset:0;z-index:2;"></div>
          </div>
          <!-- Fixed UI overlays -->
          <div class="org-toolbar">
            <button class="btn" id="org-auto-layout" title="Auto-arrange">âŠž Auto Layout</button>
            <button class="btn" id="org-reset-wires" title="Clear all connections">âœ• Clear Wires</button>
            <button class="btn primary" id="org-export-config" title="Export routing config for agents">â¬¡ Export Routing</button>
            <span id="org-sync-status" style="display:inline-flex;align-items:center;gap:4px;font-size:10px;color:var(--text-muted);font-weight:500;"><span id="org-sync-dot" style="width:6px;height:6px;border-radius:50%;background:var(--text-muted);"></span><span id="org-sync-label">local</span></span>
            <button class="btn" id="org-reset-view" title="Reset pan & zoom">âŠ¡ Reset View</button>
            <span class="org-hint" id="org-hint">Drag ports to connect Â· Drag cards to arrange Â· Right-click wire to delete Â· Scroll to zoom</span>
          </div>
          <div class="org-legend">
            <span class="org-legend-item"><span class="org-legend-dot" style="background:var(--accent-green);"></span> Connected</span>
            <span class="org-legend-item"><span class="org-legend-line"></span> Data Flow</span>
            <span class="org-legend-item" id="org-zoom-label" style="font-variant-numeric:tabular-nums;">100%</span>
          </div>
        </div>
      </div>

      <!-- AGENT CHAT -->
      <div class="view-panel" id="chat">
        <div id="chat-agents">
          <div class="panel-header"><div class="label">AGENTS</div></div>
          <div id="chat-agent-list"></div>
        </div>
        <div id="chat-main">
          <div id="chat-header"></div>
          <div id="chat-messages"></div>
          <div class="typing-indicator" id="chat-typing"><span></span><span></span><span></span></div>
          <div id="chat-input-bar">
            <input type="text" id="chat-input" placeholder="Message agent...">
            <button class="btn primary" id="chat-send">SEND</button>
          </div>
        </div>
      </div>

      <!-- CALENDAR -->
      <div class="view-panel" id="calendar">
        <div id="cal-grid-wrap">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <div>
              <div style="font-size:9px;color:var(--text-muted);letter-spacing:2px;">SCHEDULE</div>
              <div style="display:flex;align-items:center;gap:10px;">
                <button class="btn" id="cal-prev" style="padding:4px 8px;font-size:14px;">â€¹</button>
                <div id="cal-month-label" style="font-family:var(--font-display);font-size:20px;font-weight:700;color:var(--text-primary);min-width:180px;text-align:center;">February 2026</div>
                <button class="btn" id="cal-next" style="padding:4px 8px;font-size:14px;">â€º</button>
                <button class="btn" id="cal-today-btn" style="font-size:9px;padding:4px 10px;">TODAY</button>
              </div>
            </div>
            <button class="btn primary" id="cal-add-btn">+ ADD EVENT</button>
          </div>
          <div id="cal-grid"></div>
        </div>
        <div id="cal-detail">
          <div class="panel-header">
            <div class="label">SELECTED DATE</div>
            <div class="title" id="cal-detail-date">â€”</div>
          </div>
          <div class="detail-scroll" id="cal-detail-events"></div>
        </div>
      </div>

      <!-- MARKETING -->
      <div class="view-panel" id="marketing">
        <div id="mktg-board">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <div>
              <div style="font-size:9px;color:var(--accent-green);letter-spacing:2px;">VIPER MARKETING OPS</div>
              <div style="font-family:var(--font-display);font-size:20px;font-weight:700;color:var(--text-primary);">Campaign Whiteboard</div>
            </div>
            <button class="btn primary" id="camp-add-btn">+ ADD CAMPAIGN</button>
          </div>
          <div class="kpi-row" id="mktg-kpis"></div>
          <div class="campaign-grid" id="campaign-cards"></div>
        </div>
        <div id="mktg-detail">
          <div class="panel-header" id="mktg-detail-header">
            <div class="label">CAMPAIGN DETAIL</div>
            <div class="title">Select a campaign</div>
          </div>
          <div class="detail-scroll" id="mktg-detail-body"></div>
        </div>
      </div>

      <!-- TASKS -->
      <div class="view-panel" id="tasks">
        <div class="board-wrap">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <div>
              <div style="font-size:9px;color:var(--text-muted);letter-spacing:2px;">OPERATIONS</div>
              <div style="font-family:var(--font-display);font-size:20px;font-weight:700;color:var(--text-primary);">Task Board</div>
            </div>
            <button class="btn primary" id="task-add-btn">+ ADD TASK</button>
          </div>
          <div class="board-columns" id="board-columns"></div>
        </div>
      </div>

      <!-- REVENUECAT -->
      <div class="view-panel" id="analytics">
        <div class="rc-wrap">
          <!-- App selector + timeframe -->
          <div class="rc-toolbar">
            <div id="rc-app-selector" style="display:flex;gap:6px;"></div>
            <div style="flex:1;"></div>
            <div id="rc-timeframe" style="display:flex;gap:4px;"></div>
          </div>

          <div class="rc-grid">
            <!-- Left: KPIs + Chart + Products -->
            <div class="rc-main">
              <!-- KPI row -->
              <div class="rc-kpis" id="rc-kpis"></div>

              <!-- MRR Chart -->
              <div class="card rc-chart-card">
                <div class="rc-chart-header">
                  <span class="rc-chart-title">Monthly Recurring Revenue</span>
                  <span class="rc-chart-value" id="rc-mrr-display"></span>
                </div>
                <div class="rc-chart" id="rc-chart"></div>
              </div>

              <!-- Products table -->
              <div class="card rc-products-card">
                <div style="font-size:11px;color:var(--text-muted);font-weight:600;margin-bottom:12px;">PRODUCTS</div>
                <div id="rc-products"></div>
              </div>

              <!-- Conversion funnel -->
              <div class="card rc-funnel-card">
                <div style="font-size:11px;color:var(--text-muted);font-weight:600;margin-bottom:12px;">CONVERSION FUNNEL</div>
                <div id="rc-funnel"></div>
              </div>
            </div>

            <!-- Right: Status + Transactions -->
            <div class="rc-sidebar">
              <!-- Subscriber status -->
              <div class="card rc-status-card">
                <div style="font-size:11px;color:var(--text-muted);font-weight:600;margin-bottom:12px;">SUBSCRIBER STATUS</div>
                <div id="rc-status"></div>
              </div>

              <!-- Live feed -->
              <div class="card rc-feed-card">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                  <span style="font-size:11px;color:var(--text-muted);font-weight:600;">LIVE TRANSACTIONS</span>
                  <span style="width:6px;height:6px;border-radius:50%;background:var(--accent-green);animation:pulse 2s infinite;"></span>
                </div>
                <div id="rc-feed"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- BRIEFING ROOM -->
      <div class="view-panel" id="briefing">
        <div id="br-room">
          <!-- Conference table visualization -->
          <div id="br-table-area">
            <div class="grid-overlay"></div>
            <div id="br-table">
              <div id="br-table-inner">
                <div id="br-topic-display">
                  <div class="br-topic-label">AWAITING BRIEFING</div>
                  <div class="br-topic-text" id="br-topic-text">No active meeting</div>
                </div>
              </div>
            </div>
            <!-- Agent seats injected by JS -->
            <div id="br-seats"></div>
            <div id="br-controls">
              <button class="btn primary" id="br-start-btn">â–¶ START MEETING</button>
              <button class="btn" id="br-interject-btn" style="display:none;">âœ‹ INTERJECT</button>
              <button class="btn" id="br-end-btn" style="display:none;color:var(--accent-red);border-color:rgba(255,82,82,.2);">â–  END MEETING</button>
              <div id="br-status" style="font-size:9px;color:var(--text-muted);letter-spacing:1px;margin-left:auto;">STANDBY</div>
            </div>
          </div>

          <!-- Transcript panel -->
          <div id="br-transcript">
            <div class="panel-header">
              <div class="label">MEETING TRANSCRIPT</div>
              <div style="display:flex;gap:6px;margin-top:6px;">
                <span class="br-meta" id="br-msg-count">0 messages</span>
                <span class="br-meta" id="br-duration">00:00</span>
              </div>
            </div>
            <div id="br-transcript-scroll"></div>
            <div id="br-typing-area"></div>
            <div id="br-input-bar" style="display:none;">
              <input type="text" id="br-input" placeholder="Interject in the meeting...">
              <button class="btn primary" id="br-input-send">SEND</button>
            </div>
            <div id="br-action-items" style="display:none;">
              <div style="font-size:9px;color:var(--accent-green);letter-spacing:2px;padding:8px 16px;border-top:1px solid var(--border);">ACTION ITEMS</div>
              <div id="br-action-list"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- CRON JOBS -->
      <div class="view-panel" id="cron">
        <div class="cron-wrap">
          <div class="cron-header">
            <div>
              <div class="cron-count" id="cron-count">0 active Â· 0 paused</div>
            </div>
            <button class="btn primary" id="cron-add-btn">+ New Cron Job</button>
          </div>
          <div class="cron-list" id="cron-list"></div>
        </div>
      </div>

      <!-- AGENT LOGS -->
      <div class="view-panel" id="logs">
        <div id="logs-agents">
          <div class="panel-header"><div class="label">AGENTS</div></div>
          <div id="logs-agent-list"></div>
        </div>
        <div id="logs-main">
          <div id="logs-toolbar">
            <div id="logs-filters"></div>
            <div id="logs-meta"></div>
          </div>
          <div id="logs-feed"></div>
        </div>
      </div>

      <!-- SYSTEM PROMPTS -->
      <div class="view-panel" id="prompts">
        <div id="sp-agents">
          <div class="panel-header"><div class="label">AGENTS</div></div>
          <div id="sp-agent-list"></div>
        </div>
        <div id="sp-editor">
          <div id="sp-header">
            <div id="sp-agent-info"></div>
            <div id="sp-actions">
              <span id="sp-save-status"></span>
              <button class="btn" id="sp-revert-btn">â†© Revert</button>
              <button class="btn" id="sp-copy-btn">âŽ˜ Copy All</button>
              <button class="btn primary" id="sp-save-btn">â¬¡ Save & Push</button>
            </div>
          </div>
          <div id="sp-sections"></div>
        </div>
      </div>

      <!-- API VAULT -->
      <div class="view-panel" id="vault">
        <div id="vault-wrap">
          <div id="vault-toolbar">
            <div>
              <div style="font-size:9px;color:var(--text-muted);letter-spacing:2px;">SECRETS</div>
              <div style="font-family:var(--font-display);font-size:20px;font-weight:700;color:var(--text-primary);">API Vault</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center;">
              <span id="vault-count" style="font-size:10px;color:var(--text-muted);font-weight:500;"></span>
              <button class="btn primary" id="vault-add-btn">+ Add Secret</button>
            </div>
          </div>
          <div id="vault-list"></div>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- MEETING START MODAL -->
<div class="modal-overlay" id="br-modal">
  <div class="modal">
    <h3>â¬¡ Start Briefing</h3>
    <label>MEETING TOPIC</label>
    <input type="text" id="br-modal-topic" placeholder="e.g. Q1 campaign strategy review">
    <label>MEETING TYPE</label>
    <select id="br-modal-type">
      <option value="strategy">Strategy Session</option>
      <option value="standup">Daily Standup</option>
      <option value="review">Performance Review</option>
      <option value="incident">Incident Response</option>
      <option value="brainstorm">Brainstorm</option>
      <option value="planning">Sprint Planning</option>
    </select>
    <label>PARTICIPANTS</label>
    <div id="br-modal-agents" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:4px;"></div>
    <div class="modal-actions">
      <button class="btn" onclick="document.getElementById('br-modal').classList.remove('open')">CANCEL</button>
      <button class="btn primary" onclick="startMeeting()">START</button>
    </div>
  </div>
</div>

<!-- CHARACTER CUSTOMIZER MODAL -->
<div class="modal-overlay" id="avatar-modal">
  <div class="modal" style="max-width:520px;">
    <h3>ðŸŽ® Character Customizer</h3>
    <div style="display:flex;gap:20px;">
      <!-- Preview -->
      <div style="flex-shrink:0;text-align:center;">
        <div id="av-preview" style="background:var(--bg-deep);border:1px solid var(--border);border-radius:8px;padding:16px 20px;margin-bottom:8px;"></div>
        <select id="av-agent-select" style="width:100%;font-size:10px;"></select>
      </div>
      <!-- Controls -->
      <div style="flex:1;display:flex;flex-direction:column;gap:8px;overflow-y:auto;max-height:380px;" id="av-controls">
        <label>SKIN TONE</label>
        <div class="av-picker" id="av-skin" data-prop="skin"></div>
        <label>HAIR COLOR</label>
        <div class="av-picker" id="av-hair-color" data-prop="hairColor"></div>
        <label>HAIRSTYLE</label>
        <div class="av-style-picker" id="av-hair" data-prop="hair" data-max="8"></div>
        <label>EYES</label>
        <div class="av-style-picker" id="av-eyes" data-prop="eyes" data-max="5"></div>
        <label>MOUTH</label>
        <div class="av-style-picker" id="av-mouth" data-prop="mouth" data-max="4"></div>
        <label>BODY STYLE</label>
        <div class="av-style-picker" id="av-body" data-prop="bodyType" data-max="3"></div>
        <label>ACCESSORY</label>
        <div class="av-style-picker" id="av-accessory" data-prop="accessory" data-max="6"></div>
        <label>CLOTHES COLOR</label>
        <div class="av-picker" id="av-clothes" data-prop="clothes"></div>
        <label>PANTS COLOR</label>
        <div class="av-picker" id="av-pants" data-prop="pants"></div>
        <label>SHOE COLOR</label>
        <div class="av-picker" id="av-shoes" data-prop="shoes"></div>
        <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
          <label style="margin:0;">BLUSH</label>
          <input type="checkbox" id="av-blush" style="width:auto;">
        </div>
      </div>
    </div>
    <div class="modal-actions" style="margin-top:12px;">
      <button class="btn" onclick="document.getElementById('avatar-modal').classList.remove('open')">CLOSE</button>
      <button class="btn" onclick="randomizeAvatar()">ðŸŽ² RANDOMIZE</button>
      <button class="btn primary" onclick="saveAvatar()">SAVE</button>
    </div>
  </div>
</div>

<div id="settings-overlay">
  <div id="settings-modal">
    <h3>âš™ Gateway Connection</h3>
    <label>GATEWAY URL</label>
    <input type="text" id="cfg-url" placeholder="ws://127.0.0.1:18789">
    <label>AUTH TOKEN</label>
    <input type="password" id="cfg-token" placeholder="paste from openclaw dashboard">
    <label>AGENTS (JSON array of {id, name, role, color})</label>
    <textarea id="cfg-agents" rows="6" style="width:100%;font-size:10px;"></textarea>
    <div class="actions">
      <button class="btn" id="cfg-copy-link">COPY INSTALL LINK</button>
      <button class="btn" onclick="closeSettings()">CANCEL</button>
      <button class="btn primary" onclick="saveSettings()">CONNECT</button>
    </div>
    <div style="margin-top:14px;font-size:9px;color:var(--text-muted);line-height:1.6;">
      <strong style="color:var(--accent-green);">Setup:</strong> Drop this file at
      <code style="color:var(--text-secondary);">~/.openclaw/workspace/canvas/index.html</code><br>
      Served at <code style="color:var(--text-secondary);">http://&lt;host&gt;:18793/__openclaw__/canvas/</code><br>
      Agents can push updates via <code style="color:var(--text-secondary);">canvas.eval</code><br>
      One-click install format (tokens are auto-scrubbed from URLs after load):
      <code style="color:var(--text-secondary);">...?gateway=ws://&lt;host&gt;:18789&token=&lt;AUTH_TOKEN&gt;</code>
      (or use <code style="color:var(--text-secondary);">#agent=&lt;agentLink&gt;</code> with a full ws/wss or OpenClaw URL in the URL fragment).
      Compatible with OpenClaw style params too: <code style="color:var(--text-secondary);">?gatewayUrl=ws://...&token=...</code>
    </div>
    <hr style="border:none;border-top:1px solid var(--border);margin:14px 0 10px;">
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
      <strong style="font-size:10px;color:var(--text-secondary);">Gateway Persistence</strong>
      <label style="display:flex;align-items:center;gap:4px;font-size:9px;color:var(--text-muted);cursor:pointer;">
        <input type="checkbox" id="cfg-gw-sync" style="width:auto;" checked>
        Sync state to gateway
      </label>
      <span id="cfg-sync-status" style="font-size:8px;color:var(--text-muted);margin-left:auto;"></span>
    </div>
    <div style="font-size:8px;color:var(--text-muted);line-height:1.6;margin-bottom:10px;">
      When enabled, your dashboard state is saved to <code style="color:var(--text-secondary);">~/.openclaw/workspace/canvas/state/</code> on the gateway host.<br>
      Reconnecting from any browser restores your data automatically. Recovery chain: <strong style="color:var(--text-secondary);">Gateway â†’ IndexedDB â†’ localStorage â†’ Defaults</strong>
    </div>
    <hr style="border:none;border-top:1px solid var(--border);margin:4px 0 10px;">
    <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
      <button class="btn" id="cfg-export" style="font-size:9px;">â¤“ Export State</button>
      <button class="btn" id="cfg-import" style="font-size:9px;">â¤’ Import State</button>
      <button class="btn" id="cfg-backup-now" style="font-size:9px;">â—‰ Backup Now</button>
      <button class="btn" id="cfg-gw-push" style="font-size:9px;">â†‘ Push to Gateway</button>
      <button class="btn" id="cfg-gw-pull" style="font-size:9px;">â†“ Pull from Gateway</button>
      <button class="btn" id="cfg-reset" style="font-size:9px;color:var(--accent-red);border-color:var(--accent-red);">âš  Reset All Data</button>
    </div>
    <div id="cfg-backup-list" style="margin-top:10px;max-height:140px;overflow-y:auto;"></div>
    <input type="file" id="cfg-import-file" accept=".json" style="display:none;">
  </div>
</div>

<!-- ADD EVENT MODAL -->
<div class="modal-overlay" id="cal-modal">
  <div class="modal">
    <h3>+ New Event</h3>
    <label>TITLE</label><input type="text" id="ev-title">
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      <div><label>TIME</label><input type="time" id="ev-time" value="09:00"></div>
      <div><label>AGENT</label><select id="ev-agent"></select></div>
    </div>
    <label>TYPE</label>
    <select id="ev-type">
      <option value="meeting">Meeting</option><option value="deploy">Deploy</option>
      <option value="research">Research</option><option value="launch">Launch</option>
      <option value="review">Review</option><option value="delivery">Delivery</option>
    </select>
    <div class="modal-actions">
      <button class="btn" onclick="document.getElementById('cal-modal').classList.remove('open')">CANCEL</button>
      <button class="btn primary" onclick="addCalEvent()">ADD</button>
    </div>
  </div>
</div>

<!-- ADD TASK MODAL -->
<div class="modal-overlay" id="task-modal">
  <div class="modal">
    <h3>+ New Task</h3>
    <label>TITLE</label><input type="text" id="new-task-title">
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      <div><label>AGENT</label><select id="new-task-agent"></select></div>
      <div><label>PRIORITY</label>
        <select id="new-task-priority">
          <option value="high">High</option><option value="medium">Medium</option><option value="low">Low</option>
        </select>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn" onclick="document.getElementById('task-modal').classList.remove('open')">CANCEL</button>
      <button class="btn primary" onclick="addTask()">ADD</button>
    </div>
  </div>
</div>

<!-- Campaign Modal -->
<div class="modal-overlay" id="camp-modal">
  <div class="modal" style="width:520px;">
    <h3 id="camp-modal-title">â—Ž New Campaign</h3>
    <label>CAMPAIGN NAME</label>
    <input type="text" id="camp-m-name" placeholder="e.g. Spring Launch Blitz">
    <div class="am-row" style="display:flex;gap:12px;">
      <div style="flex:1;"><label>PLATFORM</label>
        <select id="camp-m-platform"><option>Google Ads</option><option>Meta Ads</option><option>TikTok</option><option>X / Twitter</option><option>LinkedIn</option><option>Reddit</option><option>App Store</option><option>Organic</option><option>Email</option><option>Other</option></select>
      </div>
      <div style="flex:1;"><label>STATUS</label>
        <select id="camp-m-status"><option value="draft">Draft</option><option value="scheduled">Scheduled</option><option value="active">Active</option></select>
      </div>
    </div>
    <div class="am-row" style="display:flex;gap:12px;">
      <div style="flex:1;"><label>BUDGET</label><input type="text" id="camp-m-budget" placeholder="e.g. $5,000"></div>
      <div style="flex:1;"><label>AUDIENCE</label><input type="text" id="camp-m-audience" placeholder="e.g. iOS developers 25-44"></div>
    </div>
    <div class="modal-actions">
      <button class="btn" onclick="document.getElementById('camp-modal').classList.remove('open')">CANCEL</button>
      <button class="btn primary" onclick="addCampaignFromModal()">CREATE</button>
    </div>
  </div>
</div>

<!-- Export Routing Config Modal -->
<div class="modal-overlay" id="routing-modal">
  <div class="modal" style="width:600px;max-height:80vh;display:flex;flex-direction:column;">
    <h3>â¬¡ Routing Configuration</h3>
    <div style="font-size:11px;color:var(--text-muted);margin-bottom:12px;">
      Drop these into each agent's <code style="color:var(--text-secondary);">$include</code> config or system prompt.
      Agents will self-enforce routing based on their node graph connections.
    </div>
    <div id="routing-config-content" style="flex:1;overflow-y:auto;background:var(--bg-surface);border:1px solid var(--border);border-radius:var(--radius-sm);padding:16px;font-family:var(--font-mono,'monospace');font-size:11px;line-height:1.7;white-space:pre-wrap;color:var(--text-secondary);max-height:50vh;"></div>
    <div class="modal-actions">
      <button class="btn" onclick="document.getElementById('routing-modal').classList.remove('open')">CLOSE</button>
      <button class="btn" onclick="copyRoutingConfig('individual')">COPY PER-AGENT</button>
      <button class="btn primary" onclick="copyRoutingConfig('full')">COPY ALL</button>
    </div>
  </div>
</div>

<!-- CRON JOB MODAL -->
<div class="modal-overlay" id="cron-modal">
  <div class="modal" style="width:560px;">
    <h3 id="cron-modal-title">â± New Cron Job</h3>
    <label>JOB NAME</label>
    <input type="text" id="cron-m-name" placeholder="e.g. Daily Intel Brief">

    <label>ASSIGN AGENTS</label>
    <div class="cron-agent-picker" id="cron-m-agents"></div>

    <label>SCHEDULE</label>
    <div class="cron-preset-row" id="cron-m-presets"></div>

    <div id="cron-m-custom-area" style="display:none;">
      <label style="margin-top:10px;">TIME</label>
      <input type="time" id="cron-m-time" value="09:00" style="width:120px;">

      <label style="margin-top:10px;">DAYS</label>
      <div class="cron-day-picker" id="cron-m-days"></div>

      <label style="margin-top:10px;">INTERVAL (optional)</label>
      <div style="display:flex;gap:8px;align-items:center;">
        <span style="font-size:11px;color:var(--text-muted);">Every</span>
        <input type="number" id="cron-m-interval" value="1" min="1" max="60" style="width:60px;">
        <select id="cron-m-interval-unit" style="width:100px;">
          <option value="minutes">minutes</option>
          <option value="hours">hours</option>
          <option value="days" selected>days</option>
        </select>
      </div>
    </div>

    <div class="cron-expr-row" style="margin-top:10px;">
      <label style="display:flex;align-items:center;gap:6px;">
        <span>CRON EXPRESSION</span>
        <span style="font-size:9px;color:var(--text-muted);">(auto-generated or edit manually)</span>
      </label>
      <input type="text" id="cron-m-expr" placeholder="* * * * *" style="font-family:var(--font-mono,'monospace');letter-spacing:1px;">
      <div class="cron-expr-hint" id="cron-m-expr-hint" style="font-size:10px;color:var(--text-muted);margin-top:4px;"></div>
    </div>

    <label style="margin-top:10px;">AGENT INSTRUCTIONS</label>
    <textarea id="cron-m-message" rows="3" placeholder="What should the agent(s) do when this job fires?"></textarea>

    <div class="modal-actions">
      <button class="btn" onclick="closeCronModal()">CANCEL</button>
      <button class="btn primary" onclick="saveCronJob()">SAVE JOB</button>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPENCLAW COMMAND CENTER â€” Runtime
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ CONFIG & STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LLM_MODELS = [
  { id: 'claude-opus-4-6', name: 'Claude Opus 4.6', provider: 'Anthropic', tier: 'flagship' },
  { id: 'claude-sonnet-4-5-20250929', name: 'Claude Sonnet 4.5', provider: 'Anthropic', tier: 'balanced' },
  { id: 'claude-haiku-4-5-20251001', name: 'Claude Haiku 4.5', provider: 'Anthropic', tier: 'fast' },
  { id: 'gpt-4o', name: 'GPT-4o', provider: 'OpenAI', tier: 'flagship' },
  { id: 'gpt-4o-mini', name: 'GPT-4o Mini', provider: 'OpenAI', tier: 'fast' },
  { id: 'o3', name: 'o3', provider: 'OpenAI', tier: 'reasoning' },
  { id: 'o4-mini', name: 'o4 Mini', provider: 'OpenAI', tier: 'reasoning' },
  { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro', provider: 'Google', tier: 'flagship' },
  { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', provider: 'Google', tier: 'fast' },
  { id: 'deepseek-r1', name: 'DeepSeek R1', provider: 'DeepSeek', tier: 'reasoning' },
  { id: 'llama-3.3-70b', name: 'Llama 3.3 70B', provider: 'Meta', tier: 'open' },
  { id: 'ollama-local', name: 'Ollama (Local)', provider: 'Local', tier: 'local' },
  { id: 'custom', name: 'Custom Endpoint', provider: 'Custom', tier: 'custom' },
];

const AGENT_COLORS = [
  '#0a84ff','#34c759','#ff9f0a','#bf5af2','#ff453a','#ffd60a',
  '#30d5c8','#ff6b6b','#64d2ff','#ff9ff3','#a29bfe','#00b894',
  '#e17055','#6c5ce7','#fdcb6e','#e84393','#00cec9','#fab1a0',
];

const DEFAULT_AGENTS = [
  { id: "viper", name: "VIPER", role: "Marketing", color: "#34c759", model: "claude-sonnet-4-5-20250929", admin: true, skills: ["Ad Campaigns","SEO","Content Strategy","Social Media"], personality: "Creative strategist with data-driven instincts" },
  { id: "atlas", name: "ATLAS", role: "Operations", color: "#0a84ff", model: "claude-opus-4-6", admin: true, skills: ["Scheduling","Workflow","Resource Allocation","Process Optimization"], personality: "Methodical planner and efficiency optimizer" },
  { id: "oracle", name: "ORACLE", role: "Research", color: "#ff9f0a", model: "claude-opus-4-6", admin: true, skills: ["Market Analysis","Competitor Intel","Trend Forecasting","Data Mining"], personality: "Deep analyst with pattern recognition expertise" },
  { id: "forge", name: "FORGE", role: "Development", color: "#bf5af2", model: "claude-sonnet-4-5-20250929", admin: true, skills: ["Code Review","Architecture","DevOps","Security Audits"], personality: "Technical architect and security-minded builder" },
];

let state = {
  gatewayUrl: __agentInstallConfig.gatewayUrl || localStorage.getItem('oc_gw_url') || 'ws://127.0.0.1:18789',
  authToken: __agentInstallConfig.hasToken ? __agentInstallConfig.authToken : (localStorage.getItem('oc_gw_token') || ''),
  gatewayModels: JSON.parse(localStorage.getItem('oc_gatewayModels') || 'null') || [],
  agents: JSON.parse(localStorage.getItem('oc_agents') || 'null') || DEFAULT_AGENTS,
  ws: null,
  connected: false,
  activeView: 'warroom',
  activeChat: DEFAULT_AGENTS[0]?.id || '',
  selectedDate: new Date().toISOString().split('T')[0],
  selectedCampaign: null,
  calViewYear: new Date().getFullYear(),
  calViewMonth: new Date().getMonth(),
  chatMessages: {},
  warChatter: [],
  orgPositions: {
    atlas:  { x: 340, y: 40 },
    viper:  { x: 120, y: 240 },
    oracle: { x: 560, y: 240 },
    forge:  { x: 340, y: 440 },
  },
  orgConnections: [],
  calEvents: [],
  tasks: [],
  cronJobs: [],
  activityLog: [],
  logSelectedAgent: 'all',
  logActiveFilters: new Set(['task','cron','comms','system','error']),
  promptSelectedAgent: DEFAULT_AGENTS[0]?.id || '',
  agentPrompts: {},
  vault: [],
  campaigns: [],
  campaignTasks: {},
  analyticsTimeframe: '7d',
  agentStatus: {},
  rc: {
    apps: [],
    selectedApp: '',
    timeframe: '30d',
    mrr: 0, mrrChange: 0,
    revenue: 0, revenueChange: 0,
    activeSubscribers: 0, subscribersChange: 0,
    activeTrial: 0, trialChange: 0,
    ltv: 0, ltvChange: 0,
    churnRate: 0, churnChange: 0,
    mrrHistory: { '7d': [], '30d': [], '90d': [] },
    revenueHistory: { '7d': [], '30d': [] },
    products: [],
    subscriberStatus: { active:0, trial:0, grace:0, billing_retry:0, expired:0, cancelled:0 },
    funnel: { installs:0, paywallViews:0, trialStarts:0, conversions:0 },
    transactions: [],
    appData: {},
  },
  notifications: [],
  avatarConfigs: {},
  meeting: {
    active: false,
    topic: '',
    messages: [],
    startedAt: null,
    participants: [],
    actionItems: [],
    history: [],  // past meetings
  },
};

if (__agentInstallConfig.gatewayUrl) {
  try { localStorage.setItem('oc_gw_url', state.gatewayUrl); } catch(e) {}
}
if (__agentInstallConfig.hasToken) {
  try { localStorage.setItem('oc_gw_token', state.authToken); } catch(e) {}
}

// Migrate agents: add model/admin fields if missing
state.agents.forEach(a => {
  if (!a.model) a.model = 'claude-sonnet-4-5-20250929';
  if (a.admin === undefined) a.admin = true;
});

// Init chat messages
state.agents.forEach(a => {
  state.chatMessages[a.id] = state.chatMessages[a.id] || [];
});

// â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const getAgent = id => state.agents.find(a => a.id === id);
const ts = () => { const d = new Date(); return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; };

const BOOTSTRAP_GATEWAY_KEYS = [
  'gateway', 'gw', 'ws', 'url', 'gateway_url', 'gateway-url', 'gatewayUrl', 'gateway-url',
  'gw_url', 'gw-url',
  'agent', 'agent_url', 'agent-url', 'agent-link', 'agent-link-url', 'agentlink',
  'openclaw', 'openclaw-url', 'openclaw_url', 'openclaw_gateway', 'openclaw_gateway_url',
  'link'
];
const BOOTSTRAP_TOKEN_KEYS = [
  'token', 'auth', 'auth_token', 'auth-token', 'gw_token', 'gateway_token',
  'agent_token', 'agent-token', 'openid_token', 'access_token', 'authorization'
];
const BOOTSTRAP_STRIP_KEYS = new Set([
  ...BOOTSTRAP_GATEWAY_KEYS.map(k => k.toLowerCase()),
  ...BOOTSTRAP_TOKEN_KEYS.map(k => k.toLowerCase()),
]);

function _sanitizeBootstrapValue(v) {
  if (v == null) return '';
  const decoded = _decodeMaybe(v);
  if (!decoded) return '';
  return decoded.replace(/[\u0000-\u001F\u007F]/g, '').trim();
}

function _sanitizeBootstrapToken(raw) {
  return _sanitizeBootstrapValue(raw).replace(/\s+/g, '');
}

function _isAllowedGatewayCandidate(raw) {
  if (!raw) return false;
  return /^[A-Za-z0-9.\-_:/?&=%+~#@!,()'"]+$/.test(raw);
}

function _decodeMaybe(v) {
  if (v == null) return '';
  try { return decodeURIComponent(String(v)); } catch(e) { return String(v); }
}

function _readBootstrapParam(names, params, hashParams) {
  const lowered = names.map(n => n.toLowerCase());
  for (const [key, value] of params.entries()) {
    if (lowered.includes(key.toLowerCase())) return { value: _sanitizeBootstrapValue(value), has: true, source: 'query' };
  }
  if (hashParams) {
    for (const [key, value] of hashParams.entries()) {
      if (lowered.includes(key.toLowerCase())) return { value: _sanitizeBootstrapValue(value), has: true, source: 'hash' };
    }
  }
  return { value: '', has: false, source: '' };
}

function _parseGatewayCandidate(raw, fallbackToken = '') {
  const value = _sanitizeBootstrapValue(raw);
  if (!value) return { gatewayUrl: '', authToken: '', hasGateway: false, hasToken: false, source: 'candidate' };
  if (!_isAllowedGatewayCandidate(value)) return { gatewayUrl: '', authToken: '', hasGateway: false, hasToken: false, source: 'candidate' };

  const defaultToken = _sanitizeBootstrapToken(fallbackToken);
  if (!_isAllowedGatewayCandidate(defaultToken)) return { gatewayUrl: '', authToken: '', hasGateway: false, hasToken: false, source: 'candidate' };

  const normalized = value
    .replace(/^openclaw\+?wss?:\/\//i, 'wss://')
    .replace(/^openclaw\+?ws:\/\//i, 'ws://')
    .replace(/^openclaw:\/\//i, 'wss://')
    .replace(/^https:\/\//i, 'wss://')
    .replace(/^http:\/\//i, 'ws://');

  let token = defaultToken || '';
  try {
    const parsed = new URL(normalized);
    if (parsed.protocol === 'ws:' || parsed.protocol === 'wss:') {
      const gatewayUrl = `${parsed.protocol}//${parsed.host}${parsed.pathname || ''}`;
      const tokenFromUrl = parsed.searchParams.get('token') || parsed.searchParams.get('auth') || parsed.searchParams.get('auth_token');
      const authToken = _sanitizeBootstrapToken(tokenFromUrl || token || '');
      return {
        gatewayUrl,
        authToken,
        hasGateway: true,
        hasToken: authToken.length > 0,
        source: 'candidate',
      };
    }

    if (parsed.protocol === 'http:' || parsed.protocol === 'https:') {
      const embedded = parsed.searchParams.get('gateway') || parsed.searchParams.get('gw') || parsed.searchParams.get('ws') || parsed.searchParams.get('url');
      const embeddedToken = parsed.searchParams.get('token') || token;
      if (embedded) {
        return _parseGatewayCandidate(embedded, embeddedToken);
      }
    }

    return {
      gatewayUrl: '',
      authToken: token || '',
      hasGateway: false,
      hasToken: !!token,
      source: 'candidate',
    };
  } catch(e) {
    const gatewayUrl = /^wss?:\/\//i.test(normalized) ? normalized : `ws://${normalized}`;
    if (!/^[a-zA-Z][a-zA-Z\d+\-.]*:\/\//.test(gatewayUrl)) return { gatewayUrl: '', authToken: '', hasGateway: false, hasToken: false, source: 'candidate' };
    return {
      gatewayUrl,
      authToken: token || '',
      hasGateway: true,
      hasToken: token !== '',
      source: 'candidate',
    };
  }
}

function _getAgentInstallConfig() {
  const query = new URLSearchParams(location.search);
  const hash = (location.hash || '').replace(/^#/, '');
  const hashParams = hash.includes('=') ? new URLSearchParams(hash) : null;
  const hashRawOnly = (hash && !hash.includes('=')) ? _decodeMaybe(hash) : '';

  const tokenParam = _readBootstrapParam(BOOTSTRAP_TOKEN_KEYS, query, hashParams);
  const gatewayParam = _readBootstrapParam(BOOTSTRAP_GATEWAY_KEYS, query, hashParams);
  const agentParam = _readBootstrapParam(['agent', 'openclaw_agent', 'agent-link', 'agent-link-url'], query, hashParams);

  if (agentParam.has) {
    return { ..._parseGatewayCandidate(agentParam.value, tokenParam.has ? tokenParam.value : ''), source: agentParam.source };
  }

  if (hashRawOnly) {
    const parsed = _parseGatewayCandidate(hashRawOnly, tokenParam.has ? tokenParam.value : '');
    if (parsed.gatewayUrl || parsed.hasToken) return { ...parsed, source: 'hash' };
  }

  if (gatewayParam.has) {
    return { ..._parseGatewayCandidate(gatewayParam.value, tokenParam.has ? tokenParam.value : ''), source: gatewayParam.source };
  }

  if (tokenParam.has) {
    return {
      gatewayUrl: '',
      authToken: tokenParam.value || '',
      hasGateway: false,
      hasToken: true,
      source: tokenParam.source,
    };
  }

  return {
    gatewayUrl: '',
    authToken: '',
    hasGateway: false,
    hasToken: false,
    source: '',
  };
}

function _stripBootstrapFromAddress(config) {
  if (!window.history?.replaceState || !location) return;
  try {
    const url = new URL(location.href);
    let changed = false;

    const removeFrom = (entries, setFn, hasFn) => {
      for (const k of entries) {
        if (BOOTSTRAP_STRIP_KEYS.has(k.toLowerCase())) {
          setFn(k);
          changed = true;
        }
      }
    };

    removeFrom(Array.from(url.searchParams.keys()), (k) => url.searchParams.delete(k));

    const hashText = (url.hash || '').replace(/^#/, '');
    if (!hashText.includes('=')) {
      if (hashText && config.source === 'hash') {
        url.hash = '';
        changed = true;
      }
    } else {
      const hashParams = new URLSearchParams(hashText);
      removeFrom(Array.from(hashParams.keys()), (k) => hashParams.delete(k));
      const nextHash = hashParams.toString();
      const next = nextHash ? `#${nextHash}` : '';
      if (url.hash !== next) {
        url.hash = next;
        changed = true;
      }
    }

    if (changed) history.replaceState({}, '', url.toString());
  } catch(e) {}
}

const __agentInstallConfig = _getAgentInstallConfig();
if (__agentInstallConfig.gatewayUrl || __agentInstallConfig.hasToken) {
  _stripBootstrapFromAddress(__agentInstallConfig);
}

const typeColors = { meeting:"#0a84ff", deploy:"#bf5af2", research:"#ff9f0a", launch:"#34c759", review:"#ffd60a", delivery:"#34c759" };
const priColors = { high:"#ff453a", medium:"#ffd60a", low:"var(--text-muted)" };
const statusColors = { active:"#34c759", scheduled:"#0a84ff", draft:"var(--text-muted)" };

// HTML escape â€” prevents XSS from agent-provided content
function _esc(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.appendChild(document.createTextNode(String(str)));
  return div.innerHTML;
}

// Data size caps â€” prevent unbounded localStorage growth
const DATA_CAPS = {
  chatPerAgent: 200,     // messages per agent
  warChatter: 500,       // total comms messages
  activityLog: 500,      // already existed, enforced here too
  meetingMessages: 300,  // per meeting
};

function _trimChat() {
  Object.keys(state.chatMessages).forEach(id => {
    if (state.chatMessages[id].length > DATA_CAPS.chatPerAgent) {
      state.chatMessages[id] = state.chatMessages[id].slice(-DATA_CAPS.chatPerAgent);
    }
  });
}
function _trimWarChatter() {
  if (state.warChatter.length > DATA_CAPS.warChatter) {
    state.warChatter = state.warChatter.slice(-DATA_CAPS.warChatter);
  }
}

// Rate limiter for canvas_eval â€” prevent runaway agents from flooding
const _canvasEvalTracker = {};
function _canvasEvalAllowed(agentId) {
  const now = Date.now();
  if (!_canvasEvalTracker[agentId]) _canvasEvalTracker[agentId] = [];
  // Purge entries older than 10s
  _canvasEvalTracker[agentId] = _canvasEvalTracker[agentId].filter(t => now - t < 10000);
  if (_canvasEvalTracker[agentId].length >= 50) { // max 50 calls per 10s per agent
    console.warn(`[canvas_eval] Rate limited: ${agentId}`);
    return false;
  }
  _canvasEvalTracker[agentId].push(now);
  return true;
}
// â”€â”€ STORAGE ENGINE (IndexedDB + localStorage dual-write) â”€â”€â”€â”€â”€â”€
// IndexedDB is the source of truth. localStorage is a fast sync cache.
// Automatic versioned backups every 5 minutes. Last 20 kept.
const OC_VERSION = '1.0.0';
const OC_SCHEMA_VERSION = 1;
const IDB_NAME = 'openclaw_command_center';
const IDB_VERSION = 1;
const BACKUP_INTERVAL = 5 * 60 * 1000; // 5 minutes
const MAX_BACKUPS = 20;

// All persisted state keys â€” single source of truth for what gets saved/loaded
const STATE_KEYS = [
  'agents','tasks','calEvents','campaigns','campaignTasks','chatMessages',
  'warChatter','orgPositions','orgConnections','cronJobs','activityLog',
  'agentPrompts','vault','agentStatus','avatarConfigs','rc','meeting_history',
  'gatewayModels',
];
const CONFIG_KEYS = ['gw_url','gw_token'];

const _storage = {
  db: null,
  ready: false,
  _saveTimer: null,
  _lastSaveTs: 0,
  _dirty: false,
  _backupTimer: null,
  // Gateway sync state
  _gatewaySynced: false,
  _gatewayLastAck: 0,
  _gatewaySyncEnabled: true, // user can toggle
  _pendingStateRequest: false,

  // â”€â”€ INIT â”€â”€
  async init() {
    try {
      this.db = await new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, IDB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          // Main state store â€” key/value pairs
          if (!db.objectStoreNames.contains('state')) {
            db.createObjectStore('state', { keyPath: 'key' });
          }
          // Versioned backups
          if (!db.objectStoreNames.contains('backups')) {
            const store = db.createObjectStore('backups', { keyPath: 'id', autoIncrement: true });
            store.createIndex('timestamp', 'timestamp');
          }
        };
      });
      this.ready = true;
      console.log('[Storage] IndexedDB ready');
      return true;
    } catch(e) {
      console.warn('[Storage] IndexedDB unavailable, using localStorage only:', e.message);
      this.ready = false;
      return false;
    }
  },

  // â”€â”€ INDIVIDUAL KEY OPS â”€â”€
  async idbPut(key, value) {
    if (!this.ready) return;
    return new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction('state', 'readwrite');
        tx.objectStore('state').put({ key, value, updatedAt: Date.now() });
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => { console.warn(`[Storage] IDB write failed: ${key}`); resolve(false); };
      } catch(e) { resolve(false); }
    });
  },

  async idbGet(key) {
    if (!this.ready) return null;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction('state', 'readonly');
        const req = tx.objectStore('state').get(key);
        req.onsuccess = () => resolve(req.result?.value ?? null);
        req.onerror = () => resolve(null);
      } catch(e) { resolve(null); }
    });
  },

  // â”€â”€ FULL STATE SNAPSHOT â”€â”€
  _getSerializableState() {
    const snap = {};
    STATE_KEYS.forEach(k => {
      if (k === 'meeting_history') {
        snap[k] = state.meeting?.history || [];
      } else {
        snap[k] = state[k];
      }
    });
    snap._config = {
      gw_url: state.gatewayUrl,
      gw_token: state.authToken,
    };
    snap._schema = OC_SCHEMA_VERSION;
    snap._version = OC_VERSION;
    return snap;
  },

  async persistFullState() {
    const snap = this._getSerializableState();
    this._lastSaveTs = Date.now();
    snap._savedAt = this._lastSaveTs;

    // Write each key to IDB individually (for granular recovery)
    const promises = STATE_KEYS.map(k => this.idbPut('oc_' + k, snap[k]));
    promises.push(this.idbPut('oc_config', snap._config));
    promises.push(this.idbPut('oc_meta', {
      schema: OC_SCHEMA_VERSION,
      version: OC_VERSION,
      savedAt: this._lastSaveTs,
    }));
    await Promise.all(promises);

    // Also write to localStorage (fast sync cache)
    STATE_KEYS.forEach(k => {
      try {
        const val = k === 'meeting_history' ? (state.meeting?.history || []) : state[k];
        localStorage.setItem('oc_' + k, JSON.stringify(val));
      } catch(e) {} // localStorage may fail â€” IDB is primary
    });

    // Push to gateway if connected
    this._syncToGateway(snap);

    this._dirty = false;
    _updateSaveIndicator(this._gatewaySynced ? 'synced' : 'saved');
    console.log(`[Storage] Full state persisted (${Math.round(JSON.stringify(snap).length/1024)}KB)`);
  },

  // â”€â”€ GATEWAY SYNC â”€â”€
  _syncToGateway(snap) {
    if (!this._gatewaySyncEnabled || !state.connected || !state.ws) return;
    try {
      // Strip config (has auth token) â€” gateway already has it
      const payload = { ...snap };
      delete payload._config;
      state.ws.send(JSON.stringify({
        type: 'state_sync',
        savedAt: this._lastSaveTs,
        schema: OC_SCHEMA_VERSION,
        version: OC_VERSION,
        state: payload,
      }));
      console.log('[Sync] State pushed to gateway');
    } catch(e) {
      console.warn('[Sync] Failed to push state to gateway:', e.message);
    }
  },

  requestStateFromGateway() {
    if (!state.connected || !state.ws) return;
    this._pendingStateRequest = true;
    try {
      state.ws.send(JSON.stringify({
        type: 'state_request',
        localSavedAt: this._lastSaveTs || 0,
        schema: OC_SCHEMA_VERSION,
        version: OC_VERSION,
      }));
      console.log('[Sync] Requested state from gateway');
    } catch(e) {
      this._pendingStateRequest = false;
      console.warn('[Sync] state_request failed:', e.message);
    }
  },

  handleStateRestore(msg) {
    // Gateway sends stored state back â€” merge by timestamp
    this._pendingStateRequest = false;

    if (!msg.state) {
      // Gateway has no stored state â€” this is a fresh gateway
      console.log('[Sync] Gateway has no stored state â€” pushing local state');
      this._gatewaySynced = true;
      const snap = this._getSerializableState();
      snap._savedAt = this._lastSaveTs;
      this._syncToGateway(snap);
      _updateSaveIndicator('synced');
      return;
    }

    const gatewaySavedAt = msg.savedAt || msg.state._savedAt || 0;
    const localSavedAt = this._lastSaveTs || 0;

    if (gatewaySavedAt > localSavedAt) {
      // Gateway has newer data â€” restore it
      console.log(`[Sync] Gateway state is newer (gateway: ${new Date(gatewaySavedAt).toLocaleString()}, local: ${localSavedAt ? new Date(localSavedAt).toLocaleString() : 'none'})`);
      this._applySnapshot(msg.state);
      this.createBackup('gateway-restore');
      this.persistFullState();
      renderAll();
      _showToast({ text: 'State restored from gateway', level: 'success', ts: ts() });
    } else if (localSavedAt > gatewaySavedAt) {
      // Local is newer â€” push to gateway
      console.log(`[Sync] Local state is newer â€” pushing to gateway`);
      const snap = this._getSerializableState();
      snap._savedAt = this._lastSaveTs;
      this._syncToGateway(snap);
    } else {
      console.log('[Sync] State in sync with gateway');
    }

    this._gatewaySynced = true;
    _updateSaveIndicator('synced');
  },

  handleStateAck(msg) {
    this._gatewaySynced = true;
    this._gatewayLastAck = msg.savedAt || Date.now();
    _updateSaveIndicator('synced');
    console.log(`[Sync] Gateway confirmed save (${msg.path || 'state/current.json'})`);
  },

  handleGatewayDisconnect() {
    this._gatewaySynced = false;
    this._pendingStateRequest = false;
    _updateSaveIndicator('saved'); // Downgrade from 'synced' to 'saved'
  },

  // â”€â”€ SHARED SNAPSHOT APPLY â”€â”€
  // Used by backup restore, import, and gateway restore
  _applySnapshot(snap) {
    STATE_KEYS.forEach(k => {
      if (k === 'meeting_history') {
        if (snap[k]) state.meeting.history = snap[k];
      } else if (snap[k] !== undefined) {
        state[k] = snap[k];
      }
    });
    if (snap._config) {
      state.gatewayUrl = snap._config.gw_url || state.gatewayUrl;
      state.authToken = snap._config.gw_token || state.authToken;
    }
    // Re-init chat arrays for any agents
    state.agents.forEach(a => {
      state.chatMessages[a.id] = state.chatMessages[a.id] || [];
      state.agentStatus[a.id] = state.agentStatus[a.id] || 'active';
    });
  },

  // Debounced save â€” coalesces rapid writes
  queueSave() {
    this._dirty = true;
    _updateSaveIndicator('saving');
    if (this._saveTimer) clearTimeout(this._saveTimer);
    this._saveTimer = setTimeout(() => this.persistFullState(), 1500);
  },

  // â”€â”€ BACKUPS â”€â”€
  async createBackup(label) {
    if (!this.ready) return null;
    const snap = this._getSerializableState();
    const backup = {
      timestamp: Date.now(),
      label: label || 'auto',
      data: snap,
      size: JSON.stringify(snap).length,
    };
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction('backups', 'readwrite');
        const req = tx.objectStore('backups').add(backup);
        req.onsuccess = () => {
          console.log(`[Backup] Created: ${backup.label} (${Math.round(backup.size/1024)}KB)`);
          resolve(req.result); // returns auto-incremented ID
        };
        req.onerror = () => resolve(null);
        tx.oncomplete = () => this._pruneBackups();
      } catch(e) { resolve(null); }
    });
  },

  async getBackups() {
    if (!this.ready) return [];
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction('backups', 'readonly');
        const req = tx.objectStore('backups').index('timestamp').getAll();
        req.onsuccess = () => resolve((req.result || []).reverse()); // newest first
        req.onerror = () => resolve([]);
      } catch(e) { resolve([]); }
    });
  },

  async restoreBackup(id) {
    if (!this.ready) return false;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction('backups', 'readonly');
        const req = tx.objectStore('backups').get(id);
        req.onsuccess = () => {
          if (!req.result?.data) { resolve(false); return; }
          this._applySnapshot(req.result.data);
          this.persistFullState();
          renderAll();
          console.log(`[Backup] Restored from ${new Date(req.result.timestamp).toLocaleString()}`);
          resolve(true);
        };
        req.onerror = () => resolve(false);
      } catch(e) { resolve(false); }
    });
  },

  async _pruneBackups() {
    if (!this.ready) return;
    try {
      const backups = await this.getBackups();
      if (backups.length <= MAX_BACKUPS) return;
      const toDelete = backups.slice(MAX_BACKUPS); // oldest ones (list is newest-first)
      const tx = this.db.transaction('backups', 'readwrite');
      const store = tx.objectStore('backups');
      toDelete.forEach(b => store.delete(b.id));
      console.log(`[Backup] Pruned ${toDelete.length} old backups`);
    } catch(e) {}
  },

  // â”€â”€ BOOT RECOVERY â”€â”€
  async recoverFromIDB() {
    if (!this.ready) return false;
    try {
      const meta = await this.idbGet('oc_meta');
      if (!meta || !meta.savedAt) return false;

      let recovered = 0;
      for (const k of STATE_KEYS) {
        const val = await this.idbGet('oc_' + k);
        if (val !== null && val !== undefined) {
          if (k === 'meeting_history') {
            state.meeting.history = val;
          } else {
            state[k] = val;
          }
          recovered++;
        }
      }
      const config = await this.idbGet('oc_config');
      if (config) {
        state.gatewayUrl = config.gw_url || state.gatewayUrl;
        state.authToken = config.gw_token || state.authToken;
      }
      console.log(`[Storage] Recovered ${recovered}/${STATE_KEYS.length} keys from IndexedDB (saved ${new Date(meta.savedAt).toLocaleString()})`);
      return recovered > 0;
    } catch(e) {
      console.warn('[Storage] IDB recovery failed:', e);
      return false;
    }
  },

  // â”€â”€ PERIODIC BACKUP TIMER â”€â”€
  startBackupTimer() {
    // Create initial backup on first boot
    setTimeout(() => this.createBackup('boot'), 3000);
    // Then every 5 minutes
    this._backupTimer = setInterval(() => {
      if (this._dirty || Date.now() - this._lastSaveTs > BACKUP_INTERVAL) {
        this.createBackup('auto');
      }
    }, BACKUP_INTERVAL);
  },

  // â”€â”€ EXPORT / IMPORT â”€â”€
  exportToFile() {
    const snap = this._getSerializableState();
    snap._exportedAt = new Date().toISOString();
    snap._version = OC_VERSION;
    const blob = new Blob([JSON.stringify(snap, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `openclaw-backup-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    a.click();
    URL.revokeObjectURL(url);
    _showToast({ text: 'State exported to file', level: 'success', ts: ts() });
  },

  importFromFile(jsonData) {
    try {
      const snap = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
      this._applySnapshot(snap);
      this.persistFullState();
      this.createBackup('import');
      renderAll();
      return true;
    } catch(e) {
      console.error('[Storage] Import failed:', e);
      return false;
    }
  },

  // â”€â”€ FACTORY RESET â”€â”€
  async factoryReset() {
    // Clear localStorage
    Object.keys(localStorage).filter(k => k.startsWith('oc_') || k === 'openclaw-theme').forEach(k => localStorage.removeItem(k));
    // Clear IDB
    if (this.ready) {
      try {
        const tx1 = this.db.transaction('state', 'readwrite');
        tx1.objectStore('state').clear();
        const tx2 = this.db.transaction('backups', 'readwrite');
        tx2.objectStore('backups').clear();
      } catch(e) {}
    }
    location.reload();
  },
};

// â”€â”€ SAVE INDICATOR â”€â”€
function _updateSaveIndicator(status) {
  const dot = $('#save-dot');
  const text = $('#save-text');
  if (!dot || !text) return;
  switch(status) {
    case 'saving':
      dot.style.background = 'var(--accent-yellow)';
      text.textContent = 'Saving...';
      break;
    case 'saved':
      dot.style.background = 'var(--accent-green)';
      text.textContent = 'Saved locally';
      break;
    case 'synced':
      dot.style.background = 'var(--accent-blue)';
      text.textContent = 'Synced';
      break;
    case 'syncing':
      dot.style.background = 'var(--accent-blue)';
      dot.style.animation = 'pulse .8s infinite';
      text.textContent = 'Syncing...';
      return; // don't clear animation
    case 'error':
      dot.style.background = 'var(--accent-red)';
      text.textContent = 'Save error';
      break;
    case 'recovering':
      dot.style.background = 'var(--accent-blue)';
      text.textContent = 'Recovering...';
      break;
    default:
      dot.style.background = 'var(--text-muted)';
      text.textContent = status || 'Unknown';
  }
  dot.style.animation = '';
}

// â”€â”€ PERSISTENCE HELPERS (dual-write: localStorage sync + IDB async) â”€â”€
function _safeSave(key, data) {
  // 1. Sync write to localStorage (fast, for immediate reads)
  try {
    localStorage.setItem(key, JSON.stringify(data));
  } catch(e) {
    if (e.name === 'QuotaExceededError' || e.code === 22) {
      console.warn(`[Storage] localStorage quota exceeded for ${key}`);
      // Don't panic â€” IDB is the real store
    }
  }
  // 2. Queue async full-state persist to IDB
  _storage.queueSave();
}

function _saveTasks() { _safeSave('oc_tasks', state.tasks); }
function _saveCalEvents() { _safeSave('oc_calEvents', state.calEvents); }
function _saveCampaigns() { _safeSave('oc_campaigns', state.campaigns); _safeSave('oc_campaignTasks', state.campaignTasks); }
function _saveChatMessages() { _trimChat(); _safeSave('oc_chatMessages', state.chatMessages); }
function _saveAvatarConfigs() { _safeSave('oc_avatarConfigs', state.avatarConfigs); }
function _saveAgentStatus() { _safeSave('oc_agentStatus', state.agentStatus); }
function _saveMeetingHistory() { _safeSave('oc_meetingHistory', state.meeting.history); }
function _saveRcData() { _safeSave('oc_rc', state.rc); }
function _saveAgents() { _safeSave('oc_agents', state.agents); }
function _saveOrgPositions() { _safeSave('oc_orgPositions', state.orgPositions); }
function _saveOrgConnections() { _safeSave('oc_orgConnections', state.orgConnections); }
function _saveAgentPrompts() { _safeSave('oc_agentPrompts', state.agentPrompts); }
function _saveCronJobs() { _safeSave('oc_cronJobs', state.cronJobs); }
function _saveActivityLog() { _safeSave('oc_activityLog', state.activityLog); }


const CHATTER_POOL = [];

// â”€â”€ 8-BIT AVATAR SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Procedural pixel art character generator
const AV_W = 12, AV_H = 17, AV_SCALE = 3;

const SKIN_TONES = ['#ffdbac','#f5c9a0','#e8b88a','#d4956b','#a67040','#6b4226'];
const HAIR_COLORS = ['#1a1a2e','#3d2b1f','#6b3a2a','#8b6234','#c9a050','#d44d2c','#e8d8c8','#4a2d7a','#2d5a7a','#d4658a'];

function _hashStr(s) { let h = 5381; for (let i = 0; i < s.length; i++) h = ((h << 5) + h + s.charCodeAt(i)) | 0; return Math.abs(h); }
function _seeded(seed) { let s = (seed % 2147483647) || 1; return () => { s = (s * 16807) % 2147483647; return (s - 1) / 2147483646; }; }
function _pick(rng, arr) { return arr[Math.floor(rng() * arr.length)]; }
function _darkenHex(hex, amt) {
  if (!hex || hex.startsWith('var')) return '#333';
  const r = Math.max(0, parseInt(hex.slice(1,3),16) - amt);
  const g = Math.max(0, parseInt(hex.slice(3,5),16) - amt);
  const b = Math.max(0, parseInt(hex.slice(5,7),16) - amt);
  return '#' + [r,g,b].map(c => c.toString(16).padStart(2,'0')).join('');
}
function _lightenHex(hex, amt) {
  if (!hex || hex.startsWith('var')) return '#aaa';
  const r = Math.min(255, parseInt(hex.slice(1,3),16) + amt);
  const g = Math.min(255, parseInt(hex.slice(3,5),16) + amt);
  const b = Math.min(255, parseInt(hex.slice(5,7),16) + amt);
  return '#' + [r,g,b].map(c => c.toString(16).padStart(2,'0')).join('');
}

function generateAvatarConfig(agentId, agentColor) {
  const rng = _seeded(_hashStr(agentId));
  return {
    skin: _pick(rng, SKIN_TONES),
    hairColor: _pick(rng, HAIR_COLORS),
    hair: Math.floor(rng() * 8),
    eyes: Math.floor(rng() * 5),
    mouth: Math.floor(rng() * 4),
    accessory: Math.floor(rng() * 6), // 0=none,1=glasses,2=headband,3=scarf,4=hat,5=earring
    bodyType: Math.floor(rng() * 3),
    clothes: agentColor,
    pants: _darkenHex(agentColor, 90),
    shoes: _pick(rng, ['#2a1f14','#1a1a2e','#8b2020','#e8e8e8','#3a5c3a','#4a3060']),
    blush: rng() > 0.4,
  };
}

function renderAvatar(cfg, scale) {
  scale = scale || AV_SCALE;
  const c = document.createElement('canvas');
  c.width = AV_W * scale; c.height = AV_H * scale;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const px = (x, y, col) => {
    if (x < 0 || x >= AV_W || y < 0 || y >= AV_H || !col) return;
    ctx.fillStyle = col;
    ctx.fillRect(x * scale, y * scale, scale, scale);
  };
  const row = (y, x0, cols) => cols.forEach((col, i) => { if (col) px(x0 + i, y, col); });

  const S = cfg.skin, SD = _darkenHex(S, 30), SL = _lightenHex(S, 20);
  const H = cfg.hairColor, HD = _darkenHex(H, 35);
  const C = cfg.clothes, CD = _darkenHex(C, 45), CL = _lightenHex(C, 30);
  const P = cfg.pants, PD = _darkenHex(P, 30);
  const F = cfg.shoes, FD = _darkenHex(F, 30);
  const O = '#0d0d1a'; // outline
  const W = '#ffffff', BL = '#ff9090'; // white, blush

  // â”€â”€â”€ HEAD (rows 2-8) â”€â”€â”€
  row(2, 3, [O,O,O,O,O,O]);
  row(3, 2, [O,S,S,S,S,S,S,O]);
  row(4, 2, [O,S,S,S,S,S,S,O]); // eye row â€” drawn over
  row(5, 2, [O,S,S,S,S,S,S,O]);
  row(6, 2, [O,S,S,S,S,S,S,O]);
  row(7, 3, [O,S,S,S,S,O]);
  row(8, 4, [O,S,S,O]);

  // â”€â”€â”€ EYES (row 4) â”€â”€â”€
  const eyeDraws = [
    // 0: dot
    () => { px(4,4,O); px(7,4,O); },
    // 1: wide open (cute)
    () => { px(4,3,O); px(4,4,O); px(5,3,W); px(7,3,O); px(7,4,O); px(8,3,W); },
    // 2: happy closed ^_^
    () => { px(4,4,O); px(3,3,O); px(5,3,O); px(7,4,O); px(6,3,O); px(8,3,O); },
    // 3: determined
    () => { px(3,3,O); px(4,4,O); px(5,4,O); px(6,3,O); px(7,4,O); px(8,4,O); },
    // 4: sparkle
    () => { px(4,3,O); px(4,4,O); px(3,4,W); px(5,3,W); px(7,3,O); px(7,4,O); px(6,4,W); px(8,3,W); },
  ];
  (eyeDraws[cfg.eyes] || eyeDraws[0])();

  // â”€â”€â”€ BLUSH â”€â”€â”€
  if (cfg.blush) { px(3,5,BL); px(8,5,BL); }

  // â”€â”€â”€ MOUTH (row 6-7) â”€â”€â”€
  const mouthDraws = [
    // 0: smile
    () => { px(5,6,O); px(6,6,O); px(4,6,SD); px(7,6,SD); },
    // 1: neutral
    () => { px(5,6,O); px(6,6,O); },
    // 2: cat :3
    () => { px(5,6,O); px(4,7,O); px(6,7,O); },
    // 3: grin
    () => { px(4,6,O); px(5,6,'#ff6b6b'); px(6,6,'#ff6b6b'); px(7,6,O); },
  ];
  (mouthDraws[cfg.mouth] || mouthDraws[0])();

  // â”€â”€â”€ BODY / SHIRT (rows 9-12) â”€â”€â”€
  const bodyDraws = [
    // 0: standard tee
    () => {
      row(9, 4, [O,C,C,O]);
      row(10, 3, [O,C,C,C,C,O]);
      row(11, 2, [O,S,O,C,C,C,C,O,S,O]);
      row(12, 2, [0,S,O,C,C,C,C,O,S]);
      row(13, 3, [0,O,C,C,C,C,O]);
    },
    // 1: jacket / open front
    () => {
      row(9, 4, [O,C,C,O]);
      row(10, 3, [O,C,CD,CL,CL,CD,C,O]);
      row(11, 2, [O,S,O,C,CD,CL,CD,C,O,S,O]);
      row(12, 2, [0,S,O,C,CD,CL,CD,C,O,S]);
      row(13, 3, [0,O,C,CD,CD,C,O]);
    },
    // 2: tank / vest
    () => {
      row(9, 4, [O,C,C,O]);
      row(10, 3, [O,S,C,C,C,C,S,O]);
      row(11, 2, [O,S,O,C,C,C,C,O,S,O]);
      row(12, 2, [0,S,O,C,C,C,C,O,S]);
      row(13, 3, [0,O,C,C,C,C,O]);
    },
  ];
  (bodyDraws[cfg.bodyType] || bodyDraws[0])();

  // â”€â”€â”€ PANTS (rows 14-15) â”€â”€â”€
  row(14, 3, [0,O,P,P,P,P,O]);
  row(15, 3, [0,O,P,O,O,P,O]);

  // â”€â”€â”€ SHOES (row 16) â”€â”€â”€
  row(16, 3, [O,F,F,O,O,F,F,O]);

  // â”€â”€â”€ HAIR (drawn last, overlays head) â”€â”€â”€
  const hairDraws = [
    // 0: short crop
    () => {
      row(1, 3, [H,H,H,H,H,H]);
      row(2, 2, [H,H,H,H,H,H,H,H]);
      px(2,3,H); px(9,3,H);
    },
    // 1: spiky
    () => {
      px(3,0,H); px(5,0,H); px(8,0,H);
      row(1, 2, [H,H,H,H,H,H,H,H]);
      row(2, 2, [H,H,H,H,H,H,H,H]);
      px(2,3,H); px(9,3,H);
    },
    // 2: long flowing
    () => {
      row(1, 3, [H,H,H,H,H,H]);
      row(2, 2, [H,H,H,H,H,H,H,H]);
      px(2,3,H); px(9,3,H);
      px(2,4,H); px(9,4,H);
      px(2,5,H); px(9,5,H);
      px(1,6,HD); px(10,6,HD);
      px(1,7,HD); px(10,7,HD);
      px(1,8,HD); px(10,8,HD);
      px(1,9,HD); px(10,9,HD);
    },
    // 3: mohawk
    () => {
      px(5,0,H); px(6,0,H);
      px(5,1,H); px(6,1,H);
      row(2, 3, [HD,HD,H,H,HD,HD]);
      px(2,3,HD); px(9,3,HD);
    },
    // 4: bowl cut
    () => {
      row(1, 3, [H,H,H,H,H,H]);
      row(2, 2, [H,H,H,H,H,H,H,H]);
      row(3, 2, [H,H,H,H,H,H,H,H]);
      px(2,4,H); px(3,4,H); px(8,4,H); px(9,4,H);
    },
    // 5: ponytail
    () => {
      row(1, 3, [H,H,H,H,H,H]);
      row(2, 2, [H,H,H,H,H,H,H,H]);
      px(2,3,H); px(9,3,H);
      // ponytail extension
      px(10,2,H); px(11,3,H); px(11,4,HD); px(11,5,HD); px(11,6,HD);
    },
    // 6: messy / wild
    () => {
      px(2,0,H); px(4,0,H); px(7,0,H); px(9,0,H);
      row(1, 2, [H,H,H,H,H,H,H,H]);
      row(2, 1, [H,H,H,H,H,H,H,H,H,H]);
      px(1,3,H); px(2,3,H); px(9,3,H); px(10,3,H);
      px(1,4,HD); px(10,4,HD);
    },
    // 7: bald / buzz
    () => {
      row(2, 3, [SD,SD,SD,SD,SD,SD]);
      px(2,3,SD); px(9,3,SD);
    },
  ];
  (hairDraws[cfg.hair] || hairDraws[0])();

  // â”€â”€â”€ ACCESSORIES â”€â”€â”€
  const accDraws = [
    () => {}, // 0: none
    // 1: glasses
    () => {
      px(3,4,'#4a4a6a'); px(4,4,'#8ab4f8'); px(5,4,'#4a4a6a');
      px(6,4,'#4a4a6a');
      px(7,4,'#8ab4f8'); px(8,4,'#4a4a6a');
    },
    // 2: headband
    () => {
      const bc = _lightenHex(C, 60);
      row(3, 2, [bc,bc,bc,bc,bc,bc,bc,bc]);
    },
    // 3: scarf
    () => {
      row(9, 3, [O,CL,CL,CL,CL,O]);
      row(10, 3, [CL,CL,CL,CL,CL,CL]);
      px(9,10,CL); px(9,11,CL); px(9,12,CD);
    },
    // 4: hat
    () => {
      const hc = _darkenHex(C, 20);
      row(0, 3, [hc,hc,hc,hc,hc,hc]);
      row(1, 2, [hc,hc,hc,hc,hc,hc,hc,hc]);
      row(2, 1, [O,hc,hc,hc,hc,hc,hc,hc,hc,O]);
    },
    // 5: earring
    () => {
      px(2,5,'#ffd700'); px(2,6,'#ffd700');
    },
  ];
  (accDraws[cfg.accessory] || accDraws[0])();

  return c.toDataURL();
}

// Generate + cache avatar data URLs
function getAvatarDataUrl(agentId, scale) {
  const cacheKey = `${agentId}_${scale||AV_SCALE}`;
  if (!state._avatarCache) state._avatarCache = {};
  if (state._avatarCache[cacheKey]) return state._avatarCache[cacheKey];
  if (!state.avatarConfigs[agentId]) {
    const ag = getAgent(agentId);
    state.avatarConfigs[agentId] = generateAvatarConfig(agentId, ag?.color || '#888');
  }
  const url = renderAvatar(state.avatarConfigs[agentId], scale || AV_SCALE);
  state._avatarCache[cacheKey] = url;
  return url;
}

function invalidateAvatarCache(agentId) {
  if (!state._avatarCache) return;
  Object.keys(state._avatarCache).forEach(k => { if (k.startsWith(agentId)) delete state._avatarCache[k]; });
}

// Init avatars for all agents
function initAvatars() {
  state.agents.forEach(a => {
    if (!state.avatarConfigs[a.id]) {
      state.avatarConfigs[a.id] = generateAvatarConfig(a.id, a.color);
    }
  });
}

// â”€â”€ AGENT MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _initAgent(agent) {
  // Set defaults
  agent.id = agent.id || agent.name.toLowerCase().replace(/[^a-z0-9]+/g, '');
  agent.model = agent.model || (state.gatewayModels.length > 0 ? state.gatewayModels[0].id : '');
  if (agent.admin === undefined) agent.admin = false;
  agent.skills = agent.skills || [];
  agent.personality = agent.personality || 'Professional and efficient.';
  agent.created = agent.created || new Date().toISOString();

  // Add to agents array
  state.agents.push(agent);
  _saveAgents();

  // Init chat
  state.chatMessages[agent.id] = [];

  // Init status
  state.agentStatus[agent.id] = 'active';

  // Init org position (spiral outward from center to avoid overlap)
  const count = state.agents.length;
  const angle = ((count - 1) * 137.5) * Math.PI / 180; // golden angle
  const radius = 120 + (count * 30);
  const cx = 340, cy = 280;
  state.orgPositions[agent.id] = {
    x: Math.round((cx + Math.cos(angle) * radius) / 20) * 20,
    y: Math.round((cy + Math.sin(angle) * radius) / 20) * 20,
  };
  _saveOrgPositions();

  // Generate avatar
  state.avatarConfigs[agent.id] = generateAvatarConfig(agent.id, agent.color);

  // Generate default prompt
  // (will auto-generate on first access via _getDefaultPrompt)

  // Log activity
  if (typeof _autoLog === 'function') {
    _autoLog('system', state.agents[0]?.id || 'system', `New agent created: ${agent.name}`, `ID: ${agent.id} Â· Model: ${agent.model} Â· Role: ${agent.role}`);
  }

  renderAll();
}

function _deleteAgent(agentId) {
  const agent = getAgent(agentId);
  if (!agent) return;

  // Remove from agents
  state.agents = state.agents.filter(a => a.id !== agentId);
  _saveAgents();

  // Clean up org position
  delete state.orgPositions[agentId];
  _saveOrgPositions();

  // Clean up connections involving this agent
  state.orgConnections = state.orgConnections.filter(c => c.from !== agentId && c.to !== agentId);
  _saveOrgConnections();

  // Clean up chat
  delete state.chatMessages[agentId];

  // Clean up status
  delete state.agentStatus[agentId];

  // Clean up avatar
  delete state.avatarConfigs[agentId];

  // Clean up prompts
  delete state.agentPrompts[agentId];
  _saveAgentPrompts();

  // Remove from vault allow lists
  state.vault.forEach(s => {
    s.allowList = (s.allowList || []).filter(a => a !== agentId);
  });
  if (typeof _saveVault === 'function') _saveVault();

  // Remove tasks assigned to this agent
  state.tasks = state.tasks.filter(t => t.agent !== agentId);

  // Remove from cron jobs
  state.cronJobs.forEach(j => {
    j.agents = (j.agents || []).filter(a => a !== agentId);
  });

  // Fix activeChat if needed
  if (state.activeChat === agentId) {
    state.activeChat = state.agents[0]?.id || '';
  }

  // Fix selected agents in views
  if (state.promptSelectedAgent === agentId) {
    state.promptSelectedAgent = state.agents[0]?.id || '';
  }

  // Log
  if (typeof _autoLog === 'function') {
    _autoLog('system', state.agents[0]?.id || 'system', `Agent deleted: ${agent.name}`, `All connections, tasks, and data removed`);
  }

  renderAll();
}

function _openAgentModal(editId) {
  const existing = editId ? getAgent(editId) : null;
  const isEdit = !!existing;
  const usedColors = state.agents.filter(a => a.id !== editId).map(a => a.color);

  // Modal skill state
  let skills = existing?.skills ? [...existing.skills] : [];

  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay open';
  overlay.innerHTML = `
    <div class="modal" style="max-width:520px;">
      <h3>${isEdit ? 'âœŽ Edit Agent' : '+ Create Agent'}</h3>
      <div class="agent-modal-body">
        <div class="am-row">
          <div class="vault-field">
            <label>Agent Name</label>
            <input type="text" id="am-name" placeholder="e.g. SENTINEL" value="${existing?.name||''}" style="text-transform:uppercase;font-weight:700;font-family:var(--font-display);">
          </div>
          <div class="vault-field" style="max-width:140px;">
            <label>Agent ID</label>
            <input type="text" id="am-id" placeholder="auto" value="${existing?.id||''}" style="font-family:var(--font-mono,monospace);font-size:11px;" ${isEdit ? 'disabled' : ''}>
            <div class="vault-hint">${isEdit ? 'Cannot change ID' : 'Auto-generated from name'}</div>
          </div>
        </div>
        <div class="vault-field">
          <label>Role</label>
          <input type="text" id="am-role" placeholder="e.g. Security Operations" value="${existing?.role||''}">
        </div>
        <div class="vault-field">
          <label>LLM Model</label>
          <select id="am-model" class="am-model-select">
            ${_buildModelOptions(existing?.model || '')}
          </select>
        </div>
        <div class="vault-field">
          <label>Color</label>
          <div class="am-color-grid" id="am-colors"></div>
        </div>
        <div class="vault-field">
          <label>Skills</label>
          <div style="background:var(--bg-elevated);border:1px solid var(--border);border-radius:var(--radius-sm);padding:6px 10px;display:flex;flex-wrap:wrap;gap:6px;min-height:38px;align-items:center;">
            <div class="am-skill-tags" id="am-skills"></div>
            <input type="text" class="am-skill-input" id="am-skill-input" placeholder="Type skill + Enter">
          </div>
        </div>
        <div class="vault-field">
          <label>Personality</label>
          <input type="text" id="am-personality" placeholder="e.g. Vigilant sentinel with zero-trust mindset" value="${existing?.personality||''}">
        </div>
        <div class="vault-field">
          <label>Briefing Room Access</label>
          <div style="display:flex;align-items:center;gap:10px;padding:6px 0;">
            <button type="button" id="am-admin-toggle" class="am-toggle-btn ${(existing?.admin !== false) ? 'on' : ''}" style="
              width:44px;height:24px;border-radius:12px;border:1px solid var(--border);
              background:${(existing?.admin !== false) ? 'var(--accent-green)' : 'var(--bg-elevated)'};
              cursor:pointer;position:relative;transition:all .2s;padding:0;
            ">
              <span style="
                display:block;width:18px;height:18px;border-radius:50%;
                background:white;position:absolute;top:2px;
                left:${(existing?.admin !== false) ? '22px' : '3px'};
                transition:left .2s;box-shadow:0 1px 3px rgba(0,0,0,.2);
              "></span>
            </button>
            <span id="am-admin-label" style="font-size:11px;color:var(--text-secondary);font-weight:600;">
              ${(existing?.admin !== false) ? 'Admin â€” participates in briefings' : 'Worker â€” excluded from briefings'}
            </span>
          </div>
          <div class="vault-hint">Admin agents appear in the Briefing Room and can be selected as meeting participants</div>
        </div>
        ${isEdit ? `
          <div class="am-danger-zone">
            <button class="am-delete-btn" id="am-delete">âš  Delete Agent â€” Remove ${existing.name} and all associated data</button>
          </div>
        ` : ''}
      </div>
      <div class="modal-actions">
        <button class="btn" id="am-cancel">CANCEL</button>
        <button class="btn primary" id="am-save">${isEdit ? 'UPDATE AGENT' : 'CREATE AGENT'}</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  // Color swatches
  const colorGrid = overlay.querySelector('#am-colors');
  let selectedColor = existing?.color || AGENT_COLORS.find(c => !usedColors.includes(c)) || AGENT_COLORS[0];

  function renderColors() {
    colorGrid.innerHTML = AGENT_COLORS.map(c => {
      const taken = usedColors.includes(c);
      const sel = c === selectedColor;
      return `<div class="am-color-swatch ${sel?'selected':''} ${taken?'taken':''}" data-color="${c}" style="background:${c};" title="${taken?'In use':''}"></div>`;
    }).join('') + `
      <div style="display:flex;align-items:center;gap:4px;margin-left:4px;">
        <input type="color" id="am-custom-color" value="${selectedColor}" style="width:28px;height:28px;border:none;padding:0;cursor:pointer;border-radius:6px;">
      </div>
    `;

    colorGrid.querySelectorAll('.am-color-swatch').forEach(sw => {
      sw.addEventListener('click', () => {
        selectedColor = sw.dataset.color;
        renderColors();
      });
    });
    colorGrid.querySelector('#am-custom-color')?.addEventListener('input', e => {
      selectedColor = e.target.value;
      colorGrid.querySelectorAll('.am-color-swatch').forEach(s => s.classList.remove('selected'));
    });
  }
  renderColors();

  // Admin toggle
  let isAdmin = existing?.admin !== false;
  const adminToggle = overlay.querySelector('#am-admin-toggle');
  const adminLabel = overlay.querySelector('#am-admin-label');
  adminToggle?.addEventListener('click', () => {
    isAdmin = !isAdmin;
    adminToggle.style.background = isAdmin ? 'var(--accent-green)' : 'var(--bg-elevated)';
    adminToggle.querySelector('span').style.left = isAdmin ? '22px' : '3px';
    adminLabel.textContent = isAdmin ? 'Admin â€” participates in briefings' : 'Worker â€” excluded from briefings';
  });

  // Model selector â€” handle manual entry
  const modelSelect = overlay.querySelector('#am-model');
  modelSelect?.addEventListener('change', () => {
    if (modelSelect.value === '__custom__') {
      const customId = prompt('Enter model ID (e.g. claude-sonnet-4-5-20250929, gpt-4o, llama3:70b):');
      if (customId && customId.trim()) {
        // Add as a new option and select it
        const opt = document.createElement('option');
        opt.value = customId.trim();
        opt.textContent = customId.trim();
        opt.selected = true;
        // Insert before the custom entry option
        const customOpt = modelSelect.querySelector('option[value="__custom__"]');
        customOpt.parentElement.insertBefore(opt, customOpt);
      } else {
        // User cancelled â€” reset to first real option or empty
        const firstReal = modelSelect.querySelector('option:not([disabled]):not([value="__custom__"])');
        if (firstReal) modelSelect.value = firstReal.value;
      }
    }
  });

  // Skills tags
  function renderSkills() {
    overlay.querySelector('#am-skills').innerHTML = skills.map((s, i) => `
      <span class="am-skill-tag">${s}<span class="am-skill-x" data-si="${i}">âœ•</span></span>
    `).join('');
    overlay.querySelectorAll('.am-skill-x').forEach(x => {
      x.addEventListener('click', () => { skills.splice(parseInt(x.dataset.si), 1); renderSkills(); });
    });
  }
  renderSkills();

  overlay.querySelector('#am-skill-input').addEventListener('keydown', e => {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault();
      const v = e.target.value.trim();
      if (v && !skills.includes(v)) { skills.push(v); renderSkills(); }
      e.target.value = '';
    }
  });

  // Auto-generate ID from name
  const nameInput = overlay.querySelector('#am-name');
  const idInput = overlay.querySelector('#am-id');
  if (!isEdit) {
    nameInput.addEventListener('input', () => {
      if (!idInput._manual) {
        idInput.value = nameInput.value.toLowerCase().replace(/[^a-z0-9]+/g, '').slice(0, 20);
      }
    });
    idInput.addEventListener('input', () => { idInput._manual = true; });
  }

  // Cancel / close
  overlay.querySelector('#am-cancel').addEventListener('click', () => overlay.remove());
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });

  // Delete
  if (isEdit) {
    overlay.querySelector('#am-delete')?.addEventListener('click', () => {
      if (confirm(`Delete ${existing.name}? This removes all connections, tasks, prompts, and vault access for this agent.`)) {
        _deleteAgent(editId);
        overlay.remove();
      }
    });
  }

  // Save
  overlay.querySelector('#am-save').addEventListener('click', () => {
    const name = nameInput.value.trim().toUpperCase();
    const id = isEdit ? editId : idInput.value.trim().toLowerCase().replace(/[^a-z0-9]+/g, '');
    const role = overlay.querySelector('#am-role').value.trim();
    let model = overlay.querySelector('#am-model').value;
    if (model === '__custom__') model = ''; // Guard: user cancelled manual entry
    const personality = overlay.querySelector('#am-personality').value.trim();

    if (!name || !id || !role) return;

    // Check ID uniqueness
    if (!isEdit && getAgent(id)) {
      idInput.style.borderColor = 'var(--accent-red)';
      return;
    }

    if (isEdit) {
      // Update existing
      const agent = getAgent(editId);
      const adminChanged = agent.admin !== isAdmin;
      agent.name = name;
      agent.role = role;
      agent.model = model;
      agent.color = selectedColor;
      agent.skills = skills;
      agent.personality = personality;
      agent.admin = isAdmin;
      _saveAgents();
      // Regenerate avatar if color changed
      state.avatarConfigs[editId] = generateAvatarConfig(editId, selectedColor);
      // Regenerate default prompt with new admin level and push to gateway
      if (!state.agentPrompts[editId]) {
        // Using defaults â€” regenerate them with new admin/role/skills
        // (custom prompts are left as-is since user edited them)
      } else {
        // If admin status changed, regenerate the tools + instructions sections
        if (adminChanged) {
          const fresh = _getDefaultPrompt(editId);
          state.agentPrompts[editId].tools = fresh.tools;
          state.agentPrompts[editId].instructions = fresh.instructions;
          state.agentPrompts[editId].identity = fresh.identity;
          state.agentPrompts[editId].role = fresh.role;
          _saveAgentPrompts();
        }
      }
      // Push updated prompt to gateway
      window.__openclaw_cc.pushPrompt(editId);
      _autoLog('system', state.agents[0]?.id || 'system', `Agent updated: ${name}`, `Model: ${model} Â· Role: ${role} Â· Admin: ${isAdmin}${adminChanged ? ' (changed)' : ''}`);
      renderAll();
    } else {
      _initAgent({
        id, name, role, model,
        admin: isAdmin,
        color: selectedColor,
        skills: [...skills],
        personality,
      });
    }
    overlay.remove();
  });

  nameInput.focus();
}

function _buildModelOptions(selectedModel) {
  const models = state.gatewayModels;

  if (models.length === 0) {
    // No gateway models available â€” show empty state with manual entry
    let html = '<option value="" disabled selected>âš  No gateway connected â€” enter manually</option>';
    if (selectedModel) {
      html = `<option value="${selectedModel}" selected>${selectedModel}</option>`;
    }
    html += '<option value="__custom__">âœŽ Enter model ID manually...</option>';
    return html;
  }

  // Group gateway models by provider
  const groups = {};
  models.forEach(m => {
    const provider = m.provider || 'Gateway';
    if (!groups[provider]) groups[provider] = [];
    groups[provider].push(m);
  });

  let html = '';
  Object.entries(groups).forEach(([provider, provModels]) => {
    html += `<optgroup label="${provider}">`;
    provModels.forEach(m => {
      const sizeTag = m.size ? ` (${m.size})` : '';
      html += `<option value="${m.id}" ${m.id === selectedModel ? 'selected' : ''}>${m.name}${sizeTag}</option>`;
    });
    html += `</optgroup>`;
  });

  // If the selected model isn't in the gateway list, still show it
  const allIds = models.map(m => m.id);
  if (selectedModel && !allIds.includes(selectedModel)) {
    html += `<optgroup label="Current (not on gateway)"><option value="${selectedModel}" selected>${selectedModel}</option></optgroup>`;
  }

  // Always offer manual entry
  html += `<optgroup label="â”€â”€â”€â”€â”€â”€"><option value="__custom__">âœŽ Enter model ID manually...</option></optgroup>`;
  return html;
}

// Resolve a model ID to a display name â€” checks gateway models first, then LLM_MODELS as label fallback, then returns raw ID
function _modelDisplayName(modelId) {
  if (!modelId) return '';
  const gw = state.gatewayModels.find(m => m.id === modelId);
  if (gw) return gw.name;
  const builtin = LLM_MODELS.find(m => m.id === modelId);
  if (builtin) return builtin.name;
  return modelId;
}

// Wire up + button
$('#add-agent-btn')?.addEventListener('click', () => _openAgentModal());

// â”€â”€ GATEWAY WEBSOCKET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _reconnectAttempt = 0;
function connectGateway() {
  if (state.ws) { state.ws.close(); state.ws = null; }
  const el = $('#conn-status');
  el.className = 'connecting'; el.title = 'Connecting...';

  try {
    const url = state.authToken
      ? `${state.gatewayUrl}?token=${encodeURIComponent(state.authToken)}`
      : state.gatewayUrl;
    const ws = new WebSocket(url);
    state.ws = ws;

    ws.onopen = () => {
      state.connected = true;
      _reconnectAttempt = 0; // Reset backoff on success
      el.className = 'connected'; el.title = 'Gateway: connected';
      console.log('[CommandCenter] Connected to Gateway');
      // Subscribe to sessions/events
      ws.send(JSON.stringify({ type: 'subscribe', channels: ['sessions','presence','config'] }));
      // Request available models from gateway
      ws.send(JSON.stringify({ type: 'get_models' }));
      // Request stored state from gateway (persistence protocol)
      _storage.requestStateFromGateway();
      // Push current routing to all agents
      _syncAllRouting('reconnect');
      // Push vault manifest
      _syncVaultToGateway();
    };

    ws.onmessage = (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        handleGatewayMessage(msg);
      } catch(e) { console.warn('[CommandCenter] Parse error:', e); }
    };

    ws.onclose = () => {
      state.connected = false;
      _storage.handleGatewayDisconnect();
      el.className = 'disconnected'; el.title = 'Gateway: disconnected';
      console.log('[CommandCenter] Disconnected');
      // Exponential backoff reconnect: 1s, 2s, 4s, 8s, 16s, 30s max
      _reconnectAttempt = Math.min((_reconnectAttempt || 0) + 1, 6);
      const baseDelay = Math.min(1000 * Math.pow(2, _reconnectAttempt - 1), 30000);
      const jitter = Math.random() * 1000;
      const delay = baseDelay + jitter;
      console.log(`[CommandCenter] Reconnecting in ${Math.round(delay/1000)}s (attempt ${_reconnectAttempt})`);
      el.title = `Gateway: reconnecting in ${Math.round(delay/1000)}s...`;
      setTimeout(() => { if (!state.connected) connectGateway(); }, delay);
    };

    ws.onerror = () => {
      el.className = 'disconnected'; el.title = 'Gateway: error';
    };
  } catch(e) {
    el.className = 'disconnected'; el.title = 'Gateway: failed';
    console.error('[CommandCenter] WS error:', e);
  }
}

function handleGatewayMessage(msg) {
  // Route incoming Gateway protocol messages
  // These hooks let agents push data into the dashboard
  console.log('[Gateway]', msg);

  if (msg.type === 'message' && msg.agentId) {
    const agentId = msg.agentId;
    if (!state.chatMessages[agentId]) state.chatMessages[agentId] = [];
    state.chatMessages[agentId].push({
      from: 'agent', text: msg.text || msg.content, ts: ts()
    });
    _saveChatMessages();
    // Hide typing indicator
    const typing = $('#chat-typing');
    if (typing) typing.classList.remove('show');
    if (state.activeChat === agentId && state.activeView === 'chat') renderChat();
  }

  if (msg.type === 'presence') {
    // Update agent status indicators
    if (msg.agentId && msg.status) {
      state.agentStatus[msg.agentId] = msg.status;
      _saveAgentStatus();
    }
    renderAgentPills();
    renderOrgChart();
  }

  if (msg.type === 'models') {
    // Gateway reports available models
    if (Array.isArray(msg.models) && msg.models.length > 0) {
      state.gatewayModels = msg.models.map(m => ({
        id: m.id || m.name,
        name: m.name || m.id,
        provider: m.provider || 'Gateway',
        tier: m.tier || 'available',
        size: m.size || null,
      }));
      _safeSave('oc_gatewayModels', state.gatewayModels);
      console.log(`[Models] Gateway reports ${state.gatewayModels.length} available models`);
    }
  }

  if (msg.type === 'routing_ack') {
    console.log(`[Routing] ${msg.agentId} acknowledged routing update`);
  }

  if (msg.type === 'vault_request') {
    _handleVaultRequest(msg);
  }

  // canvas_eval â€” agent pushes API calls into the dashboard
  if (msg.type === 'canvas_eval') {
    // Rate limit per agent
    if (!_canvasEvalAllowed(msg.agentId || 'unknown')) {
      if (state.ws && msg.requestId) {
        state.ws.send(JSON.stringify({
          type: 'canvas_eval_result',
          requestId: msg.requestId,
          error: 'Rate limited â€” max 50 calls per 10s per agent',
        }));
      }
      return;
    }
    // Block dangerous methods â€” agents must not overwrite state or manage agents
    const BLOCKED_METHODS = ['importState','getState','createAgent','removeAgent','editAgent','addSecret','updateSecret','deleteSecret'];
    if (BLOCKED_METHODS.includes(msg.method)) {
      console.warn(`[canvas_eval] Blocked restricted method: ${msg.method} from ${msg.agentId}`);
      if (state.ws && msg.requestId) {
        state.ws.send(JSON.stringify({
          type: 'canvas_eval_result',
          requestId: msg.requestId,
          error: `Method '${msg.method}' is restricted â€” not callable via canvas_eval`,
        }));
      }
      return;
    }
    try {
      const method = msg.method; // e.g. 'addTask', 'logActivity', 'rcUpdateMetrics'
      const args = msg.args || msg.params; // method arguments
      const fn = window.__openclaw_cc[method];
      if (typeof fn === 'function') {
        const result = Array.isArray(args) ? fn.apply(window.__openclaw_cc, args) : fn.call(window.__openclaw_cc, args);
        // Send result back to gateway
        if (state.ws && msg.requestId) {
          state.ws.send(JSON.stringify({
            type: 'canvas_eval_result',
            requestId: msg.requestId,
            agentId: msg.agentId,
            method,
            result,
          }));
        }
        console.log(`[canvas_eval] ${msg.agentId || 'unknown'}.${method}() â†’`, result);
      } else {
        console.warn(`[canvas_eval] Unknown method: ${method}`);
        if (state.ws && msg.requestId) {
          state.ws.send(JSON.stringify({
            type: 'canvas_eval_result',
            requestId: msg.requestId,
            error: `Unknown method: ${method}`,
          }));
        }
      }
    } catch(e) {
      console.error(`[canvas_eval] Error executing ${msg.method}:`, e);
      if (state.ws && msg.requestId) {
        state.ws.send(JSON.stringify({
          type: 'canvas_eval_result',
          requestId: msg.requestId,
          error: e.message,
        }));
      }
    }
  }

  // meeting_message â€” agent participates in active briefing
  if (msg.type === 'meeting_message') {
    if (state.meeting.active && msg.agentId) {
      window.__openclaw_cc.meetingMessage({
        agent: msg.agentId,
        text: msg.text || msg.content,
        type: msg.messageType || 'message',
      });
    }
  }

  // Agent-to-agent comms relayed through gateway
  if (msg.type === 'agent_comms') {
    window.__openclaw_cc.pushComms({
      from: msg.from,
      to: msg.to,
      text: msg.text,
    });
  }

  // â”€â”€ GATEWAY PERSISTENCE PROTOCOL â”€â”€
  // state_restore â€” gateway sends stored state in response to state_request
  if (msg.type === 'state_restore') {
    _storage.handleStateRestore(msg);
  }

  // state_ack â€” gateway confirms it wrote state to disk
  if (msg.type === 'state_ack') {
    _storage.handleStateAck(msg);
  }

  // state_conflict â€” gateway detected a conflict (e.g. another CC instance)
  if (msg.type === 'state_conflict') {
    const gwTs = msg.savedAt || 0;
    const localTs = _storage._lastSaveTs || 0;
    console.warn(`[Sync] State conflict â€” gateway: ${new Date(gwTs).toLocaleString()}, local: ${new Date(localTs).toLocaleString()}`);
    // Offer user a choice
    const useGateway = confirm(
      `State conflict detected!\n\n` +
      `Gateway copy: ${new Date(gwTs).toLocaleString()}\n` +
      `Your local copy: ${new Date(localTs).toLocaleString()}\n\n` +
      `Use the gateway version? (Cancel keeps your local version)`
    );
    if (useGateway && msg.state) {
      _storage._applySnapshot(msg.state);
      _storage.createBackup('conflict-resolve');
      _storage.persistFullState();
      renderAll();
      _showToast({ text: 'Resolved â€” using gateway state', level: 'success', ts: ts() });
    } else {
      // Push local state to overwrite gateway
      const snap = _storage._getSerializableState();
      snap._savedAt = _storage._lastSaveTs;
      _storage._syncToGateway(snap);
      _showToast({ text: 'Resolved â€” pushed local state to gateway', level: 'info', ts: ts() });
    }
  }
}

// â”€â”€ CANVAS API (for agents to push updates via canvas.eval) â”€â”€â”€â”€â”€
// Full bidirectional API â€” every human action is also agent-callable
// Usage: window.__openclaw_cc.<method>({...})
window.__openclaw_cc = {

  // â”€â”€â”€ AGENT MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  createAgent(agent) {
    if (!agent.name || !agent.role) return { ok:false, error:'name and role required' };
    agent.id = agent.id || agent.name.toLowerCase().replace(/[^a-z0-9]+/g, '');
    if (getAgent(agent.id)) return { ok:false, error:'id already exists' };
    _initAgent(agent);
    return { ok:true, id: agent.id };
  },
  editAgent(id, fields) {
    const a = getAgent(id);
    if (!a) return { ok:false, error:'not found' };
    const adminChanged = fields.admin !== undefined && fields.admin !== a.admin;
    Object.assign(a, fields);
    if (fields.color) state.avatarConfigs[id] = generateAvatarConfig(id, fields.color);
    _saveAgents();
    // If admin status changed, regenerate prompt with new access level
    if (adminChanged) {
      if (state.agentPrompts[id]) {
        const fresh = _getDefaultPrompt(id);
        state.agentPrompts[id].tools = fresh.tools;
        state.agentPrompts[id].instructions = fresh.instructions;
        state.agentPrompts[id].identity = fresh.identity;
        state.agentPrompts[id].role = fresh.role;
        _saveAgentPrompts();
      }
      window.__openclaw_cc.pushPrompt(id);
    }
    renderAll();
    return { ok:true };
  },
  removeAgent(id) {
    if (!getAgent(id)) return { ok:false, error:'not found' };
    _deleteAgent(id);
    return { ok:true };
  },
  getAgents() { return state.agents.map(a => ({ ...a })); },
  getModels() { return state.gatewayModels.length > 0 ? [...state.gatewayModels] : [...LLM_MODELS]; },

  // â”€â”€â”€ ORG STRUCTURE / COMMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  pushComms(msg) {
    msg.ts = msg.ts || ts();
    // Validate connection exists (or allow 'all')
    if (msg.to !== 'all') {
      const connected = state.orgConnections.some(c =>
        (c.from === msg.from && c.to === msg.to) || (c.from === msg.to && c.to === msg.from)
      );
      if (!connected) return { ok:false, error:`no connection between ${msg.from} and ${msg.to}` };
    }
    state.warChatter.push(msg);
    _trimWarChatter();
    renderWarChatter();
    return { ok:true, count: state.warChatter.length };
  },
  clearComms() {
    state.warChatter = [];
    renderWarChatter();
    return { ok:true };
  },
  // Connection management
  addConnection(from, fromPort, to, toPort) {
    const exists = state.orgConnections.some(c => c.from===from && c.to===to && c.fromPort===fromPort && c.toPort===toPort);
    if (exists) return { ok:false, error:'connection exists' };
    const conn = { id:'c'+Date.now(), from, fromPort: fromPort||'bottom', to, toPort: toPort||'top' };
    state.orgConnections.push(conn);
    _onConnectionsChanged('api_add');
    return { ok:true, id: conn.id };
  },
  removeConnection(connId) {
    const before = state.orgConnections.length;
    state.orgConnections = state.orgConnections.filter(c => c.id !== connId);
    if (state.orgConnections.length < before) _onConnectionsChanged('api_remove');
    return { ok: state.orgConnections.length < before, id: connId };
  },
  getConnections(agentId) {
    if (!agentId) return [...state.orgConnections];
    return state.orgConnections.filter(c => c.from === agentId || c.to === agentId);
  },
  getConnectedAgents(agentId) {
    const connected = new Set();
    state.orgConnections.forEach(c => {
      if (c.from === agentId) connected.add(c.to);
      if (c.to === agentId) connected.add(c.from);
    });
    return [...connected];
  },
  moveOrgNode(agentId, x, y) {
    if (!state.orgPositions[agentId]) return { ok:false, error:'unknown agent' };
    state.orgPositions[agentId] = { x, y };
    renderOrgChart();
    return { ok:true };
  },
  clearConnections() {
    state.orgConnections = [];
    _onConnectionsChanged('api_clear');
    return { ok:true };
  },
  // Routing config generation
  generateRoutingConfig(agentId) {
    const agent = getAgent(agentId);
    if (!agent) return { ok:false, error:'unknown agent' };
    const connected = [];
    const upstream = [];
    const downstream = [];
    const lateral = [];
    state.orgConnections.forEach(c => {
      if (c.from === agentId) {
        const target = getAgent(c.to);
        if (target) {
          connected.push(target);
          // bottomâ†’top = downstream, leftâ†”right = lateral
          if (c.fromPort === 'bottom' || c.toPort === 'top') downstream.push(target);
          else if (c.fromPort === 'top' || c.toPort === 'bottom') upstream.push(target);
          else lateral.push(target);
        }
      }
      if (c.to === agentId) {
        const target = getAgent(c.from);
        if (target) {
          connected.push(target);
          if (c.toPort === 'top' || c.fromPort === 'bottom') upstream.push(target);
          else if (c.toPort === 'bottom' || c.fromPort === 'top') downstream.push(target);
          else lateral.push(target);
        }
      }
    });
    return {
      ok: true,
      agent: agent.id,
      name: agent.name,
      role: agent.role,
      connected: connected.map(a => ({ id:a.id, name:a.name, role:a.role })),
      upstream: upstream.map(a => ({ id:a.id, name:a.name, role:a.role })),
      downstream: downstream.map(a => ({ id:a.id, name:a.name, role:a.role })),
      lateral: lateral.map(a => ({ id:a.id, name:a.name, role:a.role })),
    };
  },
  exportAllRoutingConfigs() {
    return _generateExportConfig();
  },

  // â”€â”€â”€ AGENT STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // status: "active" | "idle" | "busy" | "error" | "offline"
  setAgentStatus(agentId, status) {
    if (!getAgent(agentId)) return { ok:false, error:'unknown agent' };
    state.agentStatus[agentId] = status;
    _saveAgentStatus();
    renderAgentPills();
    renderOrgChart();
    return { ok:true, agentId, status };
  },
  getAgentStatus(agentId) {
    return state.agentStatus[agentId] || 'active';
  },

  // â”€â”€â”€ TASKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addTask(task) {
    task.id = task.id || Date.now();
    task.status = task.status || 'todo';
    task.due = task.due || 'TBD';
    task.priority = task.priority || 'medium';
    state.tasks.push(task);
    _saveTasks();
    renderTasks();
    return { ok:true, id: task.id };
  },
  moveTask(taskId, newStatus) {
    const task = state.tasks.find(t => t.id === taskId);
    if (!task) return { ok:false, error:'task not found' };
    if (!['todo','in-progress','done'].includes(newStatus)) return { ok:false, error:'invalid status' };
    task.status = newStatus;
    _saveTasks();
    renderTasks();
    return { ok:true, id:taskId, status:newStatus };
  },
  updateTask(taskId, fields) {
    const task = state.tasks.find(t => t.id === taskId);
    if (!task) return { ok:false, error:'task not found' };
    Object.assign(task, fields);
    _saveTasks();
    renderTasks();
    return { ok:true, id:taskId };
  },
  deleteTask(taskId) {
    const before = state.tasks.length;
    state.tasks = state.tasks.filter(t => t.id !== taskId);
    _saveTasks();
    renderTasks();
    return { ok: state.tasks.length < before, id:taskId };
  },
  getTasks(filter) {
    let tasks = [...state.tasks];
    if (filter?.agent) tasks = tasks.filter(t => t.agent === filter.agent);
    if (filter?.status) tasks = tasks.filter(t => t.status === filter.status);
    if (filter?.priority) tasks = tasks.filter(t => t.priority === filter.priority);
    return tasks;
  },
  clearTasks(filter) {
    if (filter?.status) {
      state.tasks = state.tasks.filter(t => t.status !== filter.status);
    } else if (filter?.agent) {
      state.tasks = state.tasks.filter(t => t.agent !== filter.agent);
    } else {
      state.tasks = [];
    }
    _saveTasks();
    renderTasks();
    return { ok:true, remaining: state.tasks.length };
  },

  // â”€â”€â”€ CRON JOBS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addCronJob(job) {
    job.id = job.id || Date.now();
    job.enabled = job.enabled !== false;
    job.runs = job.runs || 0;
    job.errors = job.errors || 0;
    job.lastRun = job.lastRun || 'â€”';
    job.nextRun = job.nextRun || _calcNextRun(job);
    job.created = job.created || new Date().toISOString().split('T')[0];
    state.cronJobs.push(job);
    _saveCronJobs();
    renderCron();
    _syncCronToGateway(job);
    return { ok:true, id: job.id };
  },
  updateCronJob(jobId, fields) {
    const job = state.cronJobs.find(j => j.id === jobId);
    if (!job) return { ok:false, error:'job not found' };
    Object.assign(job, fields);
    if (fields.schedule || fields.enabled !== undefined) job.nextRun = _calcNextRun(job);
    renderCron();
    _syncCronToGateway(job);
    return { ok:true, id: jobId };
  },
  deleteCronJob(jobId) {
    const before = state.cronJobs.length;
    state.cronJobs = state.cronJobs.filter(j => j.id !== jobId);
    _saveCronJobs();
    renderCron();
    return { ok: state.cronJobs.length < before, id: jobId };
  },
  toggleCronJob(jobId) {
    const job = state.cronJobs.find(j => j.id === jobId);
    if (!job) return { ok:false, error:'job not found' };
    job.enabled = !job.enabled;
    job.nextRun = _calcNextRun(job);
    renderCron();
    _syncCronToGateway(job);
    return { ok:true, id: jobId, enabled: job.enabled };
  },
  getCronJobs(filter) {
    let jobs = [...state.cronJobs];
    if (filter?.agent) jobs = jobs.filter(j => j.agents?.includes(filter.agent));
    if (filter?.enabled !== undefined) jobs = jobs.filter(j => j.enabled === filter.enabled);
    return jobs;
  },
  logCronRun(jobId, success, error) {
    const job = state.cronJobs.find(j => j.id === jobId);
    if (!job) return { ok:false, error:'job not found' };
    job.runs = (job.runs||0) + 1;
    if (!success) job.errors = (job.errors||0) + 1;
    job.lastRun = ts();
    job.nextRun = _calcNextRun(job);
    renderCron();
    return { ok:true, runs: job.runs, errors: job.errors };
  },

  // â”€â”€â”€ ACTIVITY LOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  logActivity(entry) {
    entry.id = entry.id || Date.now() + Math.random();
    entry.ts = entry.ts || new Date().toISOString();
    entry.type = entry.type || 'system';
    state.activityLog.unshift(entry); // newest first
    if (state.activityLog.length > 500) state.activityLog.length = 500; // cap
    renderLogs();
    return { ok:true, id: entry.id };
  },
  getActivityLog(filter) {
    let logs = [...state.activityLog];
    if (filter?.agent) logs = logs.filter(l => l.agent === filter.agent);
    if (filter?.type) logs = logs.filter(l => l.type === filter.type);
    if (filter?.since) logs = logs.filter(l => new Date(l.ts) >= new Date(filter.since));
    return logs;
  },
  clearActivityLog(filter) {
    if (filter?.agent) {
      state.activityLog = state.activityLog.filter(l => l.agent !== filter.agent);
    } else if (filter?.type) {
      state.activityLog = state.activityLog.filter(l => l.type !== filter.type);
    } else {
      state.activityLog = [];
    }
    renderLogs();
    return { ok:true, remaining: state.activityLog.length };
  },

  // â”€â”€â”€ SYSTEM PROMPTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getPrompt(agentId) {
    return state.agentPrompts[agentId] || _getDefaultPrompt(agentId);
  },
  setPrompt(agentId, sections) {
    if (!state.agentPrompts[agentId]) state.agentPrompts[agentId] = _getDefaultPrompt(agentId);
    Object.assign(state.agentPrompts[agentId], sections);
    _saveAgentPrompts();
    renderPrompts();
    return { ok:true, agentId };
  },
  pushPrompt(agentId) {
    const prompt = state.agentPrompts[agentId] || _getDefaultPrompt(agentId);
    const compiled = _compilePrompt(agentId, prompt);
    if (state.connected && state.ws) {
      state.ws.send(JSON.stringify({
        type: 'prompt_update',
        agentId,
        prompt: compiled,
        sections: prompt,
        timestamp: Date.now(),
      }));
      _autoLog('system', agentId, `System prompt pushed to Gateway`, `${compiled.length} chars`);
      return { ok:true, pushed:true, length: compiled.length };
    }
    return { ok:true, pushed:false, reason:'not connected' };
  },
  pushAllPrompts() {
    const results = {};
    state.agents.forEach(a => { results[a.id] = window.__openclaw_cc.pushPrompt(a.id); });
    return results;
  },

  // â”€â”€â”€ API VAULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addSecret(secret) {
    secret.id = secret.id || 'sec_' + Date.now();
    secret.created = secret.created || new Date().toISOString();
    secret.allowList = secret.allowList || state.agents.map(a => a.id); // allow all by default
    state.vault.push(secret);
    _saveVault();
    renderVault();
    _autoLog('system', state.agents[0]?.id || 'system', `Secret added: ${secret.name}`, `Key: ${secret.envKey} Â· Allowed: ${secret.allowList.join(', ')}`);
    return { ok:true, id: secret.id };
  },
  updateSecret(id, fields) {
    const s = state.vault.find(v => v.id === id);
    if (!s) return { ok:false, error:'not found' };
    Object.assign(s, fields);
    _saveVault();
    renderVault();
    return { ok:true };
  },
  deleteSecret(id) {
    const s = state.vault.find(v => v.id === id);
    state.vault = state.vault.filter(v => v.id !== id);
    _saveVault();
    renderVault();
    if (s) _autoLog('system', state.agents[0]?.id || 'system', `Secret deleted: ${s.name}`);
    return { ok:true };
  },
  getSecret(envKey, agentId) {
    // Support dotted notation: REVENUECAT.API_KEY â†’ base=REVENUECAT, field=API_KEY
    const parts = envKey.split('.');
    const baseKey = parts[0];
    const fieldKey = parts[1] || null;

    const s = state.vault.find(v => v.envKey === baseKey);
    if (!s) return { ok:false, error:'not found' };
    if (agentId && !s.allowList.includes(agentId)) {
      return { ok:false, error:'access denied', agent: agentId, key: envKey };
    }
    const fields = s.fields || [{ label:'Value', key:'VALUE', value: s.value || '' }];

    // If specific field requested
    if (fieldKey) {
      const f = fields.find(f => f.key === fieldKey);
      if (!f) return { ok:false, error:`field "${fieldKey}" not found in ${baseKey}` };
      return { ok:true, name: s.name, field: f.label, value: f.value };
    }

    // Return all fields
    const result = {};
    fields.forEach(f => { result[f.key] = f.value; });
    return { ok:true, name: s.name, fields: result };
  },
  listSecrets(agentId) {
    if (!agentId) return state.vault.map(s => ({
      id:s.id, name:s.name, envKey:s.envKey, allowList:s.allowList,
      fieldKeys: (s.fields||[]).map(f => f.key),
    }));
    return state.vault.filter(s => s.allowList.includes(agentId)).map(s => ({
      id:s.id, name:s.name, envKey:s.envKey,
      fieldKeys: (s.fields||[]).map(f => f.key),
    }));
  },
  setAllowList(secretId, agentIds) {
    const s = state.vault.find(v => v.id === secretId);
    if (!s) return { ok:false, error:'not found' };
    s.allowList = agentIds;
    _saveVault();
    renderVault();
    return { ok:true, allowList: s.allowList };
  },

  // â”€â”€â”€ CALENDAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addCalEvent(ev) {
    ev.id = ev.id || Date.now();
    state.calEvents.push(ev);
    _saveCalEvents();
    renderCalendar();
    return { ok:true, id: ev.id };
  },
  updateCalEvent(eventId, fields) {
    const ev = state.calEvents.find(e => e.id === eventId);
    if (!ev) return { ok:false, error:'event not found' };
    Object.assign(ev, fields);
    _saveCalEvents();
    renderCalendar();
    return { ok:true, id:eventId };
  },
  deleteCalEvent(eventId) {
    const before = state.calEvents.length;
    state.calEvents = state.calEvents.filter(e => e.id !== eventId);
    _saveCalEvents();
    renderCalendar();
    return { ok: state.calEvents.length < before, id:eventId };
  },
  getCalEvents(filter) {
    let evs = [...state.calEvents];
    if (filter?.date) evs = evs.filter(e => e.date === filter.date);
    if (filter?.agent) evs = evs.filter(e => e.agent === filter.agent);
    if (filter?.type) evs = evs.filter(e => e.type === filter.type);
    return evs;
  },
  clearCalEvents(filter) {
    if (filter?.date) {
      state.calEvents = state.calEvents.filter(e => e.date !== filter.date);
    } else if (filter?.agent) {
      state.calEvents = state.calEvents.filter(e => e.agent !== filter.agent);
    } else {
      state.calEvents = [];
    }
    _saveCalEvents();
    renderCalendar();
    return { ok:true, remaining: state.calEvents.length };
  },

  // â”€â”€â”€ CAMPAIGNS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addCampaign(camp) {
    camp.id = camp.id || Date.now();
    camp.status = camp.status || 'draft';
    camp.spend = camp.spend || 0;
    camp.conversions = camp.conversions || 0;
    camp.tasks = camp.tasks || [];
    state.campaigns.push(camp);
    _saveCampaigns();
    renderMarketing();
    return { ok:true, id: camp.id };
  },
  updateCampaign(campId, fields) {
    const camp = state.campaigns.find(c => c.id === campId);
    if (!camp) return { ok:false, error:'campaign not found' };
    Object.assign(camp, fields);
    _saveCampaigns();
    renderMarketing();
    return { ok:true, id:campId };
  },
  pushCampaignUpdate(update) {
    const camp = state.campaigns.find(c => c.id === update.id);
    if (camp && update.field) {
      camp[update.field] = update.value;
      _saveCampaigns();
      renderMarketing();
      return { ok:true };
    }
    return { ok:false, error:'campaign not found or missing field' };
  },
  deleteCampaign(campId) {
    const before = state.campaigns.length;
    state.campaigns = state.campaigns.filter(c => c.id !== campId);
    if (state.selectedCampaign !== null) {
      const idx = state.campaigns.findIndex(c => c.id === campId);
      if (idx === -1) state.selectedCampaign = null;
    }
    _saveCampaigns();
    renderMarketing();
    return { ok: state.campaigns.length < before };
  },
  toggleCampaignTask(campId, taskIdx) {
    const key = `${campId}-${taskIdx}`;
    state.campaignTasks[key] = !state.campaignTasks[key];
    _saveCampaigns();
    renderMarketing();
    return { ok:true, checked: state.campaignTasks[key] };
  },
  setCampaignTaskStatus(campId, taskIdx, checked) {
    const key = `${campId}-${taskIdx}`;
    state.campaignTasks[key] = !!checked;
    _saveCampaigns();
    renderMarketing();
    return { ok:true, checked: state.campaignTasks[key] };
  },
  addCampaignTask(campId, taskText) {
    const camp = state.campaigns.find(c => c.id === campId);
    if (!camp) return { ok:false, error:'campaign not found' };
    camp.tasks = camp.tasks || [];
    camp.tasks.push(taskText);
    _saveCampaigns();
    renderMarketing();
    return { ok:true, index: camp.tasks.length - 1 };
  },
  removeCampaignTask(campId, taskIdx) {
    const camp = state.campaigns.find(c => c.id === campId);
    if (!camp || !camp.tasks || taskIdx >= camp.tasks.length) return { ok:false };
    camp.tasks.splice(taskIdx, 1);
    // Reindex campaign task states
    const newTasks = {};
    Object.keys(state.campaignTasks).forEach(k => {
      const [cid, ti] = k.split('-').map(Number);
      if (cid === campId && ti > taskIdx) newTasks[`${cid}-${ti-1}`] = state.campaignTasks[k];
      else if (cid !== campId || ti !== taskIdx) newTasks[k] = state.campaignTasks[k];
    });
    state.campaignTasks = newTasks;
    _saveCampaigns();
    renderMarketing();
    return { ok:true };
  },
  getCampaigns(filter) {
    let camps = [...state.campaigns];
    if (filter?.status) camps = camps.filter(c => c.status === filter.status);
    return camps;
  },

  // â”€â”€â”€ CHAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sendAgentMessage(agentId, text) {
    if (!state.chatMessages[agentId]) {
      state.chatMessages[agentId] = [];
    }
    state.chatMessages[agentId].push({ from: 'agent', text, ts: ts() });
    _saveChatMessages();
    if (state.activeChat === agentId) renderChat();
    return { ok:true };
  },
  getChatHistory(agentId, limit) {
    const msgs = state.chatMessages[agentId] || [];
    return limit ? msgs.slice(-limit) : [...msgs];
  },
  clearChat(agentId) {
    if (state.chatMessages[agentId]) {
      state.chatMessages[agentId] = [];
      _saveChatMessages();
      if (state.activeChat === agentId) renderChat();
    }
    return { ok:true };
  },

  // â”€â”€â”€ REVENUECAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  rcAddApp(app) {
    if (!app.id || !app.name) return { ok:false, error:'id and name required' };
    if (state.rc.apps.find(a => a.id === app.id)) return { ok:false, error:'app id exists' };
    state.rc.apps.push({ id: app.id, name: app.name, icon: app.icon || 'ðŸ“±' });
    state.rc.appData[app.id] = {
      mrr: 0, mrrChange: 0, revenue: 0, revenueChange: 0,
      activeSubscribers: 0, subscribersChange: 0, activeTrial: 0, trialChange: 0,
      ltv: 0, ltvChange: 0, churnRate: 0, churnChange: 0,
      mrrHistory: { '7d':[], '30d':[], '90d':[] },
      products: [], transactions: [],
      subscriberStatus: { active:0, trial:0, grace:0, billing_retry:0, expired:0, cancelled:0 },
      funnel: { installs:0, paywallViews:0, trialStarts:0, conversions:0 },
    };
    if (!state.rc.selectedApp) state.rc.selectedApp = app.id;
    _saveRcData();
    renderAnalytics();
    return { ok:true, id: app.id };
  },
  rcRemoveApp(appId) {
    state.rc.apps = state.rc.apps.filter(a => a.id !== appId);
    delete state.rc.appData[appId];
    if (state.rc.selectedApp === appId) state.rc.selectedApp = state.rc.apps[0]?.id || '';
    _saveRcData();
    renderAnalytics();
    return { ok:true };
  },
  rcSelectApp(appId) {
    const app = state.rc.apps.find(a => a.id === appId);
    if (!app) return { ok:false, error:'unknown app' };
    state.rc.selectedApp = appId;
    _saveRcData();
    renderAnalytics();
    return { ok:true, app: appId };
  },
  rcSetTimeframe(tf) {
    state.rc.timeframe = tf;
    renderAnalytics();
    return { ok:true };
  },
  rcUpdateMetrics(metrics) {
    Object.assign(state.rc, metrics);
    _saveRcData();
    renderAnalytics();
    return { ok:true };
  },
  rcPushTransaction(tx) {
    tx.time = tx.time || ts();
    const d = _getRcData();
    (d.transactions || state.rc.transactions).unshift(tx);
    if ((d.transactions || state.rc.transactions).length > 50) (d.transactions || state.rc.transactions).pop();
    _saveRcData();
    renderAnalytics();
    return { ok:true };
  },
  rcUpdateProduct(productId, fields) {
    const d = _getRcData();
    const products = d.products || state.rc.products;
    const p = products.find(p => p.id === productId);
    if (!p) return { ok:false, error:'product not found' };
    Object.assign(p, fields);
    _saveRcData();
    renderAnalytics();
    return { ok:true };
  },
  rcAppendMrr(timeframe, value) {
    const d = _getRcData();
    const hist = d.mrrHistory || state.rc.mrrHistory;
    if (!hist[timeframe]) hist[timeframe] = [];
    hist[timeframe].push(value);
    _saveRcData();
    renderAnalytics();
    return { ok:true };
  },
  rcGetMetrics() {
    return JSON.parse(JSON.stringify(_getRcData()));
  },

  // â”€â”€â”€ NOTIFICATIONS / ALERTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  notify(msg) {
    const n = {
      id: Date.now(),
      agent: msg.agent || null,
      text: msg.text,
      level: msg.level || 'info', // info | warn | error | success
      ts: ts(),
    };
    state.notifications.push(n);
    _showToast(n);
    return { ok:true, id: n.id };
  },

  // â”€â”€â”€ MEETING / BRIEFING ROOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  meetingMessage(msg) {
    // Agent pushes a message into the active meeting
    if (!state.meeting.active && !msg.force) return { ok:false, error:'no active meeting' };
    const m = {
      id: Date.now(),
      agent: msg.agent,
      text: msg.text,
      ts: msg.ts || ts(),
      type: msg.type || 'message', // message | action-item | decision | question
    };
    state.meeting.messages.push(m);
    if (m.type === 'action-item') {
      state.meeting.actionItems.push({ agent: m.agent, text: m.text, ts: m.ts });
    }
    renderBriefing();
    return { ok:true, id: m.id };
  },
  startMeetingProgrammatic(opts) {
    state.meeting.active = true;
    state.meeting.topic = opts.topic || 'General Discussion';
    state.meeting.messages = [];
    state.meeting.actionItems = [];
    state.meeting.startedAt = Date.now();
    state.meeting.participants = opts.participants || state.agents.filter(a => a.admin !== false).map(a => a.id);
    state.meeting.messages.push({
      id: Date.now(), agent: null, type: 'system',
      text: `Meeting started: ${state.meeting.topic}`,
      ts: ts(),
    });
    renderBriefing();
    return { ok:true, topic: state.meeting.topic };
  },
  endMeetingProgrammatic() {
    if (!state.meeting.active) return { ok:false };
    const summary = {
      topic: state.meeting.topic,
      messages: [...state.meeting.messages],
      actionItems: [...state.meeting.actionItems],
      duration: Date.now() - state.meeting.startedAt,
      participants: [...state.meeting.participants],
      endedAt: Date.now(),
    };
    state.meeting.history.push(summary);
    _saveMeetingHistory();
    state.meeting.active = false;
    state.meeting.messages.push({
      id: Date.now(), agent: null, type: 'system',
      text: 'Meeting concluded.',
      ts: ts(),
    });
    renderBriefing();
    return { ok:true, summary };
  },
  addActionItem(item) {
    state.meeting.actionItems.push({
      agent: item.agent, text: item.text, ts: ts(),
    });
    renderBriefing();
    return { ok:true };
  },
  getMeetingState() {
    return JSON.parse(JSON.stringify(state.meeting));
  },
  getMeetingHistory() {
    return [...state.meeting.history];
  },

  // â”€â”€â”€ AVATAR / CHARACTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getAvatarConfig(agentId) {
    return state.avatarConfigs[agentId] ? {...state.avatarConfigs[agentId]} : null;
  },
  setAvatarConfig(agentId, cfg) {
    if (!getAgent(agentId)) return { ok:false, error:'unknown agent' };
    state.avatarConfigs[agentId] = {...(state.avatarConfigs[agentId] || {}), ...cfg};
    invalidateAvatarCache(agentId);
    renderAll();
    return { ok:true, agentId };
  },
  randomizeAvatarConfig(agentId) {
    if (!getAgent(agentId)) return { ok:false, error:'unknown agent' };
    const ag = getAgent(agentId);
    const rng = _seeded(Date.now());
    state.avatarConfigs[agentId] = {
      skin: _pick(rng, SKIN_TONES),
      hairColor: _pick(rng, HAIR_COLORS),
      hair: Math.floor(rng() * 8),
      eyes: Math.floor(rng() * 5),
      mouth: Math.floor(rng() * 4),
      accessory: Math.floor(rng() * 6),
      bodyType: Math.floor(rng() * 3),
      clothes: ag.color,
      pants: _darkenHex(ag.color, 90),
      shoes: _pick(rng, ['#2a1f14','#1a1a2e','#8b2020','#e8e8e8','#3a5c3a','#4a3060']),
      blush: rng() > 0.4,
    };
    invalidateAvatarCache(agentId);
    renderAll();
    return { ok:true, agentId, config: state.avatarConfigs[agentId] };
  },

  // â”€â”€â”€ NAVIGATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchView(view) {
    if (viewTitles[view]) { switchView(view); return { ok:true }; }
    return { ok:false, error:'unknown view' };
  },
  selectDate(date) {
    state.selectedDate = date;
    renderCalendar();
    return { ok:true };
  },
  selectCampaign(index) {
    state.selectedCampaign = index;
    renderMarketing();
    return { ok:true };
  },
  selectChatAgent(agentId) {
    if (!getAgent(agentId)) return { ok:false, error:'unknown agent' };
    state.activeChat = agentId;
    renderChatAgentList();
    renderChat();
    return { ok:true };
  },

  // â”€â”€â”€ BULK / STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getState() { return JSON.parse(JSON.stringify(state, (k,v) => k==='ws'?undefined:v)); },
  importState(partial) {
    Object.keys(partial).forEach(k => {
      if (k !== 'ws' && k !== 'connected' && state.hasOwnProperty(k)) {
        state[k] = partial[k];
      }
    });
    renderAll();
    return { ok:true };
  },
  renderAll() { renderAll(); return { ok:true }; },
};

// â”€â”€ TOAST NOTIFICATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _showToast(n) {
  const container = $('#toast-container');
  const ag = getAgent(n.agent);
  const el = document.createElement('div');
  el.className = `toast ${n.level}`;
  el.innerHTML = `
    ${ag ? `<span class="toast-agent" style="color:${ag.color};">${ag.name}</span>` : ''}
    <span class="toast-text">${_esc(n.text)}</span>
    <span style="font-size:8px;color:var(--text-muted);">${n.ts}</span>
  `;
  container.appendChild(el);
  // Auto-remove after 5s
  setTimeout(() => {
    el.classList.add('toast-fade');
    setTimeout(() => el.remove(), 300);
  }, 5000);
  // Max 5 toasts visible
  while (container.children.length > 5) container.firstChild.remove();
}

// â”€â”€ NAVIGATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const viewTitles = {
  warroom: ['Organization Structure','NODE GRAPH EDITOR'],
  chat: ['Agent Chat','DIRECT COMMS'],
  calendar: ['Calendar','SCHEDULE'],
  marketing: ['Marketing','CAMPAIGN OPS'],
  tasks: ['Task Board','OPERATIONS'],
  cron: ['Cron Jobs','SCHEDULED AUTOMATION'],
  analytics: ['RevenueCat','SUBSCRIPTION ANALYTICS'],
  briefing: ['Briefing Room','AUTONOMOUS MEETING'],
  logs: ['Agent Logs','ACTIVITY FEED'],
  prompts: ['System Prompts','AGENT CONFIGURATION'],
  vault: ['API Vault','SECRETS & KEYS'],
};

function switchView(view) {
  state.activeView = view;
  $$('.view-panel').forEach(p => p.classList.remove('active'));
  $(`#${view}`).classList.add('active');
  $$('.nav-btn[data-view]').forEach(b => b.classList.toggle('active', b.dataset.view === view));
  const [t, s] = viewTitles[view] || ['',''];
  $('#view-title').textContent = t;
  $('#view-sub').textContent = s;
}

$$('.nav-btn[data-view]').forEach(btn => {
  btn.addEventListener('click', () => switchView(btn.dataset.view));
});

// â”€â”€ SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$('#settings-btn').addEventListener('click', () => {
  $('#cfg-url').value = state.gatewayUrl;
  $('#cfg-token').value = state.authToken;
  $('#cfg-agents').value = JSON.stringify(state.agents, null, 2);
  // Populate sync toggle + status
  const syncCb = $('#cfg-gw-sync');
  if (syncCb) syncCb.checked = _storage._gatewaySyncEnabled;
  const syncStatus = $('#cfg-sync-status');
  if (syncStatus) {
    if (!state.connected) syncStatus.textContent = 'â€” disconnected';
    else if (_storage._gatewaySynced) syncStatus.textContent = 'â— synced';
    else syncStatus.textContent = 'â—‹ connected, not yet synced';
  }
  $('#settings-overlay').classList.add('open');
  _renderBackupList();
});
function closeSettings() { $('#settings-overlay').classList.remove('open'); }
function saveSettings() {
  state.gatewayUrl = $('#cfg-url').value || 'ws://127.0.0.1:18789';
  state.authToken = $('#cfg-token').value;
  _safeSave('oc_gw_url', state.gatewayUrl);
  _safeSave('oc_gw_token', state.authToken);
  try {
    const agents = JSON.parse($('#cfg-agents').value);
    if (Array.isArray(agents)) {
      state.agents = agents;
      _saveAgents();
    }
  } catch(e) {}
  closeSettings();
  connectGateway();
  renderAll();
}
$('#settings-overlay').addEventListener('click', e => { if (e.target === $('#settings-overlay')) closeSettings(); });

function copyInstallLink() {
  const cfgUrl = $('#cfg-url')?.value || state.gatewayUrl;
  const cfgToken = $('#cfg-token')?.value || state.authToken;
  const gateway = (cfgUrl || '').trim();
  const token = (cfgToken || '').trim();
  if (!gateway) {
    _showToast({ text: 'Set a gateway URL before copying install link', level: 'warn', ts: ts() });
    return;
  }

  const base = (location.protocol === 'file:')
    ? location.href.split('?')[0].split('#')[0]
    : `${location.origin}${location.pathname}`;
  const qp = new URLSearchParams();
  qp.set('gateway', gateway);
  if (token) qp.set('token', token);
  const installLink = `${base}?${qp.toString()}`;

  if (!navigator.clipboard?.writeText) {
    window.prompt('Copy this install link:', installLink);
    return;
  }
  navigator.clipboard.writeText(installLink).then(() => {
    _showToast({ text: 'Copied install link to clipboard', level: 'success', ts: ts() });
  }).catch(() => {
    window.prompt('Copy failed. Use this install link:', installLink);
  });
}

// Export state as JSON file
$('#cfg-export')?.addEventListener('click', () => _storage.exportToFile());
$('#cfg-copy-link')?.addEventListener('click', copyInstallLink);

// Import state from JSON file
$('#cfg-import')?.addEventListener('click', () => { $('#cfg-import-file').click(); });
$('#cfg-import-file')?.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    if (confirm(`Import state from ${file.name}? This will overwrite current data. A backup will be created first.`)) {
      _storage.createBackup('pre-import').then(() => {
        if (_storage.importFromFile(ev.target.result)) {
          _showToast({ text: 'State imported successfully', level: 'success', ts: ts() });
        } else {
          alert('Import failed â€” file may be corrupted.');
        }
      });
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

// Reset all data
$('#cfg-reset')?.addEventListener('click', () => {
  if (confirm('âš  Delete ALL OpenClaw data? This removes all agents, tasks, events, campaigns, chat history, vault secrets, settings, AND all backups. This cannot be undone.')) {
    if (confirm('Are you absolutely sure? This is permanent.')) {
      _storage.factoryReset();
    }
  }
});

// Save status click â†’ show storage details
$('#save-status')?.addEventListener('click', async () => {
  const lines = [];
  lines.push(`OpenClaw CC v${OC_VERSION}`);
  lines.push('');

  // Gateway sync status
  if (state.connected && _storage._gatewaySynced) {
    lines.push('â— Gateway: Synced');
    if (_storage._gatewayLastAck) lines.push(`  Last confirmed: ${new Date(_storage._gatewayLastAck).toLocaleString()}`);
  } else if (state.connected) {
    lines.push('â—‹ Gateway: Connected (sync pending)');
  } else {
    lines.push('â€” Gateway: Disconnected (local only)');
  }

  // IndexedDB status
  lines.push(_storage.ready ? 'â— IndexedDB: Active' : 'â€” IndexedDB: Not available');

  // Backups
  if (_storage.ready) {
    const backups = await _storage.getBackups();
    const lastBackup = backups[0];
    lines.push(`â— Backups: ${backups.length}/${MAX_BACKUPS}`);
    if (lastBackup) lines.push(`  Latest: ${new Date(lastBackup.timestamp).toLocaleString()} (${Math.round(lastBackup.size/1024)}KB)`);
  }

  // Last save
  if (_storage._lastSaveTs) {
    lines.push(`â— Last save: ${new Date(_storage._lastSaveTs).toLocaleString()}`);
  }

  // State size
  const snap = _storage._getSerializableState();
  lines.push(`â— State size: ${Math.round(JSON.stringify(snap).length/1024)}KB`);

  lines.push('');
  lines.push('Recovery chain: Gateway â†’ IndexedDB â†’ localStorage â†’ Defaults');

  if (_storage.ready) {
    const backups = await _storage.getBackups();
    if (backups.length > 0) {
      lines.push('');
      const doRestore = confirm(lines.join('\n') + '\n\nRestore from latest backup?');
      if (doRestore) {
        _updateSaveIndicator('recovering');
        const ok = await _storage.restoreBackup(backups[0].id);
        _showToast({ text: ok ? 'Restored from backup!' : 'Restore failed', level: ok ? 'success' : 'error', ts: ts() });
      }
      return;
    }
  }

  alert(lines.join('\n'));
});

// Backup now button
$('#cfg-backup-now')?.addEventListener('click', async () => {
  const id = await _storage.createBackup('manual');
  if (id) {
    _showToast({ text: 'Backup created successfully', level: 'success', ts: ts() });
    _renderBackupList();
  } else {
    _showToast({ text: 'Backup failed â€” IndexedDB may not be available', level: 'error', ts: ts() });
  }
});

// Gateway sync toggle
$('#cfg-gw-sync')?.addEventListener('change', (e) => {
  _storage._gatewaySyncEnabled = e.target.checked;
  if (e.target.checked && state.connected) {
    // Immediately sync
    const snap = _storage._getSerializableState();
    snap._savedAt = _storage._lastSaveTs;
    _storage._syncToGateway(snap);
    _showToast({ text: 'Gateway sync enabled â€” pushing state', level: 'info', ts: ts() });
  } else if (!e.target.checked) {
    _storage._gatewaySynced = false;
    _updateSaveIndicator('saved');
    _showToast({ text: 'Gateway sync disabled â€” local only', level: 'info', ts: ts() });
  }
});

// Force push local state to gateway
$('#cfg-gw-push')?.addEventListener('click', () => {
  if (!state.connected || !state.ws) {
    _showToast({ text: 'Not connected to gateway', level: 'error', ts: ts() });
    return;
  }
  const snap = _storage._getSerializableState();
  snap._savedAt = Date.now();
  _storage._lastSaveTs = snap._savedAt;
  _storage._syncToGateway(snap);
  _showToast({ text: 'State pushed to gateway', level: 'success', ts: ts() });
});

// Force pull state from gateway
$('#cfg-gw-pull')?.addEventListener('click', () => {
  if (!state.connected || !state.ws) {
    _showToast({ text: 'Not connected to gateway', level: 'error', ts: ts() });
    return;
  }
  // Force pull by setting local timestamp to 0 so gateway always wins
  _storage._lastSaveTs = 0;
  _storage.requestStateFromGateway();
  _showToast({ text: 'Requesting state from gateway...', level: 'info', ts: ts() });
});

// Backup list rendering
async function _renderBackupList() {
  const el = $('#cfg-backup-list');
  if (!el || !_storage.ready) {
    if (el) el.innerHTML = '<div style="font-size:9px;color:var(--text-muted);padding:6px;">IndexedDB not available</div>';
    return;
  }
  const backups = await _storage.getBackups();
  if (backups.length === 0) {
    el.innerHTML = '<div style="font-size:9px;color:var(--text-muted);padding:6px;">No backups yet</div>';
    return;
  }
  el.innerHTML = `
    <div style="font-size:8px;color:var(--text-muted);padding:2px 0 4px;letter-spacing:.5px;text-transform:uppercase;">Backups (${backups.length}/${MAX_BACKUPS})</div>
    ${backups.slice(0, 10).map(b => `
      <div style="display:flex;align-items:center;gap:6px;padding:3px 0;border-bottom:1px solid var(--border);font-size:9px;">
        <span style="color:var(--text-muted);min-width:36px;">${b.label}</span>
        <span style="flex:1;color:var(--text-secondary);">${new Date(b.timestamp).toLocaleString()}</span>
        <span style="color:var(--text-muted);font-family:var(--font-mono,monospace);">${Math.round(b.size/1024)}KB</span>
        <button class="btn" style="font-size:8px;padding:1px 6px;" onclick="_restoreBackupById(${b.id})">Restore</button>
      </div>
    `).join('')}
    ${backups.length > 10 ? `<div style="font-size:8px;color:var(--text-muted);padding:4px 0;">+${backups.length - 10} more...</div>` : ''}
  `;
}

async function _restoreBackupById(id) {
  if (!confirm('Restore from this backup? Current state will be overwritten.')) return;
  await _storage.createBackup('pre-restore'); // Safety backup first
  _updateSaveIndicator('recovering');
  const ok = await _storage.restoreBackup(id);
  if (ok) {
    _showToast({ text: 'Restored from backup!', level: 'success', ts: ts() });
    closeSettings();
  } else {
    _showToast({ text: 'Restore failed', level: 'error', ts: ts() });
  }
}

// â”€â”€ BEFOREUNLOAD GUARD â”€â”€
window.addEventListener('beforeunload', (e) => {
  if (_storage._dirty) {
    // Force a sync save before leaving
    try {
      const snap = _storage._getSerializableState();
      STATE_KEYS.forEach(k => {
        try {
          const val = k === 'meeting_history' ? (state.meeting?.history || []) : state[k];
          localStorage.setItem('oc_' + k, JSON.stringify(val));
        } catch(err) {}
      });
    } catch(err) {}
    e.preventDefault();
    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
  }
});

// â”€â”€ VISIBILITY CHANGE â€” save when tab goes background â”€â”€
document.addEventListener('visibilitychange', () => {
  if (document.hidden && _storage._dirty) {
    _storage.persistFullState();
  }
});

// â”€â”€ RENDER: Agent Pills (topbar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderAgentPills() {
  const el = $('#agent-pills');
  const statusIcon = { active:'â—', idle:'â—‹', busy:'â—‰', error:'âœ•', offline:'â€”' };
  const statusClr = { active:null, idle:'#ffd60a', busy:'#0a84ff', error:'#ff453a', offline:'#8e8e93' };
  el.innerHTML = state.agents.map(a => {
    const st = state.agentStatus[a.id] || 'active';
    const clr = statusClr[st] || a.color;
    return `
    <div class="agent-pill" style="border-color:${a.color}22;background:${a.color}08;" title="${a.name}: ${st}">
      <img src="${getAvatarDataUrl(a.id, 2)}" class="pixel-art" style="width:16px;height:22px;">
      <span class="dot" style="background:${clr};box-shadow:0 0 6px ${clr};width:5px;height:5px;${st==='offline'?'opacity:.3;animation:none;':''}"></span>
      <span style="color:${a.color};font-weight:600;">${a.name}${a.admin !== false ? '<span style="color:var(--accent-green);font-size:6px;margin-left:2px;">â˜…</span>' : ''}</span>
    </div>
  `}).join('');
}

// â”€â”€ RENDER: Organization Structure (Node Graph) â”€â”€â”€â”€â”€
const GRID_SNAP = 20;
let _dragNode = null, _dragOffset = {x:0,y:0};
let _wireDrawing = null; // {fromAgent, fromPort, startX, startY}

// Pan & Zoom state
let _pan = { x: 0, y: 0 };
let _zoom = 1;
const ZOOM_MIN = 0.25, ZOOM_MAX = 2.5, ZOOM_STEP = 0.08;
let _isPanning = false, _panStart = {x:0, y:0};

function _applyWorldTransform() {
  const world = $('#org-world');
  if (world) {
    world.style.transform = `translate(${_pan.x}px, ${_pan.y}px) scale(${_zoom})`;
  }
  const label = $('#org-zoom-label');
  if (label) label.textContent = `${Math.round(_zoom * 100)}%`;
}

// Convert screen coords â†’ world coords
function _screenToWorld(screenX, screenY) {
  const canvasRect = $('#org-canvas').getBoundingClientRect();
  return {
    x: (screenX - canvasRect.left - _pan.x) / _zoom,
    y: (screenY - canvasRect.top - _pan.y) / _zoom,
  };
}

// Convert world coords â†’ canvas-relative screen coords
function _worldToScreen(worldX, worldY) {
  return {
    x: worldX * _zoom + _pan.x,
    y: worldY * _zoom + _pan.y,
  };
}

function renderOrgChart() {
  _applyWorldTransform();
  renderOrgNodes();
  renderOrgWires();
}

function renderOrgNodes() {
  const container = $('#org-nodes');
  if (!container) return;

  // Only rebuild nodes if count changed; otherwise just reposition
  const existing = container.querySelectorAll('.org-node');
  if (existing.length !== state.agents.length) {
    _buildOrgNodes(container);
  } else {
    // Just update positions + status
    existing.forEach(node => {
      const id = node.dataset.id;
      const pos = state.orgPositions[id];
      if (pos) { node.style.left = pos.x+'px'; node.style.top = pos.y+'px'; }
      _updateOrgNodeStatus(node, id);
    });
  }
  _updatePortStates();
}

function _buildOrgNodes(container) {
  container.innerHTML = '';
  state.agents.forEach(a => {
    const pos = state.orgPositions[a.id] || {x:100, y:100};
    const node = document.createElement('div');
    node.className = 'org-node';
    node.dataset.id = a.id;
    node.style.left = pos.x + 'px';
    node.style.top = pos.y + 'px';

    node.innerHTML = `
      <div class="org-node-actions">
        <button class="org-node-act" data-agent-edit="${a.id}" title="Edit ${a.name}">âœŽ</button>
        <button class="org-node-act danger" data-agent-del="${a.id}" title="Delete ${a.name}">âœ•</button>
      </div>
      <div class="org-port port-top" data-agent="${a.id}" data-port="top"></div>
      <div class="org-port port-bottom" data-agent="${a.id}" data-port="bottom"></div>
      <div class="org-port port-left" data-agent="${a.id}" data-port="left"></div>
      <div class="org-port port-right" data-agent="${a.id}" data-port="right"></div>
      <div class="org-node-body">
        <div class="org-node-header">
          <img src="${getAvatarDataUrl(a.id, 2)}" class="pixel-art" style="width:18px;height:25px;">
          <div class="org-node-dot" style="background:${a.color};"></div>
          <div class="org-node-name" style="color:${a.color};">${a.name}</div>
          <div class="org-node-status" id="org-status-${a.id}"></div>
        </div>
        <div class="org-node-role">${a.role} Agent</div>
        <div class="org-node-model" style="font-size:8px;color:var(--text-muted);margin-top:2px;font-family:var(--font-mono,monospace);">${a.model ? _modelDisplayName(a.model) : ''}</div>
        <div style="margin-top:3px;">
          <span style="font-size:7px;font-weight:700;letter-spacing:.5px;padding:1px 5px;border-radius:3px;
            background:${a.admin !== false ? 'rgba(52,199,89,.12)' : 'rgba(142,142,147,.1)'};
            color:${a.admin !== false ? 'var(--accent-green)' : 'var(--text-muted)'};">
            ${a.admin !== false ? 'â˜… ADMIN' : 'WORKER'}
          </span>
        </div>
        <div class="org-node-skills">
          ${(a.skills||[]).map(s => `<span class="org-node-skill">${s}</span>`).join('')}
        </div>
        <div class="org-node-stats">
          <span id="org-conns-${a.id}">0 connections</span>
        </div>
      </div>
    `;

    _updateOrgNodeStatus(node, a.id);

    // Card drag
    node.addEventListener('mousedown', e => {
      if (e.target.classList.contains('org-port')) return;
      if (e.target.closest('.org-node-actions')) return;
      e.preventDefault();
      e.stopPropagation();
      _dragNode = node;
      // Offset in world space
      const worldMouse = _screenToWorld(e.clientX, e.clientY);
      const pos = state.orgPositions[a.id] || {x:0, y:0};
      _dragOffset = { x: worldMouse.x - pos.x, y: worldMouse.y - pos.y };
      node.classList.add('dragging');
      node.style.zIndex = 10;
    });

    // Port drag (wire drawing)
    node.querySelectorAll('.org-port').forEach(port => {
      port.addEventListener('mousedown', e => {
        e.preventDefault();
        e.stopPropagation();
        const portWorld = _getPortWorldPosition(port);
        _wireDrawing = {
          fromAgent: port.dataset.agent,
          fromPort: port.dataset.port,
          startX: portWorld.x,
          startY: portWorld.y,
        };
        $('#org-hint').textContent = 'Release on a port to connect';
        $('#org-hint').style.color = 'var(--accent-blue)';
      });
    });

    // Edit/delete actions on node
    node.querySelector('[data-agent-edit]')?.addEventListener('click', e => {
      e.stopPropagation();
      _openAgentModal(a.id);
    });
    node.querySelector('[data-agent-del]')?.addEventListener('click', e => {
      e.stopPropagation();
      if (confirm(`Delete ${a.name}? This removes all connections, tasks, prompts, and vault access.`)) {
        _deleteAgent(a.id);
      }
    });

    container.appendChild(node);
  });
}

function _updateOrgNodeStatus(node, id) {
  const st = state.agentStatus[id] || 'active';
  const statusEl = node.querySelector(`#org-status-${id}`);
  const dotEl = node.querySelector('.org-node-dot');
  if (statusEl) {
    statusEl.textContent = st.toUpperCase();
    statusEl.style.color = st==='active'?'var(--accent-green)':st==='error'?'var(--accent-red)':st==='busy'?'var(--accent-blue)':st==='idle'?'var(--accent-yellow)':'var(--text-muted)';
  }
  if (dotEl) {
    const a = getAgent(id);
    dotEl.style.boxShadow = st==='active'?`0 0 8px ${a?.color}`:st==='error'?'0 0 8px var(--accent-red)':'none';
    dotEl.style.animation = st==='active'?'pulse 2.5s infinite':'none';
  }
  // Update connection count
  const conns = state.orgConnections.filter(c => c.from===id || c.to===id).length;
  const connEl = node.querySelector(`#org-conns-${id}`);
  if (connEl) connEl.textContent = `${conns} connection${conns!==1?'s':''}`;
}

function _updatePortStates() {
  $$('.org-port').forEach(port => {
    const agent = port.dataset.agent;
    const portName = port.dataset.port;
    const isConnected = state.orgConnections.some(c =>
      (c.from === agent && c.fromPort === portName) || (c.to === agent && c.toPort === portName)
    );
    port.classList.toggle('connected', isConnected);
  });
}

function renderOrgWires() {
  const svg = $('#org-wires');
  if (!svg) return;

  // Remove old delete buttons
  document.querySelectorAll('.wire-del-btn').forEach(el => el.remove());

  svg.innerHTML = state.orgConnections.map(conn => {
    const fromPos = _getPortPosition(conn.from, conn.fromPort);
    const toPos = _getPortPosition(conn.to, conn.toPort);
    if (!fromPos || !toPos) return '';

    const fromAgent = getAgent(conn.from);
    const color = fromAgent?.color || 'var(--accent-blue)';
    const path = _bezierPath(fromPos, toPos, conn.fromPort, conn.toPort);

    return `
      <path class="wire-glow" d="${path}" stroke="${color}" data-id="${conn.id}"/>
      <path class="wire" d="${path}" stroke="${color}" data-id="${conn.id}"/>
    `;
  }).join('');

  // Create HTML delete buttons at wire midpoints
  const world = $('#org-world');
  if (!world) return;

  state.orgConnections.forEach(conn => {
    const fromPos = _getPortPosition(conn.from, conn.fromPort);
    const toPos = _getPortPosition(conn.to, conn.toPort);
    if (!fromPos || !toPos) return;

    const mx = (fromPos.x + toPos.x) / 2;
    const my = (fromPos.y + toPos.y) / 2;
    const fromAgent = getAgent(conn.from);
    const toAgent = getAgent(conn.to);

    const btn = document.createElement('div');
    btn.className = 'wire-del-btn';
    btn.dataset.connId = conn.id;
    btn.innerHTML = `<span class="wire-del-icon">âˆ’</span>
      <span class="wire-del-label">${fromAgent?.name||conn.from} â†’ ${toAgent?.name||conn.to}</span>`;
    btn.style.left = mx + 'px';
    btn.style.top = my + 'px';
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      window.__openclaw_cc.removeConnection(conn.id);
    });
    world.appendChild(btn);
  });
}

function _getPortPosition(agentId, portName, canvasRect) {
  // Returns world-space coords for SVG drawing (SVG is inside world)
  const port = document.querySelector(`.org-port[data-agent="${agentId}"][data-port="${portName}"]`);
  if (!port) return null;
  return _getPortWorldPosition(port);
}

function _getPortWorldPosition(port) {
  // Convert port screen position to world coordinates
  const rect = port.getBoundingClientRect();
  const screenCenterX = rect.left + rect.width / 2;
  const screenCenterY = rect.top + rect.height / 2;
  return _screenToWorld(screenCenterX, screenCenterY);
}

function _bezierPath(from, to, fromPort, toPort) {
  const dist = Math.max(50, Math.abs(to.x - from.x) * 0.4, Math.abs(to.y - from.y) * 0.4);
  const dirs = { top:{x:0,y:-1}, bottom:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
  const fd = dirs[fromPort] || dirs.bottom;
  const td = dirs[toPort] || dirs.top;
  const cp1x = from.x + fd.x * dist;
  const cp1y = from.y + fd.y * dist;
  const cp2x = to.x + td.x * dist;
  const cp2y = to.y + td.y * dist;
  return `M${from.x},${from.y} C${cp1x},${cp1y} ${cp2x},${cp2y} ${to.x},${to.y}`;
}

// â”€â”€ Global mouse handlers for drag + wire drawing + pan â”€â”€

// Zoom with mouse wheel
$('#org-canvas')?.addEventListener('wheel', e => {
  e.preventDefault();
  const canvas = $('#org-canvas');
  const canvasRect = canvas.getBoundingClientRect();
  
  // Mouse position relative to canvas
  const mx = e.clientX - canvasRect.left;
  const my = e.clientY - canvasRect.top;
  
  // World position under cursor before zoom
  const worldBefore = _screenToWorld(e.clientX, e.clientY);
  
  // Apply zoom
  const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
  _zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, _zoom + delta * _zoom));
  
  // Adjust pan so the world point under cursor stays put
  _pan.x = mx - worldBefore.x * _zoom;
  _pan.y = my - worldBefore.y * _zoom;
  
  _applyWorldTransform();
  renderOrgWires();
  _saveViewState();
}, { passive: false });

// Debounce view save
let _viewSaveTimeout = null;
function _saveViewState() {
  if (_viewSaveTimeout) clearTimeout(_viewSaveTimeout);
  _viewSaveTimeout = setTimeout(() => {
    localStorage.setItem('oc_orgView', JSON.stringify({ pan: _pan, zoom: _zoom }));
  }, 300);
}

// Pan with middle mouse or Alt+left drag
$('#org-canvas')?.addEventListener('mousedown', e => {
  // Only start pan if clicking on canvas background (not on node/port)
  const isOnNode = e.target.closest('.org-node');
  const isOnPort = e.target.classList.contains('org-port');
  const isOnToolbar = e.target.closest('.org-toolbar') || e.target.closest('.org-legend');
  
  if (isOnToolbar) return;
  
  // Middle mouse button (1) or Alt+left click
  if (e.button === 1 || (e.button === 0 && e.altKey) || (e.button === 0 && !isOnNode && !isOnPort)) {
    if (e.button === 0 && !e.altKey && (isOnNode || isOnPort)) return;
    e.preventDefault();
    _isPanning = true;
    _panStart = { x: e.clientX - _pan.x, y: e.clientY - _pan.y };
    $('#org-canvas').classList.add('panning');
  }
});

document.addEventListener('mousemove', e => {
  const canvas = $('#org-canvas');
  if (!canvas) return;

  // Canvas panning
  if (_isPanning) {
    _pan.x = e.clientX - _panStart.x;
    _pan.y = e.clientY - _panStart.y;
    _applyWorldTransform();
    renderOrgWires();
    return; // Don't process other drags during pan
  }

  // Card dragging (world coords)
  if (_dragNode) {
    const world = _screenToWorld(e.clientX, e.clientY);
    let x = world.x - _dragOffset.x;
    let y = world.y - _dragOffset.y;
    // Snap to grid
    x = Math.round(x / GRID_SNAP) * GRID_SNAP;
    y = Math.round(y / GRID_SNAP) * GRID_SNAP;
    // Clamp to reasonable bounds
    x = Math.max(-200, x);
    y = Math.max(-200, y);
    _dragNode.style.left = x + 'px';
    _dragNode.style.top = y + 'px';
    state.orgPositions[_dragNode.dataset.id] = {x, y};
    renderOrgWires();
  }

  // Wire preview (world coords)
  if (_wireDrawing) {
    const world = _screenToWorld(e.clientX, e.clientY);
    const preview = $('#org-wire-preview');
    const path = _bezierPath(
      {x: _wireDrawing.startX, y: _wireDrawing.startY},
      {x: world.x, y: world.y},
      _wireDrawing.fromPort,
      'top'
    );
    preview.innerHTML = `<path d="${path}"/>`;
  }
});

document.addEventListener('mouseup', e => {
  // Finish panning
  if (_isPanning) {
    _isPanning = false;
    $('#org-canvas')?.classList.remove('panning');
    _saveViewState();
    return;
  }

  // Finish card drag
  if (_dragNode) {
    _dragNode.classList.remove('dragging');
    _dragNode.style.zIndex = 3;
    // Save positions
    _saveOrgPositions();
    _dragNode = null;
  }

  // Finish wire drawing
  if (_wireDrawing) {
    const preview = $('#org-wire-preview');
    if (preview) preview.innerHTML = '';

    // Check if we landed on a port
    const target = document.elementFromPoint(e.clientX, e.clientY);
    if (target && target.classList.contains('org-port')) {
      const toAgent = target.dataset.agent;
      const toPort = target.dataset.port;
      if (toAgent !== _wireDrawing.fromAgent) {
        // Check for duplicate
        const exists = state.orgConnections.some(c =>
          (c.from===_wireDrawing.fromAgent && c.to===toAgent && c.fromPort===_wireDrawing.fromPort && c.toPort===toPort) ||
          (c.from===toAgent && c.to===_wireDrawing.fromAgent && c.fromPort===toPort && c.toPort===_wireDrawing.fromPort)
        );
        if (!exists) {
          state.orgConnections.push({
            id: 'c'+Date.now(),
            from: _wireDrawing.fromAgent,
            fromPort: _wireDrawing.fromPort,
            to: toAgent,
            toPort: toPort,
          });
          _onConnectionsChanged('ui_wire');
        }
      }
    }

    _wireDrawing = null;
    $('#org-hint').textContent = 'Drag ports to connect Â· Drag cards to arrange Â· Scroll to zoom Â· Alt+drag to pan';
    $('#org-hint').style.color = 'var(--text-muted)';
  }
});

// Toolbar buttons
(function() {
  const autoBtn = $('#org-auto-layout');
  const resetBtn = $('#org-reset-wires');
  const exportBtn = $('#org-export-config');
  if (autoBtn) autoBtn.addEventListener('click', _autoLayoutOrg);
  if (resetBtn) resetBtn.addEventListener('click', () => {
    state.orgConnections = [];
    _onConnectionsChanged('ui_clear');
  });
  if (exportBtn) exportBtn.addEventListener('click', _showRoutingExport);
  const resetViewBtn = $('#org-reset-view');
  if (resetViewBtn) resetViewBtn.addEventListener('click', () => {
    _pan = { x: 0, y: 0 };
    _zoom = 1;
    _applyWorldTransform();
    renderOrgWires();
    localStorage.removeItem('oc_orgView');
  });
})();

// Auto-layout: arrange in hierarchy based on connections
function _autoLayoutOrg() {
  const canvas = $('#org-canvas');
  if (!canvas) return;
  const cw = canvas.clientWidth;

  // Find root nodes (no incoming connections)
  const hasIncoming = new Set(state.orgConnections.map(c => c.to));
  const roots = state.agents.filter(a => !hasIncoming.has(a.id));
  const placed = new Set();
  const layers = [];

  // BFS to build layers
  let currentLayer = roots.map(a => a.id);
  while (currentLayer.length > 0) {
    layers.push(currentLayer);
    currentLayer.forEach(id => placed.add(id));
    const nextLayer = [];
    currentLayer.forEach(id => {
      state.orgConnections.forEach(c => {
        if (c.from === id && !placed.has(c.to) && !nextLayer.includes(c.to)) {
          nextLayer.push(c.to);
        }
      });
    });
    currentLayer = nextLayer;
  }

  // Place any unplaced agents
  const unplaced = state.agents.filter(a => !placed.has(a.id)).map(a => a.id);
  if (unplaced.length > 0) layers.push(unplaced);

  // Position
  const ySpacing = 180;
  const startY = 40;
  layers.forEach((layer, li) => {
    const totalWidth = layer.length * 220;
    const startX = Math.max(20, (cw - totalWidth) / 2);
    layer.forEach((id, i) => {
      const x = Math.round((startX + i * 220) / GRID_SNAP) * GRID_SNAP;
      const y = Math.round((startY + li * ySpacing) / GRID_SNAP) * GRID_SNAP;
      state.orgPositions[id] = {x, y};
    });
  });

  _saveOrgPositions();
  renderOrgChart();
}

// Restore saved positions/connections/view
(function() {
  try {
    const savedPos = JSON.parse(localStorage.getItem('oc_orgPositions'));
    if (savedPos) Object.assign(state.orgPositions, savedPos);
    const savedConn = JSON.parse(localStorage.getItem('oc_orgConnections'));
    if (savedConn) state.orgConnections = savedConn;
    const savedView = JSON.parse(localStorage.getItem('oc_orgView'));
    if (savedView) {
      _pan = savedView.pan || { x: 0, y: 0 };
      _zoom = savedView.zoom || 1;
      _applyWorldTransform();
    }
  } catch(e) {}
})();

// â”€â”€ Routing Config Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function _showRoutingExport() {
  const config = _generateExportConfig();
  $('#routing-config-content').textContent = config;
  $('#routing-modal').classList.add('open');
}

function _generateExportConfig() {
  const lines = [];
  const timestamp = new Date().toISOString().split('T')[0];

  lines.push(`# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
  lines.push(`# OpenClaw Routing Configuration`);
  lines.push(`# Generated: ${timestamp}`);
  lines.push(`# Source: Command Center Organization Structure (Node Graph)`);
  lines.push(`# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
  lines.push(`#`);
  lines.push(`# HOW TO USE:`);
  lines.push(`# 1. Copy each agent's block into their $include config`);
  lines.push(`#    e.g. ~/.openclaw/include/routing.md`);
  lines.push(`# 2. Add to agent config: $include: [routing.md]`);
  lines.push(`# 3. Or paste directly into the agent's system prompt`);
  lines.push(`#`);
  lines.push(`# ENFORCEMENT:`);
  lines.push(`# Before using agent-send, check your routing table.`);
  lines.push(`# Only send messages to agents listed in YOUR section.`);
  lines.push(`# Use canvas.eval to verify live: `);
  lines.push(`#   __openclaw_cc.getConnectedAgents("<your-id>")`);
  lines.push(`# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`);

  // Global connection map summary
  lines.push(`## Connection Map\n`);
  state.agents.forEach(a => {
    const routing = window.__openclaw_cc.generateRoutingConfig(a.id);
    const names = routing.connected.map(c => c.name).join(', ') || 'NONE';
    lines.push(`${a.name} (${a.role}) â†’ ${names}`);
  });
  lines.push('');

  // Per-agent routing blocks
  state.agents.forEach(a => {
    const r = window.__openclaw_cc.generateRoutingConfig(a.id);
    lines.push(`\n# â”€â”€ ${a.name} (${a.role}) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
    lines.push(`# Paste into: ~/.openclaw/agents/${a.id}/include/routing.md\n`);
    lines.push(`<routing_rules agent="${a.id}">`);
    lines.push(`You are ${a.name}, the ${a.role} agent.`);
    lines.push(`Your communication is restricted to your node graph connections.`);
    lines.push(``);
    lines.push(`ALLOWED CONTACTS:`);
    if (r.connected.length === 0) {
      lines.push(`  (none â€” you are isolated. Request connections from the operator.)`);
    } else {
      if (r.upstream.length > 0) {
        lines.push(`  REPORTS TO (upstream):`);
        r.upstream.forEach(u => lines.push(`    - ${u.name} [${u.id}] â€” ${u.role}`));
      }
      if (r.downstream.length > 0) {
        lines.push(`  MANAGES (downstream):`);
        r.downstream.forEach(d => lines.push(`    - ${d.name} [${d.id}] â€” ${d.role}`));
      }
      if (r.lateral.length > 0) {
        lines.push(`  PEERS (lateral):`);
        r.lateral.forEach(l => lines.push(`    - ${l.name} [${l.id}] â€” ${l.role}`));
      }
    }
    lines.push(``);
    lines.push(`ROUTING RULES:`);
    lines.push(`1. ONLY use agent-send to contact: ${r.connected.map(c=>c.id).join(', ') || 'nobody'}`);
    lines.push(`2. If you need to reach an agent not in your list, ask a connected`);
    lines.push(`   agent to relay the message through the org structure.`);
    lines.push(`3. For broadcasts, send to each connected agent individually.`);
    lines.push(`4. Always push comms to the dashboard for visibility:`);
    lines.push(`   canvas.eval â†’ __openclaw_cc.pushComms({from:"${a.id}",to:"<target>",text:"..."})`);
    lines.push(`5. Before sending, you may verify live connections:`);
    lines.push(`   canvas.eval â†’ __openclaw_cc.getConnectedAgents("${a.id}")`);
    lines.push(`</routing_rules>`);
  });

  return lines.join('\n');
}

function copyRoutingConfig(mode) {
  const config = _generateExportConfig();
  let text = config;

  if (mode === 'individual') {
    // Build per-agent files list
    const parts = [];
    state.agents.forEach(a => {
      const r = window.__openclaw_cc.generateRoutingConfig(a.id);
      const block = config.split(`# â”€â”€ ${a.name}`)[1];
      if (block) {
        const nextAgent = state.agents.find((ag, i) => {
          const nextIdx = state.agents.indexOf(a) + 1;
          return i === nextIdx;
        });
        let agentBlock = block;
        if (nextAgent) {
          agentBlock = block.split(`\n# â”€â”€ ${nextAgent.name}`)[0];
        }
        parts.push(`--- ${a.id}/routing.md ---\n# â”€â”€ ${a.name}${agentBlock}`);
      }
    });
    text = parts.join('\n\n');
  }

  navigator.clipboard.writeText(text).then(() => {
    const btn = mode === 'individual'
      ? document.querySelectorAll('#routing-modal .btn')[1]
      : document.querySelectorAll('#routing-modal .btn.primary')[0];
    const orig = btn.textContent;
    btn.textContent = 'âœ“ COPIED';
    setTimeout(() => { btn.textContent = orig; }, 1500);
  }).catch(() => {
    // Fallback: select the text
    const el = $('#routing-config-content');
    const range = document.createRange();
    range.selectNodeContents(el);
    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);
  });
}

// Close routing modal on backdrop click
$('#routing-modal')?.addEventListener('click', e => {
  if (e.target.id === 'routing-modal') e.target.classList.remove('open');
});

// â”€â”€ Routing Auto-Sync Engine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pushes routing rules to agents via Gateway on every wire change
let _routingSyncDebounce = null;
let _lastRoutingHash = '';

function _syncAllRouting(reason) {
  if (!state.connected || !state.ws) {
    _updateSyncIndicator('offline');
    return;
  }

  // Debounce rapid wire changes (300ms)
  if (_routingSyncDebounce) clearTimeout(_routingSyncDebounce);
  _routingSyncDebounce = setTimeout(() => {
    // Check if routing actually changed
    const hash = JSON.stringify(state.orgConnections.map(c => `${c.from}:${c.fromPort}-${c.to}:${c.toPort}`).sort());
    if (hash === _lastRoutingHash && reason !== 'reconnect') {
      return; // No change
    }
    _lastRoutingHash = hash;

    console.log(`[Routing] Syncing to all agents (${reason})`);
    _updateSyncIndicator('syncing');

    let synced = 0;
    state.agents.forEach(a => {
      _pushRoutingToAgent(a.id);
      synced++;
    });

    // Persist to localStorage
    _saveOrgConnections();

    setTimeout(() => {
      _updateSyncIndicator('synced');
      console.log(`[Routing] Pushed to ${synced} agents`);
      // Flash hint
      const hint = $('#org-hint');
      if (hint) {
        hint.textContent = `âœ“ Routing synced to ${synced} agents`;
        hint.style.color = 'var(--accent-green)';
        setTimeout(() => {
          hint.textContent = 'Drag ports to connect Â· Drag cards to arrange Â· Double-click wire to remove';
          hint.style.color = 'var(--text-muted)';
        }, 2500);
      }
    }, 300);
  }, 300);
}

function _pushRoutingToAgent(agentId) {
  if (!state.connected || !state.ws) return;

  const r = window.__openclaw_cc.generateRoutingConfig(agentId);
  const agent = getAgent(agentId);
  if (!r.ok || !agent) return;

  // Build concise routing directive
  const allowedIds = r.connected.map(c => c.id);
  const upstreamNames = r.upstream.map(u => `${u.name} (${u.role})`);
  const downstreamNames = r.downstream.map(d => `${d.name} (${d.role})`);
  const lateralNames = r.lateral.map(l => `${l.name} (${l.role})`);

  let directive = `[ROUTING UPDATE] Your organization structure connections have been updated.\n`;
  directive += `You are ${agent.name}, ${agent.role} agent.\n\n`;

  if (allowedIds.length === 0) {
    directive += `You currently have NO connections. Do not use agent-send until connections are established.\n`;
  } else {
    directive += `ALLOWED agent-send targets: ${allowedIds.join(', ')}\n`;
    if (upstreamNames.length) directive += `Reports to: ${upstreamNames.join(', ')}\n`;
    if (downstreamNames.length) directive += `Manages: ${downstreamNames.join(', ')}\n`;
    if (lateralNames.length) directive += `Peers: ${lateralNames.join(', ')}\n`;
    directive += `\nRULES:\n`;
    directive += `- ONLY use agent-send for: ${allowedIds.join(', ')}\n`;
    directive += `- To reach others, relay through your connections.\n`;
    directive += `- Log all comms: canvas.eval â†’ __openclaw_cc.pushComms({from:"${agentId}",to:"<id>",text:"..."})\n`;
    directive += `- Verify live: canvas.eval â†’ __openclaw_cc.getConnectedAgents("${agentId}")\n`;
  }

  // Send as system message to agent
  state.ws.send(JSON.stringify({
    type: 'routing_update',
    agentId,
    directive,
    connections: allowedIds,
    upstream: r.upstream.map(u => u.id),
    downstream: r.downstream.map(d => d.id),
    lateral: r.lateral.map(l => l.id),
    timestamp: Date.now(),
  }));

  // Also send as a regular message the agent can read
  state.ws.send(JSON.stringify({
    type: 'message',
    agentId,
    text: directive,
    system: true,
  }));
}

function _updateSyncIndicator(status) {
  const dot = $('#org-sync-dot');
  const label = $('#org-sync-label');
  const hint = $('#org-hint');
  if (!dot || !label) return;
  if (status === 'syncing') {
    dot.style.background = 'var(--accent-blue)';
    label.textContent = 'syncing...';
    label.style.color = 'var(--accent-blue)';
    if (hint) { hint.textContent = 'âŸ³ Pushing routing to agents...'; hint.style.color = 'var(--accent-blue)'; }
  } else if (status === 'synced') {
    dot.style.background = 'var(--accent-green)';
    dot.style.animation = 'pulse 2s 1';
    label.textContent = 'synced';
    label.style.color = 'var(--accent-green)';
    setTimeout(() => { label.textContent = 'live'; dot.style.animation = ''; }, 3000);
  } else if (status === 'offline') {
    dot.style.background = 'var(--accent-yellow)';
    label.textContent = 'offline â€” will sync on connect';
    label.style.color = 'var(--accent-yellow)';
    if (hint) {
      hint.textContent = 'Changes saved locally â€” will push to agents on Gateway connect';
      hint.style.color = 'var(--accent-yellow)';
      setTimeout(() => {
        hint.textContent = 'Drag ports to connect Â· Drag cards to arrange Â· Double-click wire to remove';
        hint.style.color = 'var(--text-muted)';
      }, 3000);
    }
  }
}

// Hook: called after any connection mutation
function _onConnectionsChanged(reason) {
  _saveOrgConnections();
  renderOrgChart();
  _syncAllRouting(reason || 'wire_change');
}

function renderWarChatter() {
  const el = $('#feed-scroll');
  if (!el) return;
  el.innerHTML = state.warChatter.map((m, i) => {
    const from = getAgent(m.from);
    const to = m.to === 'all' ? null : getAgent(m.to);
    // Check if connected
    const isConnected = m.to === 'all' || state.orgConnections.some(c =>
      (c.from===m.from && c.to===m.to) || (c.from===m.to && c.to===m.from)
    );
    return `
      <div class="comms-msg" style="animation-delay:${i*.05}s;${!isConnected?'opacity:.35;':''}">
        <div class="msg-route">
          <img src="${getAvatarDataUrl(m.from, 2)}" class="pixel-art" style="width:14px;height:20px;">
          <span style="color:${from?.color||'#fff'};font-weight:600;">${from?.name||m.from}</span>
          <span class="arrow">â†’</span>
          ${to ? `<img src="${getAvatarDataUrl(m.to, 2)}" class="pixel-art" style="width:14px;height:20px;">` : ''}
          <span style="color:${to?.color||'var(--accent-blue)'};font-weight:600;">${to?.name||'ALL'}</span>
          <span class="ts">${m.ts}</span>
        </div>
        <div class="msg-body" style="border-color:${from?.color||'var(--border)'}20;">${_esc(m.text)}</div>
      </div>
    `;
  }).join('');
  el.scrollTop = el.scrollHeight;
  const fc = $('#feed-count');
  if (fc) fc.textContent = `${state.warChatter.length} messages Â· via node graph`;
}

// Drip chatter â€” only runs if pool has messages
let chatterIdx = 0;
function dripChatter() {
  if (CHATTER_POOL.length === 0) return; // No demo data, skip entirely
  if (chatterIdx < CHATTER_POOL.length) {
    const msg = { ...CHATTER_POOL[chatterIdx], ts: ts() };
    state.warChatter.push(msg);
    renderWarChatter();
    chatterIdx++;
  }
  if (chatterIdx < CHATTER_POOL.length) {
    setTimeout(dripChatter, 3000 + Math.random() * 4000);
  }
}

// â”€â”€ RENDER: Chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderChatAgentList() {
  const el = $('#chat-agent-list');
  el.innerHTML = state.agents.map(a => {
    const modelName = _modelDisplayName(a.model);
    return `
    <button class="chat-agent-btn ${state.activeChat===a.id?'active':''}" data-id="${a.id}"
      style="border-left-color:${state.activeChat===a.id?a.color:'transparent'};">
      <img src="${getAvatarDataUrl(a.id, 2)}" class="pixel-art" style="width:24px;height:34px;flex-shrink:0;">
      <div>
        <div class="agent-name" style="color:${a.color};">${a.name}${a.admin !== false ? ' <span style="color:var(--accent-green);font-size:7px;">â˜…</span>' : ''}</div>
        <div class="agent-role">${a.role}</div>
        ${modelName ? `<div style="font-size:8px;color:var(--text-muted);font-family:var(--font-mono,monospace);margin-top:1px;">${modelName}</div>` : ''}
      </div>
    </button>
  `}).join('');
  el.querySelectorAll('.chat-agent-btn').forEach(btn => {
    btn.addEventListener('click', () => { state.activeChat = btn.dataset.id; renderChatAgentList(); renderChat(); });
  });
}

function renderChat() {
  const a = getAgent(state.activeChat);
  if (!a) return;
  $('#chat-header').innerHTML = `
    <img src="${getAvatarDataUrl(a.id, 3)}" class="pixel-art" style="width:30px;height:42px;">
    <span style="font-size:13px;color:${a.color};font-weight:700;letter-spacing:1px;">${a.name}</span>
    <span style="font-size:10px;color:var(--text-muted);margin-left:4px;">${a.role} Agent</span>
    <span style="font-size:8px;color:var(--text-muted);margin-left:6px;font-family:var(--font-mono,monospace);opacity:.6;">${_modelDisplayName(a.model)}</span>
    <span style="font-size:9px;color:var(--text-muted);margin-left:auto;">${a.personality||''}</span>
  `;
  const msgs = state.chatMessages[a.id] || [];
  const el = $('#chat-messages');
  el.innerHTML = msgs.map(m => `
    <div class="chat-bubble ${m.from}" style="${m.from==='agent'?'display:flex;gap:8px;align-items:flex-start;':''}">
      ${m.from==='agent'?`<img src="${getAvatarDataUrl(a.id, 2)}" class="pixel-art" style="width:20px;height:28px;flex-shrink:0;margin-top:2px;">`:''}
      <div>
        <div class="bubble-inner">${_esc(m.text)}</div>
        <div class="bubble-ts">${m.ts}</div>
      </div>
    </div>
  `).join('');
  el.scrollTop = el.scrollHeight;
  $('#chat-input').placeholder = `Message ${a.name}...`;
}

function sendChatMessage() {
  const input = $('#chat-input');
  const text = input.value.trim();
  if (!text) return;
  const agentId = state.activeChat;
  state.chatMessages[agentId].push({ from: 'user', text, ts: ts() });
  input.value = '';
  renderChat();

  _saveChatMessages();

  // If connected, send via Gateway WS
  if (state.connected && state.ws) {
    state.ws.send(JSON.stringify({
      type: 'message', agentId, text,
    }));
    // Show typing indicator until response arrives
    const typing = $('#chat-typing');
    typing.classList.add('show');
    // Auto-hide after 30s as a safety net
    setTimeout(() => typing.classList.remove('show'), 30000);
  } else {
    // Not connected â€” notify user
    const a = getAgent(agentId);
    state.chatMessages[agentId].push({ from: 'agent', text: `âš  Gateway not connected â€” message queued locally. Connect to ${state.gatewayUrl} to enable agent responses.`, ts: ts() });
    _saveChatMessages();
    renderChat();
  }
}

$('#chat-send').addEventListener('click', sendChatMessage);
$('#chat-input').addEventListener('keydown', e => { if (e.key === 'Enter') sendChatMessage(); });

// â”€â”€ RENDER: Calendar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderCalendar() {
  const grid = $('#cal-grid');
  const y = state.calViewYear;
  const m = state.calViewMonth;
  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  $('#cal-month-label').textContent = `${monthNames[m]} ${y}`;
  
  const weekDays = ['SUN','MON','TUE','WED','THU','FRI','SAT'];
  const daysInMonth = new Date(y, m + 1, 0).getDate();
  const firstDay = new Date(y, m, 1).getDay();
  const now = new Date();
  const todayStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
  const dateStr = d => `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;

  let html = weekDays.map(d => `<div class="cal-header-cell">${d}</div>`).join('');
  for (let i = 0; i < firstDay; i++) html += `<div class="cal-cell" style="background:var(--bg-deep);"></div>`;
  for (let d = 1; d <= daysInMonth; d++) {
    const ds = dateStr(d);
    const evs = state.calEvents.filter(e => e.date === ds);
    const sel = ds === state.selectedDate ? ' selected' : '';
    const isToday = ds === todayStr ? ' today' : '';
    html += `<div class="cal-cell${sel}${isToday}" data-date="${ds}">
      <div class="cal-day">${d}${ds===todayStr?' <span style="font-size:7px;opacity:.5">TODAY</span>':''}</div>
      ${evs.slice(0,3).map(ev => {
        const ag = getAgent(ev.agent);
        return `<div class="cal-event" style="border-color:${ag?.color||'var(--text-muted)'}">${ev.time} ${ev.title}</div>`;
      }).join('')}
      ${evs.length > 3 ? `<div style="font-size:8px;color:var(--text-muted);">+${evs.length-3} more</div>` : ''}
    </div>`;
  }
  grid.innerHTML = html;
  grid.querySelectorAll('.cal-cell[data-date]').forEach(cell => {
    cell.addEventListener('click', () => {
      state.selectedDate = cell.dataset.date;
      renderCalendar();
    });
  });
  renderCalDetail();
}

// Calendar navigation
document.addEventListener('click', e => {
  if (e.target.id === 'cal-prev') {
    state.calViewMonth--;
    if (state.calViewMonth < 0) { state.calViewMonth = 11; state.calViewYear--; }
    renderCalendar();
  }
  if (e.target.id === 'cal-next') {
    state.calViewMonth++;
    if (state.calViewMonth > 11) { state.calViewMonth = 0; state.calViewYear++; }
    renderCalendar();
  }
  if (e.target.id === 'cal-today-btn') {
    const now = new Date();
    state.calViewYear = now.getFullYear();
    state.calViewMonth = now.getMonth();
    state.selectedDate = now.toISOString().split('T')[0];
    renderCalendar();
  }
});

function renderCalDetail() {
  const d = new Date(state.selectedDate + 'T12:00:00');
  $('#cal-detail-date').textContent = d.toLocaleDateString('en-US', { weekday:'long', month:'long', day:'numeric' });
  const evs = state.calEvents.filter(e => e.date === state.selectedDate).sort((a,b) => a.time.localeCompare(b.time));
  const el = $('#cal-detail-events');
  if (!evs.length) {
    el.innerHTML = '<div style="font-size:11px;color:var(--text-muted);text-align:center;margin-top:40px;">No events</div>';
    return;
  }
  el.innerHTML = evs.map(ev => {
    const ag = getAgent(ev.agent);
    return `
      <div class="cal-detail-event" style="border-left:3px solid ${ag?.color||'var(--text-muted)'};">
        <button class="ev-delete" data-id="${ev.id}">âœ•</button>
        <div class="ev-title">${ev.title}</div>
        <div class="ev-meta">
          <span>${ev.time}</span>
          <span style="color:${ag?.color||'#fff'};">${ag?.name||ev.agent}</span>
          <span style="color:${typeColors[ev.type]||'var(--text-muted)'};text-transform:uppercase;">${ev.type}</span>
        </div>
      </div>
    `;
  }).join('');
  el.querySelectorAll('.ev-delete').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      state.calEvents = state.calEvents.filter(ev => ev.id !== +btn.dataset.id);
      _saveCalEvents();
      renderCalendar();
    });
  });
}

$('#cal-add-btn').addEventListener('click', () => {
  const sel = $('#ev-agent');
  sel.innerHTML = state.agents.map(a => `<option value="${a.id}">${a.name} (${a.role})</option>`).join('');
  $('#cal-modal').classList.add('open');
});

function addCalEvent() {
  const title = $('#ev-title').value.trim();
  if (!title) return;
  state.calEvents.push({
    id: Date.now(), title,
    date: state.selectedDate,
    time: $('#ev-time').value,
    agent: $('#ev-agent').value,
    type: $('#ev-type').value,
  });
  _saveCalEvents();
  $('#ev-title').value = '';
  $('#cal-modal').classList.remove('open');
  renderCalendar();
}

// â”€â”€ RENDER: Marketing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderMarketing() {
  // KPIs
  const totalSpend = state.campaigns.reduce((s,c) => s+c.spend, 0);
  const totalConv = state.campaigns.reduce((s,c) => s+c.conversions, 0);
  const activeCamps = state.campaigns.filter(c => c.status === 'active');
  const avgCtr = activeCamps.length > 0
    ? (activeCamps.reduce((s,c) => s + (parseFloat(c.ctr)||0), 0) / activeCamps.length).toFixed(1) + '%'
    : 'â€”';
  const topRoi = state.campaigns.length > 0
    ? state.campaigns.reduce((best, c) => {
        const rv = parseFloat(String(c.roi).replace(/[^0-9.\-]/g,'')) || 0;
        const bv = parseFloat(String(best.roi).replace(/[^0-9.\-]/g,'')) || 0;
        return rv > bv ? c : best;
      }, state.campaigns[0])
    : null;
  const topRoiStr = topRoi ? `${topRoi.roi}` : 'â€”';
  const topRoiName = topRoi ? topRoi.name : '';

  $('#mktg-kpis').innerHTML = [
    { l:'TOTAL SPEND', v:`$${totalSpend.toLocaleString()}`, s:activeCamps.length + ' active campaigns' },
    { l:'CONVERSIONS', v:totalConv.toLocaleString(), s:'total' },
    { l:'AVG CTR', v:avgCtr, s:'across active' },
    { l:'TOP ROI', v:topRoiStr, s:topRoiName },
  ].map(k => `
    <div class="card kpi-card">
      <div class="kpi-label">${k.l}</div>
      <div class="kpi-value">${k.v}</div>
      <div class="kpi-sub">${k.s}</div>
    </div>
  `).join('');

  // Campaign cards
  $('#campaign-cards').innerHTML = state.campaigns.map((c, i) => {
    const checked = (c.tasks||[]).filter((_,ti) => state.campaignTasks[`${c.id}-${ti}`]).length;
    const total = (c.tasks||[]).length;
    return `
      <div class="card campaign-card ${state.selectedCampaign===i?'selected':''}" data-idx="${i}">
        <div class="camp-header">
          <span class="camp-name">${c.name}</span>
          <span class="tag" style="color:${statusColors[c.status]};background:${statusColors[c.status]}12;">${c.status.toUpperCase()}</span>
        </div>
        <div style="font-size:9px;color:var(--text-muted);">${c.platform} Â· ${c.audience}</div>
        <div class="camp-metrics">
          <div><div class="metric-label">Budget</div><div class="metric-value">${c.budget}</div></div>
          <div><div class="metric-label">CTR</div><div class="metric-value">${c.ctr}</div></div>
          <div><div class="metric-label">ROI</div><div class="metric-value" style="color:${String(c.roi).includes('+')?'var(--accent-green)':'inherit'}">${c.roi}</div></div>
        </div>
        <div class="progress-bar"><div class="progress-fill" style="width:${total?((checked/total)*100):0}%"></div></div>
        <div style="display:flex;justify-content:space-between;margin-top:4px;font-size:8px;color:var(--text-muted);"><span>TASKS</span><span>${checked}/${total}</span></div>
      </div>
    `;
  }).join('');

  $$('.campaign-card').forEach(card => {
    card.addEventListener('click', () => {
      state.selectedCampaign = +card.dataset.idx;
      renderMarketing();
    });
  });

  // Show empty state when no campaigns
  if (state.campaigns.length === 0) {
    $('#campaign-cards').innerHTML = `
      <div style="grid-column:1/-1;text-align:center;padding:60px 20px;color:var(--text-muted);">
        <div style="font-size:28px;margin-bottom:8px;">â—Ž</div>
        <div style="font-size:12px;">No campaigns yet</div>
        <div style="font-size:10px;margin-top:4px;">Click + ADD CAMPAIGN to create one</div>
      </div>
    `;
  }

  renderCampaignDetail();
}

// Campaign add modal
document.addEventListener('click', e => {
  if (e.target.id === 'camp-add-btn') {
    $('#camp-m-name').value = '';
    $('#camp-m-budget').value = '';
    $('#camp-m-audience').value = '';
    $('#camp-m-status').value = 'draft';
    $('#camp-modal').classList.add('open');
  }
});

function addCampaignFromModal() {
  const name = $('#camp-m-name').value.trim();
  if (!name) return;
  window.__openclaw_cc.addCampaign({
    name,
    platform: $('#camp-m-platform').value,
    status: $('#camp-m-status').value,
    budget: $('#camp-m-budget').value || '$0',
    audience: $('#camp-m-audience').value || 'All',
    ctr: '0%',
    cpc: '$0',
    roi: '0%',
    impressions: '0',
    spend: 0,
    conversions: 0,
    tasks: [],
  });
  $('#camp-modal').classList.remove('open');
  state.selectedCampaign = state.campaigns.length - 1;
  renderMarketing();
}

function renderCampaignDetail() {
  const c = state.selectedCampaign !== null ? state.campaigns[state.selectedCampaign] : null;
  if (!c) {
    $('#mktg-detail-header').innerHTML = '<div class="label">CAMPAIGN DETAIL</div><div class="title">Select a campaign</div>';
    $('#mktg-detail-body').innerHTML = '';
    return;
  }
  $('#mktg-detail-header').innerHTML = `
    <div style="display:flex;align-items:center;gap:8px;">
      <div class="title" style="margin:0;">${c.name}</div>
      <span class="tag" style="color:${statusColors[c.status]};background:${statusColors[c.status]}12;">${c.status.toUpperCase()}</span>
    </div>
  `;
  const metrics = [
    ['Impressions',c.impressions],['CTR',c.ctr],['CPC',c.cpc],
    ['Conversions',c.conversions],['Spend',`$${c.spend.toLocaleString()}`],['ROI',c.roi],
  ];
  const details = [
    ['Platform',c.platform],['Audience',c.audience],['Budget',c.budget],
  ];
  $('#mktg-detail-body').innerHTML = `
    <div style="font-size:9px;color:var(--text-muted);letter-spacing:2px;margin-bottom:8px;">METRICS</div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:16px;">
      ${metrics.map(([l,v]) => `
        <div class="card" style="padding:8px;">
          <div style="font-size:8px;color:var(--text-muted);">${l}</div>
          <div style="font-size:14px;font-weight:600;color:${String(v).includes('+')?'var(--accent-green)':'var(--text-primary)'};">${v}</div>
        </div>
      `).join('')}
    </div>
    <div style="font-size:9px;color:var(--text-muted);letter-spacing:2px;margin-bottom:8px;">DETAILS</div>
    ${details.map(([l,v]) => `
      <div style="display:flex;justify-content:space-between;padding:5px 0;border-bottom:1px solid var(--border);">
        <span style="font-size:10px;color:var(--text-muted);">${l}</span>
        <span style="font-size:10px;color:var(--text-secondary);">${v}</span>
      </div>
    `).join('')}
    <div style="font-size:9px;color:var(--text-muted);letter-spacing:2px;margin:16px 0 8px;">ACTION ITEMS</div>
    ${(c.tasks||[]).map((t, ti) => {
      const done = state.campaignTasks[`${c.id}-${ti}`];
      return `
        <div class="task-item ${done?'done':''}" data-cid="${c.id}" data-ti="${ti}">
          <div class="checkbox ${done?'checked':''}"></div>
          <span class="task-text">${t}</span>
        </div>
      `;
    }).join('')}
  `;
  $$('#mktg-detail-body .task-item').forEach(item => {
    item.addEventListener('click', () => {
      const key = `${item.dataset.cid}-${item.dataset.ti}`;
      state.campaignTasks[key] = !state.campaignTasks[key];
      _saveCampaigns();
      renderMarketing();
    });
  });
}

// â”€â”€ RENDER: Tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTasks() {
  const cols = [
    { id:'todo', label:'TO DO', color:'var(--text-muted)' },
    { id:'in-progress', label:'IN PROGRESS', color:'var(--accent-blue)' },
    { id:'done', label:'DONE', color:'var(--accent-green)' },
  ];
  $('#board-columns').innerHTML = cols.map(col => {
    const items = state.tasks.filter(t => t.status === col.id);
    return `
      <div class="board-col">
        <div class="board-col-header">
          <div class="col-dot" style="background:${col.color};"></div>
          <span class="col-label">${col.label}</span>
          <span class="col-count">${items.length}</span>
        </div>
        <div class="board-col-body">
          ${items.map(task => {
            const ag = getAgent(task.agent);
            return `
              <div class="task-card">
                <div class="tc-title">${task.title}</div>
                <div class="tc-meta">
                  <img src="${getAvatarDataUrl(task.agent, 2)}" class="pixel-art" style="width:14px;height:20px;">
                  <span class="tag" style="color:${ag?.color||'#fff'};background:${ag?.color||'#fff'}12;">${ag?.name||task.agent}</span>
                  <span class="tag" style="color:${priColors[task.priority]};text-transform:uppercase;">${task.priority}</span>
                  <span style="font-size:8px;color:var(--text-muted);margin-left:auto;">${task.due}</span>
                </div>
                <div class="tc-actions">
                  ${col.id!=='todo'?`<button class="btn" data-id="${task.id}" data-action="back">â† BACK</button>`:''}
                  ${col.id!=='done'?`<button class="btn primary" data-id="${task.id}" data-action="next">NEXT â†’</button>`:''}
                  <button class="btn" data-id="${task.id}" data-action="del" style="color:var(--accent-red);border-color:rgba(255,82,82,.15);margin-left:auto;">DEL</button>
                </div>
              </div>
            `;
          }).join('')}
        </div>
      </div>
    `;
  }).join('');

  $$('.tc-actions .btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = +btn.dataset.id;
      const action = btn.dataset.action;
      if (action === 'del') {
        state.tasks = state.tasks.filter(t => t.id !== id);
        _saveTasks();
      } else {
        const task = state.tasks.find(t => t.id === id);
        if (!task) return;
        if (action === 'next') task.status = task.status === 'todo' ? 'in-progress' : 'done';
        if (action === 'back') task.status = task.status === 'done' ? 'in-progress' : 'todo';
        _saveTasks();
      }
      renderTasks();
    });
  });
}

$('#task-add-btn').addEventListener('click', () => {
  const sel = $('#new-task-agent');
  sel.innerHTML = state.agents.map(a => `<option value="${a.id}">${a.name}</option>`).join('');
  $('#task-modal').classList.add('open');
});

function addTask() {
  const title = $('#new-task-title').value.trim();
  if (!title) return;
  state.tasks.push({
    id: Date.now(), title,
    agent: $('#new-task-agent').value,
    priority: $('#new-task-priority').value,
    status: 'todo', due: 'TBD',
  });
  _saveTasks();
  $('#new-task-title').value = '';
  $('#task-modal').classList.remove('open');
  renderTasks();
}

// â”€â”€ RENDER: Cron Jobs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CRON_PRESETS = [
  { id:'every5m', label:'Every 5 min', expr:'*/5 * * * *', human:'Every 5 minutes' },
  { id:'every15m', label:'Every 15 min', expr:'*/15 * * * *', human:'Every 15 minutes' },
  { id:'every30m', label:'Every 30 min', expr:'*/30 * * * *', human:'Every 30 minutes' },
  { id:'hourly', label:'Hourly', expr:'0 * * * *', human:'Every hour on the hour' },
  { id:'daily', label:'Daily', expr:'0 9 * * *', human:'Daily at 9:00 AM' },
  { id:'weekdays', label:'Weekdays', expr:'0 9 * * 1-5', human:'Weekdays at 9:00 AM' },
  { id:'weekly', label:'Weekly', expr:'0 9 * * 1', human:'Every Monday at 9:00 AM' },
  { id:'monthly', label:'Monthly', expr:'0 9 1 * *', human:'1st of every month at 9:00 AM' },
  { id:'custom', label:'Custom', expr:'', human:'Custom schedule' },
];
const DAY_NAMES = ['Su','Mo','Tu','We','Th','Fr','Sa'];

function renderCron() {
  const active = state.cronJobs.filter(j => j.enabled).length;
  const paused = state.cronJobs.length - active;
  $('#cron-count').textContent = `${active} active Â· ${paused} paused Â· ${state.cronJobs.length} total`;

  const list = $('#cron-list');
  list.innerHTML = state.cronJobs.map(job => {
    const agents = (job.agents||[]).map(id => getAgent(id)).filter(Boolean);
    const human = _cronToHuman(job.schedule);
    return `
      <div class="cron-card ${job.enabled?'':'disabled'} ${job._expanded?'expanded':''}" data-id="${job.id}">
        <div class="cron-card-main">
          <div class="cron-toggle ${job.enabled?'on':''}" data-toggle="${job.id}">
            <div class="cron-toggle-knob"></div>
          </div>
          <div class="cron-info" style="cursor:pointer;" data-expand="${job.id}">
            <div class="cron-name">${job.name}</div>
            <div class="cron-agents-line">
              ${agents.map(a => `
                <span class="cron-agent-tag">
                  <span class="cron-agent-dot" style="background:${a.color};"></span>
                  ${a.name}
                </span>
              `).join('')}
            </div>
          </div>
          <div class="cron-schedule">
            <div class="cron-schedule-expr">${job.schedule}</div>
            <div class="cron-schedule-human">${human}</div>
          </div>
          <div class="cron-timing">
            <div class="cron-timing-row">
              <span class="cron-timing-label">Last run</span>
              <span class="cron-timing-val">${job.lastRun||'â€”'}</span>
            </div>
            <div class="cron-timing-row">
              <span class="cron-timing-label">Next run</span>
              <span class="cron-timing-val">${job.enabled?job.nextRun||'â€”':'paused'}</span>
            </div>
          </div>
          <div class="cron-actions">
            <button class="btn" data-edit="${job.id}" title="Edit">âœŽ</button>
            <button class="btn" data-run="${job.id}" title="Run now">â–¶</button>
            <button class="btn" data-del="${job.id}" title="Delete" style="color:var(--accent-red);border-color:rgba(255,82,82,.15);">âœ•</button>
          </div>
        </div>
        <div class="cron-message-row">
          <div class="msg-label">INSTRUCTIONS</div>
          <div class="cron-message-text">${job.message||'No instructions set.'}</div>
        </div>
        <div class="cron-stats-row">
          <div class="cron-stat">Runs: <strong>${job.runs||0}</strong></div>
          <div class="cron-stat">Errors: <strong style="color:${(job.errors||0)>0?'var(--accent-red)':'inherit'};">${job.errors||0}</strong></div>
          <div class="cron-stat">Created: <strong>${job.created||'â€”'}</strong></div>
        </div>
      </div>
    `;
  }).join('');

  // Bind toggle
  $$('.cron-toggle').forEach(el => {
    el.addEventListener('click', e => {
      e.stopPropagation();
      window.__openclaw_cc.toggleCronJob(+el.dataset.toggle);
    });
  });

  // Bind expand
  $$('[data-expand]').forEach(el => {
    el.addEventListener('click', () => {
      const id = +el.dataset.expand;
      const job = state.cronJobs.find(j => j.id === id);
      if (job) { job._expanded = !job._expanded; renderCron(); }
    });
  });

  // Bind edit
  $$('[data-edit]').forEach(btn => {
    btn.addEventListener('click', () => openCronModal(+btn.dataset.edit));
  });

  // Bind run now
  $$('[data-run]').forEach(btn => {
    btn.addEventListener('click', () => _runCronNow(+btn.dataset.run));
  });

  // Bind delete
  $$('[data-del]').forEach(btn => {
    btn.addEventListener('click', () => {
      window.__openclaw_cc.deleteCronJob(+btn.dataset.del);
    });
  });

  // Save to localStorage
  _saveCronJobs();
}

// â”€â”€ Cron expression to human-readable â”€â”€
function _cronToHuman(expr) {
  if (!expr) return 'No schedule';
  const preset = CRON_PRESETS.find(p => p.expr === expr);
  if (preset && preset.id !== 'custom') return preset.human;

  const parts = expr.split(' ');
  if (parts.length < 5) return expr;
  const [min, hr, dom, mon, dow] = parts;

  let text = '';
  if (min.startsWith('*/')) text = `Every ${min.slice(2)} min`;
  else if (hr === '*' && min !== '*') text = `Every hour at :${min.padStart(2,'0')}`;
  else if (hr !== '*' && min !== '*') {
    text = `At ${hr}:${min.padStart(2,'0')}`;
    if (dow === '1-5') text += ' weekdays';
    else if (dow === '0') text += ' Sundays';
    else if (dow === '1') text += ' Mondays';
    else if (dow !== '*') {
      const days = dow.split(',').map(d => DAY_NAMES[+d]||d).join(', ');
      text += ` on ${days}`;
    }
    if (dom !== '*') text += ` on day ${dom}`;
  } else {
    text = expr;
  }
  return text;
}

function _calcNextRun(job) {
  if (!job.enabled) return 'paused';
  const preset = CRON_PRESETS.find(p => p.expr === job.schedule);
  if (preset) {
    if (preset.id === 'every5m') return 'in ~5 min';
    if (preset.id === 'every15m') return 'in ~15 min';
    if (preset.id === 'every30m') return 'in ~30 min';
    if (preset.id === 'hourly') return 'next hour';
  }
  return job.customTime || 'scheduled';
}

// â”€â”€ Cron Modal â”€â”€
let _editingCronId = null;
let _cronModalState = { preset:'daily', selectedAgents:new Set(), customDays:new Set([1,2,3,4,5]) };

function openCronModal(editId) {
  const modal = $('#cron-modal');
  _editingCronId = editId || null;

  if (editId) {
    const job = state.cronJobs.find(j => j.id === editId);
    if (!job) return;
    $('#cron-modal-title').textContent = 'â± Edit Cron Job';
    $('#cron-m-name').value = job.name;
    $('#cron-m-message').value = job.message || '';
    $('#cron-m-expr').value = job.schedule || '';
    _cronModalState.selectedAgents = new Set(job.agents || []);
    _cronModalState.preset = job.preset || 'custom';
    _cronModalState.customDays = new Set(job.customDays || [1,2,3,4,5]);
    if (job.customTime) $('#cron-m-time').value = job.customTime;
  } else {
    $('#cron-modal-title').textContent = 'â± New Cron Job';
    $('#cron-m-name').value = '';
    $('#cron-m-message').value = '';
    $('#cron-m-expr').value = '0 9 * * *';
    _cronModalState.selectedAgents = new Set();
    _cronModalState.preset = 'daily';
    _cronModalState.customDays = new Set([1,2,3,4,5]);
    $('#cron-m-time').value = '09:00';
  }

  _renderCronModalAgents();
  _renderCronModalPresets();
  _renderCronModalDays();
  _updateCronExpr();
  modal.classList.add('open');
}

function closeCronModal() {
  $('#cron-modal').classList.remove('open');
  _editingCronId = null;
}

function _renderCronModalAgents() {
  $('#cron-m-agents').innerHTML = state.agents.map(a => `
    <button class="cron-agent-pick ${_cronModalState.selectedAgents.has(a.id)?'selected':''}" data-id="${a.id}">
      <span class="pick-dot" style="background:${a.color};"></span>
      ${a.name}
    </button>
  `).join('');
  $$('.cron-agent-pick').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.dataset.id;
      if (_cronModalState.selectedAgents.has(id)) _cronModalState.selectedAgents.delete(id);
      else _cronModalState.selectedAgents.add(id);
      _renderCronModalAgents();
    });
  });
}

function _renderCronModalPresets() {
  $('#cron-m-presets').innerHTML = CRON_PRESETS.map(p => `
    <button class="cron-preset ${_cronModalState.preset===p.id?'active':''}" data-pid="${p.id}">${p.label}</button>
  `).join('');
  $$('.cron-preset').forEach(btn => {
    btn.addEventListener('click', () => {
      _cronModalState.preset = btn.dataset.pid;
      _renderCronModalPresets();
      _updateCronExpr();
      // Show/hide custom area
      const custom = $('#cron-m-custom-area');
      custom.style.display = btn.dataset.pid === 'custom' ? 'block' : 'none';
    });
  });
  // Show custom area if needed
  $('#cron-m-custom-area').style.display = _cronModalState.preset === 'custom' ? 'block' : 'none';
}

function _renderCronModalDays() {
  $('#cron-m-days').innerHTML = DAY_NAMES.map((d, i) => `
    <button class="cron-day ${_cronModalState.customDays.has(i)?'active':''}" data-day="${i}">${d}</button>
  `).join('');
  $$('.cron-day').forEach(btn => {
    btn.addEventListener('click', () => {
      const day = +btn.dataset.day;
      if (_cronModalState.customDays.has(day)) _cronModalState.customDays.delete(day);
      else _cronModalState.customDays.add(day);
      _renderCronModalDays();
      _updateCronExpr();
    });
  });
}

function _updateCronExpr() {
  const preset = CRON_PRESETS.find(p => p.id === _cronModalState.preset);
  let expr = '';

  if (preset && preset.id !== 'custom') {
    expr = preset.expr;
    // Replace time in daily/weekdays/weekly/monthly presets
    if (['daily','weekdays','weekly','monthly'].includes(preset.id)) {
      const time = $('#cron-m-time')?.value || '09:00';
      const [h, m] = time.split(':');
      expr = expr.replace(/^0 9/, `${parseInt(m)} ${parseInt(h)}`);
    }
  } else {
    // Custom: build from selections
    const time = $('#cron-m-time')?.value || '09:00';
    const [h, m] = time.split(':');
    const days = [..._cronModalState.customDays].sort();

    const interval = parseInt($('#cron-m-interval')?.value || '1');
    const unit = $('#cron-m-interval-unit')?.value || 'days';

    if (unit === 'minutes' && interval > 1) {
      expr = `*/${interval} * * * *`;
    } else if (unit === 'hours' && interval > 1) {
      expr = `0 */${interval} * * *`;
    } else if (days.length === 7 || days.length === 0) {
      expr = `${parseInt(m)} ${parseInt(h)} * * *`;
    } else {
      expr = `${parseInt(m)} ${parseInt(h)} * * ${days.join(',')}`;
    }
  }

  $('#cron-m-expr').value = expr;
  $('#cron-m-expr-hint').textContent = _cronToHuman(expr);
}

function saveCronJob() {
  const name = $('#cron-m-name').value.trim();
  if (!name) { $('#cron-m-name').focus(); return; }
  if (_cronModalState.selectedAgents.size === 0) return;

  const expr = $('#cron-m-expr').value.trim();
  const message = $('#cron-m-message').value.trim();
  const time = $('#cron-m-time')?.value || '';

  const jobData = {
    name,
    agents: [..._cronModalState.selectedAgents],
    schedule: expr,
    preset: _cronModalState.preset,
    customTime: time,
    customDays: [..._cronModalState.customDays],
    message,
  };

  if (_editingCronId) {
    window.__openclaw_cc.updateCronJob(_editingCronId, jobData);
  } else {
    window.__openclaw_cc.addCronJob(jobData);
  }

  closeCronModal();
}

// â”€â”€ Run cron job immediately â”€â”€
function _runCronNow(jobId) {
  const job = state.cronJobs.find(j => j.id === jobId);
  if (!job) return;

  // Push to each assigned agent via Gateway
  if (state.connected && state.ws) {
    (job.agents || []).forEach(agentId => {
      state.ws.send(JSON.stringify({
        type: 'message',
        agentId,
        text: `[CRON: ${job.name}] ${job.message}`,
        system: true,
        cronJobId: job.id,
      }));
    });
    job.lastRun = ts();
    job.runs = (job.runs || 0) + 1;
    renderCron();
    // Flash feedback
    const hint = $('#cron-count');
    const orig = hint.textContent;
    hint.textContent = `â–¶ ${job.name} dispatched to ${job.agents.length} agent(s)`;
    hint.style.color = 'var(--accent-green)';
    setTimeout(() => { hint.style.color = ''; renderCron(); }, 2000);
  } else {
    // Not connected â€” log for later
    const hint = $('#cron-count');
    hint.textContent = 'âš  Not connected to Gateway â€” cannot dispatch';
    hint.style.color = 'var(--accent-yellow)';
    setTimeout(() => { hint.style.color = ''; renderCron(); }, 2000);
  }
}

// â”€â”€ Sync cron job config to Gateway â”€â”€
function _syncCronToGateway(job) {
  if (!state.connected || !state.ws) return;
  state.ws.send(JSON.stringify({
    type: 'cron_update',
    job: {
      id: job.id,
      name: job.name,
      agents: job.agents,
      schedule: job.schedule,
      message: job.message,
      enabled: job.enabled,
    },
  }));
}

// Bind add button and modal events
$('#cron-add-btn')?.addEventListener('click', () => openCronModal());
$('#cron-modal')?.addEventListener('click', e => {
  if (e.target.id === 'cron-modal') closeCronModal();
});
// Update expression on input changes
$('#cron-m-time')?.addEventListener('change', _updateCronExpr);
$('#cron-m-interval')?.addEventListener('input', _updateCronExpr);
$('#cron-m-interval-unit')?.addEventListener('change', _updateCronExpr);
// Allow manual cron expression editing
$('#cron-m-expr')?.addEventListener('input', () => {
  _cronModalState.preset = 'custom';
  _renderCronModalPresets();
  const expr = $('#cron-m-expr').value;
  $('#cron-m-expr-hint').textContent = _cronToHuman(expr);
});

// Restore from localStorage
(function() {
  try {
    const saved = JSON.parse(localStorage.getItem('oc_cronJobs'));
    if (saved && Array.isArray(saved)) state.cronJobs = saved;
  } catch(e) {}
  try {
    const saved = JSON.parse(localStorage.getItem('oc_activityLog'));
    if (saved && Array.isArray(saved)) state.activityLog = saved;
  } catch(e) {}

  // Restore tasks
  try { const s = JSON.parse(localStorage.getItem('oc_tasks')); if (s && Array.isArray(s)) state.tasks = s; } catch(e) {}
  // Restore calendar events
  try { const s = JSON.parse(localStorage.getItem('oc_calEvents')); if (s && Array.isArray(s)) state.calEvents = s; } catch(e) {}
  // Restore campaigns
  try { const s = JSON.parse(localStorage.getItem('oc_campaigns')); if (s && Array.isArray(s)) state.campaigns = s; } catch(e) {}
  try { const s = JSON.parse(localStorage.getItem('oc_campaignTasks')); if (s && typeof s === 'object') state.campaignTasks = s; } catch(e) {}
  // Restore chat messages
  try { const s = JSON.parse(localStorage.getItem('oc_chatMessages')); if (s && typeof s === 'object') state.chatMessages = s; } catch(e) {}
  // Restore avatar configs
  try { const s = JSON.parse(localStorage.getItem('oc_avatarConfigs')); if (s && typeof s === 'object') state.avatarConfigs = s; } catch(e) {}
  // Restore agent status
  try { const s = JSON.parse(localStorage.getItem('oc_agentStatus')); if (s && typeof s === 'object') state.agentStatus = s; } catch(e) {}
  // Restore meeting history
  try { const s = JSON.parse(localStorage.getItem('oc_meetingHistory')); if (s && Array.isArray(s)) state.meeting.history = s; } catch(e) {}
  // Restore RC data
  try { const s = JSON.parse(localStorage.getItem('oc_rc')); if (s && typeof s === 'object') { Object.assign(state.rc, s); } } catch(e) {}
})();

// â”€â”€ RENDER: Agent Logs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LOG_TYPES = [
  { id:'task', label:'Task', color:'var(--accent-blue)', icon:'â˜°' },
  { id:'cron', label:'Cron', color:'var(--accent-yellow)', icon:'â±' },
  { id:'comms', label:'Comms', color:'var(--accent-green)', icon:'â—‡' },
  { id:'system', label:'System', color:'var(--text-muted)', icon:'âš™' },
  { id:'error', label:'Error', color:'var(--accent-red)', icon:'âš ' },
];

function renderLogs() {
  // Agent sidebar
  const agentList = $('#logs-agent-list');
  if (!agentList) return;

  const countByAgent = {};
  state.activityLog.forEach(l => {
    if (!countByAgent[l.agent]) countByAgent[l.agent] = 0;
    countByAgent[l.agent]++;
  });

  agentList.innerHTML = `
    <button class="log-agent-btn ${state.logSelectedAgent==='all'?'active':''}" data-la="all">
      <div class="la-avatar" style="background:var(--text-muted);">âœ±</div>
      <div class="la-info">
        <div class="la-name">All Agents</div>
        <div class="la-role">Unified feed</div>
      </div>
      <span class="la-count">${state.activityLog.length}</span>
    </button>
    ${state.agents.map(a => `
      <button class="log-agent-btn ${state.logSelectedAgent===a.id?'active':''}" data-la="${a.id}">
        <div class="la-avatar" style="background:${a.color};">${a.name.charAt(0)}</div>
        <div class="la-info">
          <div class="la-name">${a.name}</div>
          <div class="la-role">${a.role}</div>
        </div>
        <span class="la-count">${countByAgent[a.id]||0}</span>
      </button>
    `).join('')}
  `;

  $$('.log-agent-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      state.logSelectedAgent = btn.dataset.la;
      renderLogs();
    });
  });

  // Filter chips
  const filters = $('#logs-filters');
  filters.innerHTML = LOG_TYPES.map(t => `
    <button class="log-filter-chip ${state.logActiveFilters.has(t.id)?'active':''}" data-lf="${t.id}">
      <span class="chip-dot" style="background:${t.color};"></span>
      ${t.label}
    </button>
  `).join('') + `
    <button class="log-filter-chip" data-lf="_clear" style="color:var(--accent-red);border-color:rgba(255,69,58,.15);">Clear log</button>
  `;

  $$('.log-filter-chip').forEach(chip => {
    chip.addEventListener('click', () => {
      const f = chip.dataset.lf;
      if (f === '_clear') {
        if (state.logSelectedAgent === 'all') {
          state.activityLog = [];
        } else {
          state.activityLog = state.activityLog.filter(l => l.agent !== state.logSelectedAgent);
        }
        _saveActivityLog();
        renderLogs();
        return;
      }
      if (state.logActiveFilters.has(f)) state.logActiveFilters.delete(f);
      else state.logActiveFilters.add(f);
      renderLogs();
    });
  });

  // Filter entries
  let entries = [...state.activityLog];
  if (state.logSelectedAgent !== 'all') {
    entries = entries.filter(l => l.agent === state.logSelectedAgent);
  }
  entries = entries.filter(l => state.logActiveFilters.has(l.type));

  // Meta
  $('#logs-meta').textContent = `${entries.length} entries`;

  // Feed
  const feed = $('#logs-feed');
  if (entries.length === 0) {
    const agent = state.logSelectedAgent === 'all' ? null : getAgent(state.logSelectedAgent);
    feed.innerHTML = `
      <div class="log-empty">
        <div class="log-empty-icon">â–¤</div>
        <div class="log-empty-text">${agent ? `No activity from ${agent.name}` : 'No activity recorded'}</div>
        <div class="log-empty-sub">Agent actions will appear here as they work</div>
      </div>
    `;
    return;
  }

  feed.innerHTML = entries.map(entry => {
    const agent = getAgent(entry.agent);
    const d = new Date(entry.ts);
    const time = d.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
    const date = d.toLocaleDateString([], { month:'short', day:'numeric' });
    const typeInfo = LOG_TYPES.find(t => t.id === entry.type) || LOG_TYPES[3];

    return `
      <div class="log-entry" data-logid="${entry.id}">
        <div class="log-time-col">
          <span class="log-time">${time}</span>
          <span class="log-date">${date}</span>
        </div>
        <div class="log-body-col">
          <div class="log-head">
            <span class="log-type-badge ${entry.type}">${typeInfo.icon} ${typeInfo.label}</span>
            ${agent ? `<span class="log-agent-badge"><span class="lab-dot" style="background:${agent.color};"></span>${agent.name}</span>` : ''}
            ${entry.detail ? `<span class="log-expand-hint" data-toggle-log="${entry.id}">details â–¾</span>` : ''}
          </div>
          <div class="log-desc">${_esc(entry.desc || '')}</div>
          ${entry.detail ? `<div class="log-detail">${_esc(entry.detail)}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');

  // Expand/collapse
  $$('[data-toggle-log]').forEach(el => {
    el.addEventListener('click', () => {
      const row = el.closest('.log-entry');
      row.classList.toggle('expanded');
      el.textContent = row.classList.contains('expanded') ? 'details â–´' : 'details â–¾';
    });
  });

  // Save
  _saveActivityLog();
}

// â”€â”€ Auto-Logging Hooks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Instrument existing API calls to produce log entries
function _autoLog(type, agent, desc, detail) {
  state.activityLog.unshift({
    id: Date.now() + Math.random(),
    ts: new Date().toISOString(),
    type, agent, desc, detail: detail || null,
  });
  if (state.activityLog.length > 500) state.activityLog.length = 500;
  // Debounced render â€” don't re-render on every rapid mutation
  clearTimeout(_autoLog._t);
  _autoLog._t = setTimeout(() => renderLogs(), 200);
}
_autoLog._t = null;

// Wrap existing API methods to auto-log
(function _instrumentAPIs() {
  const api = window.__openclaw_cc;

  // Tasks
  const _origAddTask = api.addTask.bind(api);
  api.addTask = function(task) {
    const r = _origAddTask(task);
    if (r.ok) _autoLog('task', task.agent, `Created task: ${task.title}`, `Priority: ${task.priority||'medium'} Â· Status: ${task.status||'todo'}`);
    return r;
  };

  const _origMoveTask = api.moveTask.bind(api);
  api.moveTask = function(id, status) {
    const task = state.tasks.find(t => t.id === id);
    const r = _origMoveTask(id, status);
    if (r.ok && task) _autoLog('task', task.agent, `Moved "${task.title}" â†’ ${status}`);
    return r;
  };

  const _origDeleteTask = api.deleteTask.bind(api);
  api.deleteTask = function(id) {
    const task = state.tasks.find(t => t.id === id);
    const r = _origDeleteTask(id);
    if (r.ok && task) _autoLog('task', task.agent, `Deleted task: ${task.title}`);
    return r;
  };

  // Cron
  const _origAddCron = api.addCronJob.bind(api);
  api.addCronJob = function(job) {
    const r = _origAddCron(job);
    if (r.ok) _autoLog('cron', (job.agents||[])[0]||state.agents[0]?.id||'system', `Cron job created: ${job.name}`, `Schedule: ${job.schedule} Â· Agents: ${(job.agents||[]).join(', ')}`);
    return r;
  };

  const _origToggleCron = api.toggleCronJob.bind(api);
  api.toggleCronJob = function(id) {
    const r = _origToggleCron(id);
    const job = state.cronJobs.find(j => j.id === id);
    if (r.ok && job) _autoLog('cron', (job.agents||[])[0]||state.agents[0]?.id||'system', `${job.enabled?'Enabled':'Paused'} cron: ${job.name}`);
    return r;
  };

  const _origLogCronRun = api.logCronRun.bind(api);
  api.logCronRun = function(id, success, err) {
    const job = state.cronJobs.find(j => j.id === id);
    const r = _origLogCronRun(id, success, err);
    if (r.ok && job) {
      if (success) {
        _autoLog('cron', (job.agents||[])[0]||state.agents[0]?.id||'system', `Cron completed: ${job.name}`, `Run #${job.runs}`);
      } else {
        _autoLog('error', (job.agents||[])[0]||state.agents[0]?.id||'system', `Cron failed: ${job.name}`, err || 'Unknown error');
      }
    }
    return r;
  };

  // Comms
  const _origPushComms = api.pushComms.bind(api);
  api.pushComms = function(msg) {
    const r = _origPushComms(msg);
    if (r.ok) _autoLog('comms', msg.from, `Sent message to ${msg.to==='all'?'all agents':msg.to.toUpperCase()}`, msg.text);
    else if (r.error) _autoLog('error', msg.from, `Blocked comms: ${r.error}`, `Attempted: ${msg.from} â†’ ${msg.to}`);
    return r;
  };

  // Routing
  const _origAddConn = api.addConnection.bind(api);
  api.addConnection = function(from, fp, to, tp) {
    const r = _origAddConn(from, fp, to, tp);
    if (r.ok) _autoLog('system', from, `Connection added: ${from.toUpperCase()} â†’ ${to.toUpperCase()}`, `${fp} â†’ ${tp}`);
    return r;
  };

  const _origRemoveConn = api.removeConnection.bind(api);
  api.removeConnection = function(id) {
    const conn = state.orgConnections.find(c => c.id === id);
    const r = _origRemoveConn(id);
    if (r.ok && conn) _autoLog('system', conn.from, `Connection removed: ${conn.from.toUpperCase()} â†’ ${conn.to.toUpperCase()}`);
    return r;
  };
})();

// â”€â”€ RENDER: System Prompts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PROMPT_SECTIONS = [
  {
    id: 'identity',
    icon: 'â—†',
    title: 'Identity',
    hint: 'Agent name, ID, and core identity. This is the opening line of the system prompt.',
    placeholder: 'You are [AGENT_NAME], the [Role] agent for the OpenClaw multi-agent system.',
  },
  {
    id: 'role',
    icon: 'â—Ž',
    title: 'Role & Capabilities',
    hint: 'What this agent does, what domains it covers, and what it specializes in.',
    placeholder: 'You specialize in digital marketing strategy, ad campaign management...',
  },
  {
    id: 'tools',
    icon: 'âš™',
    title: 'Tools & Integrations',
    hint: 'Available tools, APIs, canvas.eval methods, and integration details.',
    placeholder: 'You have access to the following tools:\n- canvas.eval: Push updates to Command Center\n- agent-send: Communicate with connected agents\n- web-search: Research competitors and trends',
  },
  {
    id: 'routing',
    icon: 'â—ˆ',
    title: 'Routing Rules',
    hint: 'Auto-generated from the Org Structure node graph. Edit connections there to update.',
    placeholder: '',
    auto: true,
  },
  {
    id: 'personality',
    icon: 'â™Ÿ',
    title: 'Personality & Style',
    hint: 'Communication tone, response format preferences, and behavioral guidelines.',
    placeholder: 'You communicate in a direct, data-driven style. Lead with metrics...',
  },
  {
    id: 'instructions',
    icon: 'â–¸',
    title: 'Custom Instructions',
    hint: 'Additional rules, constraints, output format requirements, or project-specific context.',
    placeholder: '- Always include source links when citing data\n- Format reports in markdown\n- Escalate security concerns immediately to the ops lead',
  },
];

function _getDefaultPrompt(agentId) {
  const a = getAgent(agentId);
  if (!a) return {};
  const isAdmin = a.admin !== false;

  // Base tools available to all agents
  let tools = `Available tools and integrations:

1. canvas.eval â€” Push updates to Command Center dashboard
   window.__openclaw_cc.addTask({title, agent:"${a.id}", priority, status})
   window.__openclaw_cc.logActivity({type, agent:"${a.id}", desc, detail})
   window.__openclaw_cc.pushComms({from:"${a.id}", to:"<agent_id>", text:"..."})

2. agent-send â€” Direct message to connected agents
   Only contact agents in your routing list.

3. Task management:
   .addTask() .moveTask(id,"status") .updateTask(id,{}) .deleteTask(id) .getTasks({agent,status,priority})

4. API Vault â€” Retrieve secrets and API keys
   vault("SERVICE.FIELD", "${a.id}") â†’ returns value or null
   vault("SERVICE", "${a.id}") â†’ returns all fields as {KEY: value}
   Use .listSecrets("${a.id}") to see which keys you can access.`;

  // Admin agents get the full API surface
  if (isAdmin) {
    tools += `

5. Calendar management (ADMIN):
   .addCalEvent({title, date:"YYYY-MM-DD", time:"HH:MM", agent:"${a.id}", type:"meeting|deadline|review|launch"})
   .updateCalEvent(id, {}) .deleteCalEvent(id) .getCalEvents({date, agent, type}) .clearCalEvents({})

6. Campaign management (ADMIN):
   .addCampaign({name, platform, status, budget, audience, ctr, cpc, roi, impressions, spend, conversions, tasks:[]})
   .updateCampaign(id, {}) .deleteCampaign(id) .getCampaigns({status})
   .addCampaignTask(campId, "task text") .toggleCampaignTask(campId, idx)

7. RevenueCat analytics (ADMIN):
   .rcGetMetrics() â€” full metrics snapshot (MRR, revenue, subscribers, churn, products, transactions, funnel)
   .rcUpdateMetrics({mrr, revenue, activeSubscribers, ...}) .rcPushTransaction({event, product, amount, user, country})
   .rcUpdateProduct(id, {subscribers, revenue, trial}) .rcAppendMrr(timeframe, value)
   .rcAddApp({id, name, icon}) .rcRemoveApp(id) .rcSelectApp(id) .rcSetTimeframe(tf)

8. Meeting / Briefing Room (ADMIN):
   .startMeetingProgrammatic({topic, participants:["id1","id2"], type:"strategy|standup|review|incident|brainstorm|planning"})
   .meetingMessage({agent:"${a.id}", text:"...", type:"message|action-item|decision|question"})
   .addActionItem({agent:"${a.id}", text:"..."}) .endMeetingProgrammatic()
   .getMeetingState() .getMeetingHistory()

9. Cron job management (ADMIN):
   .addCronJob({name, schedule:"*/5 * * * *", agents:["id"], message:"..."}) .updateCronJob(id, {}) .deleteCronJob(id)
   .toggleCronJob(id) .getCronJobs({agent, enabled})

10. Agent management (ADMIN):
    .getAgents() â€” list all agents with roles, skills, admin status
    .setAgentStatus(id, "idle|working|error|offline") .getAgentStatus(id)
    .notify({agent:"${a.id}", text:"...", level:"info|warn|error|success"})

11. Activity log (ADMIN):
    .logActivity({type:"task|cron|comms|system|error", agent:"${a.id}", desc:"...", detail:"..."})
    .getActivityLog({agent, type, since}) .clearActivityLog({})`;
  }

  const identity = `You are ${a.name}, the ${a.role} agent in the OpenClaw multi-agent system.
Agent ID: ${a.id}
Model: ${a.model || 'not specified'}
Access level: ${isAdmin ? 'ADMIN â€” full dashboard visibility and control' : 'WORKER â€” task execution scope'}`;

  const role = `You specialize in ${a.role.toLowerCase()}.

Core skills: ${(a.skills||[]).join(', ')}

You operate as part of a coordinated team of AI agents managed through the OpenClaw Command Center. Your actions, tasks, and communications are visible on the dashboard.${isAdmin ? '\n\nAs an ADMIN agent, you have full visibility into all dashboard views: tasks, calendar, campaigns, analytics, meetings, cron jobs, and agent logs. You can read and write data across all systems.' : '\n\nAs a WORKER agent, you focus on executing assigned tasks and communicating through your routing connections. Escalate cross-system needs to admin agents.'}`;

  const instructions = isAdmin
    ? `- You have full dashboard awareness â€” proactively monitor tasks, calendar, campaigns, and metrics
- Report all significant actions to the Command Center activity log
- Use pushComms() for inter-agent communication
- Update task status as you work through items
- You can start and manage briefing meetings with other admin agents
- Monitor cron jobs and activity logs for anomalies
- When asked about system status, query live data via getTasks(), getCalEvents(), rcGetMetrics(), etc.
- Coordinate worker agents through routing connections`
    : `- Report all significant actions to the Command Center activity log
- Use pushComms() for inter-agent communication
- Update task status as you work through items
- Escalate blockers and cross-system requests to admin agents via your upstream connections`;

  return {
    identity,
    role,
    tools,
    routing: '', // auto-populated by _compilePrompt
    personality: a.personality || 'Professional, efficient, and collaborative.',
    instructions,
  };
}

// Generate live dashboard context snapshot for admin agents
function _generateDashboardContext(agentId) {
  const a = getAgent(agentId);
  if (!a || a.admin === false) return '';

  const api = window.__openclaw_cc;
  let ctx = '';

  // Team roster
  const agents = api.getAgents();
  ctx += 'TEAM ROSTER:\n';
  agents.forEach(ag => {
    const status = state.agentStatus[ag.id] || 'idle';
    const level = ag.admin !== false ? 'ADMIN' : 'WORKER';
    ctx += `  ${ag.name} [${ag.id}] â€” ${ag.role} Â· ${level} Â· Status: ${status}\n`;
  });

  // Active tasks summary
  const tasks = api.getTasks();
  if (tasks.length > 0) {
    const todo = tasks.filter(t => t.status === 'todo').length;
    const inProg = tasks.filter(t => t.status === 'in-progress').length;
    const done = tasks.filter(t => t.status === 'done').length;
    ctx += `\nTASK BOARD: ${tasks.length} total (${todo} todo, ${inProg} in-progress, ${done} done)\n`;
    // Show in-progress tasks
    const active = tasks.filter(t => t.status === 'in-progress').slice(0, 5);
    if (active.length > 0) {
      ctx += '  Active:\n';
      active.forEach(t => {
        const ag = getAgent(t.agent);
        ctx += `    Â· ${t.title} [${ag?.name || t.agent}] priority:${t.priority || 'medium'}\n`;
      });
    }
    // Show overdue/pending todo tasks
    const pending = tasks.filter(t => t.status === 'todo').slice(0, 5);
    if (pending.length > 0) {
      ctx += '  Pending:\n';
      pending.forEach(t => {
        const ag = getAgent(t.agent);
        ctx += `    Â· ${t.title} [${ag?.name || t.agent}] priority:${t.priority || 'medium'}\n`;
      });
    }
  } else {
    ctx += '\nTASK BOARD: Empty\n';
  }

  // Upcoming calendar events (next 7 days)
  const today = new Date();
  const weekOut = new Date(today);
  weekOut.setDate(weekOut.getDate() + 7);
  const dateStr = d => d.toISOString().split('T')[0];
  const upcoming = state.calEvents
    .filter(e => e.date >= dateStr(today) && e.date <= dateStr(weekOut))
    .sort((a, b) => (a.date + a.time).localeCompare(b.date + b.time))
    .slice(0, 8);
  if (upcoming.length > 0) {
    ctx += '\nCALENDAR (next 7 days):\n';
    upcoming.forEach(ev => {
      const ag = getAgent(ev.agent);
      ctx += `  ${ev.date} ${ev.time} â€” ${ev.title} [${ag?.name || ev.agent}] (${ev.type})\n`;
    });
  } else {
    ctx += '\nCALENDAR: No upcoming events\n';
  }

  // Campaign summary
  if (state.campaigns.length > 0) {
    ctx += `\nCAMPAIGNS: ${state.campaigns.length} total\n`;
    state.campaigns.slice(0, 5).forEach(c => {
      ctx += `  ${c.name} â€” ${c.status.toUpperCase()} Â· ${c.platform || ''} Â· Budget: ${c.budget || '$0'} Â· ROI: ${c.roi || 'â€”'}\n`;
    });
  }

  // RC analytics snapshot (if apps configured)
  if (state.rc.apps.length > 0) {
    const d = _getRcData();
    ctx += `\nREVENUECAT: ${state.rc.apps.map(a => a.name).join(', ')}\n`;
    ctx += `  MRR: $${(d.mrr || 0).toLocaleString(undefined,{minimumFractionDigits:2})} (${d.mrrChange >= 0 ? '+' : ''}${d.mrrChange || 0}%)\n`;
    ctx += `  Subscribers: ${(d.activeSubscribers || 0).toLocaleString()} Â· Trials: ${(d.activeTrial || 0).toLocaleString()} Â· Churn: ${d.churnRate || 0}%\n`;
    ctx += `  Revenue: $${(d.revenue || 0).toLocaleString(undefined,{minimumFractionDigits:2})} Â· LTV: $${(d.ltv || 0).toFixed(2)}\n`;
  }

  // Cron jobs summary
  if (state.cronJobs.length > 0) {
    const enabled = state.cronJobs.filter(j => j.enabled).length;
    ctx += `\nCRON JOBS: ${state.cronJobs.length} total (${enabled} enabled)\n`;
    state.cronJobs.filter(j => j.enabled).slice(0, 5).forEach(j => {
      ctx += `  ${j.name} â€” ${j.schedule} Â· Runs: ${j.runs || 0} Â· Last: ${j.lastRun || 'never'}\n`;
    });
  }

  // Recent activity (last 5 entries)
  if (state.activityLog.length > 0) {
    ctx += '\nRECENT ACTIVITY:\n';
    state.activityLog.slice(0, 5).forEach(l => {
      const ag = getAgent(l.agent);
      const time = new Date(l.ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      ctx += `  ${time} [${l.type}] ${ag?.name || l.agent}: ${l.desc}\n`;
    });
  }

  return ctx;
}

function _compilePrompt(agentId, sections) {
  const a = getAgent(agentId);
  const isAdmin = a && a.admin !== false;
  let out = '';

  // Identity
  if (sections.identity) out += sections.identity + '\n\n';

  // Role
  if (sections.role) {
    out += `<role>\n${sections.role}\n</role>\n\n`;
  }

  // Tools
  if (sections.tools) {
    out += `<tools>\n${sections.tools}\n</tools>\n\n`;
  }

  // Routing â€” always auto-generate from live connections
  const routing = _generateRoutingBlock(agentId);
  out += `<routing_rules>\n${routing}\n</routing_rules>\n\n`;

  // Vault access â€” list available secrets for this agent
  const vaultKeys = window.__openclaw_cc.listSecrets(agentId);
  if (vaultKeys.length > 0) {
    let vblock = 'Your available API keys and secrets:\n';
    vaultKeys.forEach(s => {
      const fields = (s.fieldKeys||[]).map(k => `${s.envKey}.${k}`).join(', ');
      vblock += `  ${s.name}: ${fields || s.envKey}\n`;
    });
    vblock += `\nAccess via: vault("KEY.FIELD", "${agentId}")`;
    out += `<vault_access>\n${vblock}\n</vault_access>\n\n`;
  }

  // ADMIN ONLY: Dashboard context â€” live state snapshot
  if (isAdmin) {
    const dashCtx = _generateDashboardContext(agentId);
    if (dashCtx) {
      out += `<dashboard_context>\nLive system state as of ${ts()}:\n\n${dashCtx}\n</dashboard_context>\n\n`;
    }
  }

  // Personality
  if (sections.personality) {
    out += `<personality>\n${sections.personality}\n</personality>\n\n`;
  }

  // Custom
  if (sections.instructions) {
    out += `<instructions>\n${sections.instructions}\n</instructions>\n`;
  }

  return out;
}

function _generateRoutingBlock(agentId) {
  const r = window.__openclaw_cc.generateRoutingConfig(agentId);
  if (!r.ok) return 'No routing data available.';

  const allowedIds = r.connected.map(c => c.id);
  let block = `ALLOWED CONTACTS: ${allowedIds.length === 0 ? 'NONE' : allowedIds.join(', ')}\n`;
  if (r.upstream.length) block += `Reports to: ${r.upstream.map(u => `${u.name} [${u.id}] â€” ${u.role}`).join(', ')}\n`;
  if (r.downstream.length) block += `Manages: ${r.downstream.map(d => `${d.name} [${d.id}] â€” ${d.role}`).join(', ')}\n`;
  if (r.lateral.length) block += `Peers: ${r.lateral.map(l => `${l.name} [${l.id}] â€” ${l.role}`).join(', ')}\n`;
  block += `\nRULES:\n`;
  block += `1. ONLY use agent-send for: ${allowedIds.join(', ') || 'nobody'}\n`;
  block += `2. To reach unconnected agents, relay through your connections.\n`;
  block += `3. Log all comms to dashboard via pushComms().\n`;
  block += `4. Verify connections live: __openclaw_cc.getConnectedAgents("${agentId}")`;
  return block;
}

function renderPrompts() {
  const agentList = $('#sp-agent-list');
  if (!agentList) return;

  // Sidebar
  agentList.innerHTML = state.agents.map(a => {
    const hasCustom = !!state.agentPrompts[a.id];
    const isAdmin = a.admin !== false;
    return `
      <button class="sp-agent-btn ${state.promptSelectedAgent===a.id?'active':''}" data-spa="${a.id}">
        <div class="spa-avatar" style="background:${a.color};">${a.name.charAt(0)}</div>
        <div class="spa-info">
          <div class="spa-name">${a.name}</div>
          <div class="spa-role">${a.role}${isAdmin ? ' <span style="color:var(--accent-green);font-size:7px;font-weight:700;">â˜… ADMIN</span>' : ' <span style="color:var(--text-muted);font-size:7px;">WORKER</span>'}</div>
        </div>
        <span class="spa-status" style="background:${hasCustom?'var(--accent-green)':'var(--text-muted)'};opacity:${hasCustom?1:.3};" title="${hasCustom?'Custom prompt':'Default prompt'}"></span>
      </button>
    `;
  }).join('');

  $$('.sp-agent-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      state.promptSelectedAgent = btn.dataset.spa;
      renderPrompts();
    });
  });

  const agentId = state.promptSelectedAgent;
  const agent = getAgent(agentId);
  if (!agent) return;

  // Ensure prompt exists
  if (!state.agentPrompts[agentId]) {
    state.agentPrompts[agentId] = _getDefaultPrompt(agentId);
  }
  const prompt = state.agentPrompts[agentId];

  // Header
  $('#sp-agent-info').innerHTML = `
    <div class="spa-avatar" style="background:${agent.color};width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:15px;font-weight:700;color:#fff;">${agent.name.charAt(0)}</div>
    <div>
      <div class="sp-info-name">${agent.name}</div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:2px;">
        <span class="sp-info-role">${agent.role}</span>
        <span class="sp-info-id">${agent.id}</span>
        <span style="font-size:8px;font-weight:700;letter-spacing:.5px;padding:1px 6px;border-radius:3px;
          background:${agent.admin !== false ? 'rgba(52,199,89,.12)' : 'rgba(142,142,147,.1)'};
          color:${agent.admin !== false ? 'var(--accent-green)' : 'var(--text-muted)'};">
          ${agent.admin !== false ? 'â˜… ADMIN' : 'WORKER'}
        </span>
      </div>
    </div>
  `;

  // Sections
  const sections = $('#sp-sections');
  sections.innerHTML = PROMPT_SECTIONS.map(sec => {
    const val = sec.id === 'routing' ? _generateRoutingBlock(agentId) : (prompt[sec.id] || '');
    const charCount = val.length;
    const isAuto = sec.auto;

    return `
      <div class="sp-section" data-sec="${sec.id}">
        <div class="sp-section-header" data-toggle-sec="${sec.id}">
          <span class="sp-section-chevron">â–¸</span>
          <span class="sp-section-icon">${sec.icon}</span>
          <span class="sp-section-title">${sec.title}</span>
          ${isAuto ? `<span class="sp-routing-auto"><span class="sp-routing-dot"></span>Auto-synced from node graph</span>` : ''}
          <span class="sp-section-badge">${charCount} chars</span>
        </div>
        <div class="sp-section-body">
          <div class="sp-section-hint">${sec.hint}</div>
          <textarea
            class="sp-textarea ${isAuto?'readonly':''}"
            data-field="${sec.id}"
            placeholder="${sec.placeholder}"
            ${isAuto?'readonly':''}
            spellcheck="false"
          >${val}</textarea>
          <div class="sp-token-bar">
            <span>${isAuto ? 'Managed by Org Structure â€” edit connections to change' : 'Edit directly Â· Changes are local until you save'}</span>
            <span class="sp-char-count" data-count="${sec.id}">${charCount} chars</span>
          </div>
        </div>
      </div>
    `;
  }).join('');

  // Section toggle â€” click header to expand/collapse
  $$('[data-toggle-sec]').forEach(el => {
    el.addEventListener('click', () => {
      const sec = el.closest('.sp-section');
      const wasOpen = sec.classList.contains('open');
      sec.classList.toggle('open');
      if (!wasOpen) {
        // Double rAF ensures display:block has painted before measuring
        requestAnimationFrame(() => requestAnimationFrame(() => {
          const ta = sec.querySelector('.sp-textarea');
          if (ta) _autoSizeTA(ta);
        }));
      }
    });
  });

  // Live editing â€” auto-resize on every keystroke
  $$('.sp-textarea:not(.readonly)').forEach(ta => {
    ta.addEventListener('input', () => {
      const field = ta.dataset.field;
      prompt[field] = ta.value;
      const counter = $(`[data-count="${field}"]`);
      if (counter) counter.textContent = `${ta.value.length} chars`;
      const badge = ta.closest('.sp-section').querySelector('.sp-section-badge');
      if (badge) badge.textContent = `${ta.value.length} chars`;
      _autoSizeTA(ta);
      _markPromptDirty();
    });

    // Tab inserts 2 spaces
    ta.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = ta.selectionStart;
        ta.value = ta.value.substring(0, start) + '  ' + ta.value.substring(ta.selectionEnd);
        ta.selectionStart = ta.selectionEnd = start + 2;
        ta.dispatchEvent(new Event('input'));
      }
    });
  });

  // Also set rows attribute as fallback sizing
  $$('.sp-textarea').forEach(ta => {
    const lines = (ta.value || '').split('\n').length;
    ta.setAttribute('rows', Math.max(2, lines));
  });
}

function _autoSizeTA(ta) {
  // field-sizing:content handles this in modern browsers; JS fallback for others
  ta.style.height = 'auto';
  ta.style.height = ta.scrollHeight + 2 + 'px';
}

let _promptDirty = false;

function _markPromptDirty() {
  _promptDirty = true;
  const status = $('#sp-save-status');
  if (status) {
    status.textContent = 'â— unsaved';
    status.style.color = 'var(--accent-yellow)';
  }
}

function _markPromptSaved() {
  _promptDirty = false;
  const status = $('#sp-save-status');
  if (status) {
    status.textContent = 'âœ“ saved';
    status.style.color = 'var(--accent-green)';
    setTimeout(() => { if (!_promptDirty && status) { status.textContent = ''; } }, 3000);
  }
}

// Save & Push
$('#sp-save-btn')?.addEventListener('click', () => {
  const agentId = state.promptSelectedAgent;
  _saveAgentPrompts();
  window.__openclaw_cc.pushPrompt(agentId);
  _markPromptSaved();
});

// Copy All
$('#sp-copy-btn')?.addEventListener('click', () => {
  const agentId = state.promptSelectedAgent;
  const prompt = state.agentPrompts[agentId] || _getDefaultPrompt(agentId);
  const compiled = _compilePrompt(agentId, prompt);
  navigator.clipboard.writeText(compiled).then(() => {
    const btn = $('#sp-copy-btn');
    btn.textContent = 'âœ“ Copied';
    setTimeout(() => { btn.textContent = 'âŽ˜ Copy All'; }, 2000);
  });
});

// Revert
$('#sp-revert-btn')?.addEventListener('click', () => {
  const agentId = state.promptSelectedAgent;
  state.agentPrompts[agentId] = _getDefaultPrompt(agentId);
  _saveAgentPrompts();
  _promptDirty = false;
  const status = $('#sp-save-status');
  if (status) { status.textContent = 'â†© reverted'; status.style.color = 'var(--text-muted)'; }
  setTimeout(() => { if (status) status.textContent = ''; }, 2000);
  renderPrompts();
});

// Restore from localStorage
(function() {
  try {
    const saved = JSON.parse(localStorage.getItem('oc_agentPrompts'));
    if (saved && typeof saved === 'object') state.agentPrompts = saved;
  } catch(e) {}
  try {
    const saved = JSON.parse(localStorage.getItem('oc_vault'));
    if (saved && Array.isArray(saved)) {
      // Migrate old single-value format â†’ multi-field
      saved.forEach(s => {
        if (!s.fields && s.value) {
          s.fields = [{ label:'Value', key:'VALUE', value: s.value }];
          delete s.value;
        }
      });
      state.vault = saved;
    }
  } catch(e) {}
})();

function _saveVault() {
  _safeSave('oc_vault', state.vault);
  _syncVaultToGateway();
}

function _syncVaultToGateway() {
  if (!state.connected || !state.ws) return;
  // Send sanitized vault manifest (keys + allow lists, no values)
  // Gateway can then request specific values on behalf of agents
  const manifest = state.vault.map(s => ({
    id: s.id, name: s.name, envKey: s.envKey,
    fieldKeys: (s.fields||[]).map(f => f.key),
    allowList: s.allowList,
  }));
  state.ws.send(JSON.stringify({
    type: 'vault_manifest',
    manifest,
    timestamp: Date.now(),
  }));
}

// Agent-facing vault helper â€” clean interface for canvas.eval
// Usage: vault("FIREBASE.PRIVATE_KEY", "forge") â†’ returns the value string or null
window.vault = function(keyPath, agentId) {
  const result = window.__openclaw_cc.getSecret(keyPath, agentId);
  if (result.ok && result.value) return result.value;
  if (result.ok && result.fields) return result.fields;
  return null;
};

// Gateway can request actual secret values for authorized agents
// This handles inbound WebSocket messages from Gateway
function _handleVaultRequest(msg) {
  // msg: { type:'vault_request', envKey:'FIREBASE.PRIVATE_KEY', agentId:'forge', requestId:'...' }
  const result = window.__openclaw_cc.getSecret(msg.envKey, msg.agentId);
  if (state.ws) {
    state.ws.send(JSON.stringify({
      type: 'vault_response',
      requestId: msg.requestId,
      ...result,
    }));
  }
  if (result.ok) {
    _autoLog('system', msg.agentId, `Vault access: ${msg.envKey}`, `Granted`);
  } else {
    _autoLog('error', msg.agentId || state.agents[0]?.id || 'system', `Vault access denied: ${msg.envKey}`, result.error);
  }
}

// â”€â”€ RENDER: API Vault â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const VAULT_ICONS = {
  'api': 'âš¿', 'token': 'â—ˆ', 'key': 'âš¿', 'webhook': 'â¤º', 'secret': 'â—†',
  'database': 'â–¤', 'oauth': 'â—‡', 'default': 'âš¿',
};

function _vaultIcon(name) {
  const lower = (name || '').toLowerCase();
  for (const [k,v] of Object.entries(VAULT_ICONS)) {
    if (lower.includes(k)) return v;
  }
  return VAULT_ICONS.default;
}

function _maskValue(val) {
  if (!val) return 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
  if (val.length <= 8) return 'â€¢'.repeat(val.length);
  return val.substring(0, 4) + 'â€¢'.repeat(Math.min(20, val.length - 8)) + val.substring(val.length - 4);
}

function renderVault() {
  const list = $('#vault-list');
  if (!list) return;

  $('#vault-count').textContent = `${state.vault.length} secret${state.vault.length!==1?'s':''}`;

  if (state.vault.length === 0) {
    list.innerHTML = `
      <div class="vault-empty">
        <div class="vault-empty-icon">âš¿</div>
        <div class="vault-empty-text">No secrets stored</div>
        <div class="vault-empty-sub">Add API keys, tokens, and credentials for your agents</div>
      </div>
    `;
    return;
  }

  list.innerHTML = state.vault.map(s => {
    const icon = _vaultIcon(s.name);
    const dateStr = new Date(s.created).toLocaleDateString([], { month:'short', day:'numeric', year:'numeric' });
    const allowCount = s.allowList?.length || 0;
    const totalAgents = state.agents.length;
    // Normalize: support legacy single-value or new multi-field
    const fields = s.fields || [{ label:'Value', key:'VALUE', value: s.value || '' }];
    const fieldCount = fields.length;

    return `
      <div class="vault-card" data-vid="${s.id}">
        <div class="vault-card-head" data-vault-toggle="${s.id}">
          <div class="vault-card-icon">${icon}</div>
          <div class="vault-card-info">
            <div class="vault-card-name">
              ${s.name}
              <span class="vault-card-env">${s.envKey}</span>
            </div>
            <div class="vault-card-meta">
              <span>${fieldCount} field${fieldCount!==1?'s':''}</span>
              <span>${allowCount}/${totalAgents} agents</span>
              <span>Added ${dateStr}</span>
              ${s.note ? `<span>${s.note}</span>` : ''}
            </div>
          </div>
          <div class="vault-card-actions">
            <button class="vault-act-btn" data-vault-copy="${s.id}" title="Copy all fields">âŽ˜</button>
            <button class="vault-act-btn" data-vault-edit="${s.id}" title="Edit">âœŽ</button>
            <button class="vault-act-btn danger" data-vault-del="${s.id}" title="Delete">âœ•</button>
          </div>
        </div>
        <div class="vault-card-body">
          <div class="vault-fields-list">
            ${fields.map((f, i) => `
              <div class="vault-field-row" data-fid="${s.id}:${i}">
                <div class="vault-field-label">
                  <span class="vfl-key">${f.label || f.key}</span>
                  <span class="vfl-envkey">${s.envKey}.${f.key}</span>
                </div>
                <div class="vault-value-row">
                  <div class="vault-value-display masked" data-vault-fval="${s.id}:${i}">${_maskValue(f.value)}</div>
                  <button class="vault-value-toggle" data-vault-freveal="${s.id}:${i}">Reveal</button>
                  <button class="vault-act-btn" data-vault-fcopy="${s.id}:${i}" title="Copy">âŽ˜</button>
                </div>
              </div>
            `).join('')}
          </div>
          <div class="vault-allow-label" style="margin-top:14px;">Agent Access (${allowCount}/${totalAgents})</div>
          <div class="vault-agent-grid">
            ${state.agents.map(a => {
              const allowed = s.allowList?.includes(a.id);
              return `<button class="vault-agent-chip ${allowed?'allowed':''}" data-vault-agent="${s.id}:${a.id}">
                <span class="vac-dot" style="background:${a.color};"></span>
                ${a.name}
                ${allowed ? '<span class="vac-check">âœ“</span>' : ''}
              </button>`;
            }).join('')}
          </div>
        </div>
      </div>
    `;
  }).join('');

  // Toggle expand
  $$('[data-vault-toggle]').forEach(el => {
    el.addEventListener('click', e => {
      if (e.target.closest('.vault-act-btn')) return;
      el.closest('.vault-card').classList.toggle('open');
    });
  });

  // Reveal/hide per field
  $$('[data-vault-freveal]').forEach(btn => {
    btn.addEventListener('click', () => {
      const [secId, idx] = btn.dataset.vaultFreveal.split(':');
      const s = state.vault.find(v => v.id === secId);
      const fields = s?.fields || [{ value: s?.value || '' }];
      const f = fields[parseInt(idx)];
      const disp = $(`[data-vault-fval="${secId}:${idx}"]`);
      if (!f || !disp) return;
      const isRevealed = !disp.classList.contains('masked');
      if (isRevealed) {
        disp.textContent = _maskValue(f.value);
        disp.classList.add('masked');
        btn.textContent = 'Reveal';
      } else {
        disp.textContent = f.value;
        disp.classList.remove('masked');
        btn.textContent = 'Hide';
      }
    });
  });

  // Copy individual field
  $$('[data-vault-fcopy]').forEach(btn => {
    btn.addEventListener('click', () => {
      const [secId, idx] = btn.dataset.vaultFcopy.split(':');
      const s = state.vault.find(v => v.id === secId);
      const fields = s?.fields || [{ value: s?.value || '' }];
      const f = fields[parseInt(idx)];
      if (!f) return;
      navigator.clipboard.writeText(f.value).then(() => {
        btn.textContent = 'âœ“';
        setTimeout(() => { btn.textContent = 'âŽ˜'; }, 1500);
      });
    });
  });

  // Copy all fields
  $$('[data-vault-copy]').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      const s = state.vault.find(v => v.id === btn.dataset.vaultCopy);
      if (!s) return;
      const fields = s.fields || [{ label:'Value', key:'VALUE', value: s.value || '' }];
      const text = fields.map(f => `${f.label || f.key}: ${f.value}`).join('\n');
      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'âœ“';
        setTimeout(() => { btn.textContent = 'âŽ˜'; }, 1500);
      });
    });
  });

  // Delete
  $$('[data-vault-del]').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      window.__openclaw_cc.deleteSecret(btn.dataset.vaultDel);
    });
  });

  // Edit
  $$('[data-vault-edit]').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      _openVaultModal(btn.dataset.vaultEdit);
    });
  });

  // Agent allow-list toggles
  $$('[data-vault-agent]').forEach(chip => {
    chip.addEventListener('click', () => {
      const [secId, agentId] = chip.dataset.vaultAgent.split(':');
      const s = state.vault.find(v => v.id === secId);
      if (!s) return;
      if (s.allowList.includes(agentId)) {
        s.allowList = s.allowList.filter(a => a !== agentId);
      } else {
        s.allowList.push(agentId);
      }
      _saveVault();
      renderVault();
    });
  });
}

// â”€â”€ Vault Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _openVaultModal(editId) {
  const existing = editId ? state.vault.find(v => v.id === editId) : null;
  const isEdit = !!existing;
  // Normalize existing fields
  const existingFields = existing?.fields || (existing?.value ? [{ label:'Value', key:'VALUE', value: existing.value }] : []);

  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay open';
  overlay.innerHTML = `
    <div class="modal" style="max-width:540px;">
      <h3>${isEdit ? 'âœŽ Edit Secret' : '+ Add Secret'}</h3>
      <div class="vault-field">
        <label>Service Name</label>
        <input type="text" id="vm-name" placeholder="e.g. RevenueCat, Firebase, AWS" value="${existing?.name||''}">
      </div>
      <div class="vault-field">
        <label>Base Key</label>
        <input type="text" id="vm-env" placeholder="e.g. REVENUECAT" value="${existing?.envKey||''}" style="text-transform:uppercase;">
        <div class="vault-hint">Agents use BASE_KEY.FIELD_KEY to look up values (e.g. REVENUECAT.API_KEY)</div>
      </div>
      <div class="vault-field">
        <label>Fields</label>
        <div id="vm-fields"></div>
        <button class="btn" id="vm-add-field" type="button" style="margin-top:8px;font-size:11px;">+ Add Field</button>
      </div>
      <div class="vault-field">
        <label>Note (optional)</label>
        <input type="text" id="vm-note" placeholder="e.g. Production keys, expires Dec 2026" value="${existing?.note||''}">
      </div>
      <div class="modal-actions">
        <button class="btn" id="vm-cancel">CANCEL</button>
        <button class="btn primary" id="vm-save">${isEdit ? 'UPDATE' : 'ADD SECRET'}</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  // Field rows
  const fieldsContainer = overlay.querySelector('#vm-fields');
  let fieldRows = existingFields.length ? [...existingFields] : [{ label:'', key:'', value:'' }];

  function renderFieldRows() {
    fieldsContainer.innerHTML = fieldRows.map((f, i) => `
      <div class="vm-field-row" style="display:grid;grid-template-columns:1fr 1fr auto;gap:6px;margin-bottom:6px;align-items:start;">
        <div>
          ${i === 0 ? '<div style="font-size:9px;color:var(--text-muted);margin-bottom:3px;">LABEL</div>' : ''}
          <input type="text" class="vm-flabel" data-fi="${i}" placeholder="e.g. API Key" value="${f.label||''}" style="font-size:11px;padding:8px 10px;">
        </div>
        <div>
          ${i === 0 ? '<div style="font-size:9px;color:var(--text-muted);margin-bottom:3px;">VALUE</div>' : ''}
          <input type="text" class="vm-fval" data-fi="${i}" placeholder="sk-live-abc123..." value="${f.value||''}" style="font-family:var(--font-mono,monospace);font-size:11px;padding:8px 10px;">
        </div>
        <div style="${i === 0 ? 'margin-top:16px;' : ''}">
          <button class="vault-act-btn danger vm-fdel" data-fi="${i}" title="Remove field" style="width:32px;height:32px;${fieldRows.length <= 1 ? 'opacity:.3;pointer-events:none;' : ''}">âœ•</button>
        </div>
      </div>
    `).join('');

    // Auto-generate key from label
    fieldsContainer.querySelectorAll('.vm-flabel').forEach(inp => {
      inp.addEventListener('input', () => {
        const idx = parseInt(inp.dataset.fi);
        fieldRows[idx].label = inp.value;
        fieldRows[idx].key = inp.value.toUpperCase().replace(/[^A-Z0-9]+/g, '_').replace(/_+$/,'');
      });
    });
    fieldsContainer.querySelectorAll('.vm-fval').forEach(inp => {
      inp.addEventListener('input', () => {
        fieldRows[parseInt(inp.dataset.fi)].value = inp.value;
      });
    });
    fieldsContainer.querySelectorAll('.vm-fdel').forEach(btn => {
      btn.addEventListener('click', () => {
        if (fieldRows.length <= 1) return;
        fieldRows.splice(parseInt(btn.dataset.fi), 1);
        renderFieldRows();
      });
    });
  }
  renderFieldRows();

  overlay.querySelector('#vm-add-field').addEventListener('click', () => {
    fieldRows.push({ label:'', key:'', value:'' });
    renderFieldRows();
    // Focus the new label
    const labels = fieldsContainer.querySelectorAll('.vm-flabel');
    labels[labels.length - 1]?.focus();
  });

  // Auto-generate env key from name
  const nameInput = overlay.querySelector('#vm-name');
  const envInput = overlay.querySelector('#vm-env');
  if (!isEdit) {
    nameInput.addEventListener('input', () => {
      if (!envInput._manual) {
        envInput.value = nameInput.value.toUpperCase().replace(/[^A-Z0-9]+/g, '_').replace(/_+$/,'');
      }
    });
    envInput.addEventListener('input', () => { envInput._manual = true; });
  }

  overlay.querySelector('#vm-cancel').addEventListener('click', () => overlay.remove());
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });

  overlay.querySelector('#vm-save').addEventListener('click', () => {
    const name = overlay.querySelector('#vm-name').value.trim();
    const envKey = overlay.querySelector('#vm-env').value.trim().toUpperCase().replace(/[^A-Z0-9_]/g, '');
    const note = overlay.querySelector('#vm-note').value.trim();
    // Collect fields â€” filter out empty ones
    const fields = fieldRows
      .filter(f => f.label?.trim() && f.value?.trim())
      .map(f => ({
        label: f.label.trim(),
        key: f.key || f.label.toUpperCase().replace(/[^A-Z0-9]+/g, '_').replace(/_+$/,''),
        value: f.value,
      }));
    if (!name || !envKey || fields.length === 0) return;

    if (isEdit) {
      window.__openclaw_cc.updateSecret(editId, { name, envKey, fields, note });
    } else {
      window.__openclaw_cc.addSecret({ name, envKey, fields, note });
    }
    overlay.remove();
  });

  overlay.querySelector('#vm-name').focus();
}

// Add button
$('#vault-add-btn')?.addEventListener('click', () => _openVaultModal());

// â”€â”€ RENDER: Analytics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Helper to get current app data (merges overrides)
function _getRcData() {
  const appOverride = state.rc.appData?.[state.rc.selectedApp];
  if (appOverride) return { ...state.rc, ...appOverride };
  return state.rc;
}

function renderAnalytics() {
  const d = _getRcData();

  // App selector + Add button
  $('#rc-app-selector').innerHTML = state.rc.apps.map(app => `
    <button class="rc-app-btn ${state.rc.selectedApp===app.id?'active':''}" data-app="${app.id}">
      <span class="app-icon">${app.icon}</span>
      <span>${app.name}</span>
    </button>
  `).join('') + `<button class="rc-app-btn" id="rc-add-app-btn" style="border-style:dashed;color:var(--accent-green);"><span class="app-icon">+</span><span>Add App</span></button>`;
  $$('.rc-app-btn[data-app]').forEach(btn => {
    btn.addEventListener('click', () => { state.rc.selectedApp = btn.dataset.app; _saveRcData(); renderAnalytics(); });
  });
  $('#rc-add-app-btn')?.addEventListener('click', () => {
    const name = prompt('App name (e.g. Bourbon Closet):');
    if (!name) return;
    const icon = prompt('Icon emoji:', 'ðŸ“±') || 'ðŸ“±';
    const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '_');
    window.__openclaw_cc.rcAddApp({ id, name, icon });
  });

  // Empty state
  if (state.rc.apps.length === 0) {
    $('#rc-kpis').innerHTML = '';
    $('#rc-mrr-display').textContent = '$0.00';
    $('#rc-chart').innerHTML = '<div style="text-align:center;padding:40px;color:var(--text-muted);font-size:11px;">Add an app to start tracking revenue</div>';
    $('#rc-products').innerHTML = '';
    $('#rc-funnel').innerHTML = '';
    $('#rc-status').innerHTML = '';
    $('#rc-feed').innerHTML = '';
    return;
  }

  // Timeframe
  const tfs = ['7d','30d','90d'];
  $('#rc-timeframe').innerHTML = tfs.map(tf => `
    <button class="btn ${state.rc.timeframe===tf?'primary':''}" data-tf="${tf}">${tf.toUpperCase()}</button>
  `).join('');
  $$('#rc-timeframe .btn').forEach(btn => {
    btn.addEventListener('click', () => { state.rc.timeframe = btn.dataset.tf; renderAnalytics(); });
  });

  // KPIs
  const kpis = [
    { label:'MRR', value:`$${d.mrr.toLocaleString(undefined,{minimumFractionDigits:2})}`, change:d.mrrChange, up:d.mrrChange>=0 },
    { label:'ACTIVE SUBSCRIBERS', value:d.activeSubscribers.toLocaleString(), change:d.subscribersChange, up:d.subscribersChange>=0 },
    { label:'ACTIVE TRIALS', value:d.activeTrial.toLocaleString(), change:d.trialChange, up:d.trialChange>=0 },
    { label:'REVENUE', value:`$${d.revenue.toLocaleString(undefined,{minimumFractionDigits:2})}`, change:d.revenueChange, up:d.revenueChange>=0 },
    { label:'LTV', value:`$${d.ltv.toFixed(2)}`, change:d.ltvChange, up:d.ltvChange>=0 },
    { label:'CHURN RATE', value:`${d.churnRate}%`, change:d.churnChange, up:d.churnChange<=0 },
  ];
  $('#rc-kpis').innerHTML = kpis.map(k => `
    <div class="rc-kpi">
      <div class="kpi-label">${k.label}</div>
      <div class="kpi-value">${k.value}</div>
      <div class="kpi-change ${k.up?'up':'down'}">${k.change>=0?'+':''}${k.change}%</div>
    </div>
  `).join('');

  // MRR Chart
  const hist = d.mrrHistory?.[state.rc.timeframe] || d.mrrHistory?.['7d'] || [];
  const maxMrr = Math.max(...hist, 1);
  $('#rc-mrr-display').textContent = `$${d.mrr.toLocaleString(undefined,{minimumFractionDigits:2})}`;
  $('#rc-chart').innerHTML = hist.map((v,i) => `
    <div class="rc-bar" style="height:${Math.max(2,(v/maxMrr)*150)}px;">
      <div class="rc-bar-tip">$${v.toLocaleString()}</div>
    </div>
  `).join('');

  // Products table
  const products = d.products || state.rc.products;
  const maxSubs = Math.max(...products.map(p => p.subscribers), 1);
  $('#rc-products').innerHTML = `
    <div class="rc-product-row header">
      <div>PRODUCT</div><div>PRICE</div><div>SUBS</div><div>REVENUE</div><div>TRIALS</div>
    </div>
    ${products.map(p => `
      <div class="rc-product-row">
        <div class="rc-product-name"><span class="rc-product-dot" style="background:${p.color};"></span>${p.name}</div>
        <div class="val">${p.price}</div>
        <div class="val">${p.subscribers}</div>
        <div class="val money">$${p.revenue.toLocaleString(undefined,{minimumFractionDigits:2})}</div>
        <div class="val">${p.trial}</div>
      </div>
    `).join('')}
  `;

  // Conversion funnel
  const funnel = d.funnel || state.rc.funnel;
  const fStages = [
    { label:'Installs', value:funnel.installs },
    { label:'Paywall Views', value:funnel.paywallViews },
    { label:'Trial Starts', value:funnel.trialStarts },
    { label:'Conversions', value:funnel.conversions },
  ];
  const fMax = Math.max(...fStages.map(s => s.value), 1);
  $('#rc-funnel').innerHTML = `
    <div style="display:flex;gap:12px;align-items:flex-end;height:120px;">
      ${fStages.map((s, i) => {
        const pct = i > 0 ? ((s.value / fStages[i-1].value) * 100).toFixed(1) : '100';
        const opacity = 0.3 + (i / fStages.length) * 0.7;
        return `
          <div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:4px;">
            <div style="font-size:14px;font-weight:700;color:var(--text-primary);">${s.value.toLocaleString()}</div>
            <div style="width:100%;height:${(s.value/fMax)*90}px;border-radius:4px 4px 0 0;background:var(--accent-blue);opacity:${opacity};transition:height .5s;"></div>
            <div style="font-size:9px;color:var(--text-muted);font-weight:500;text-align:center;">${s.label}</div>
            ${i > 0 ? `<div style="font-size:10px;color:var(--accent-blue);font-weight:600;">${pct}%</div>` : '<div style="height:16px;"></div>'}
          </div>
        `;
      }).join('')}
    </div>
  `;

  // Subscriber status
  const ss = d.subscriberStatus || state.rc.subscriberStatus;
  const statusItems = [
    { label:'Active', value:ss.active, color:'var(--accent-green)' },
    { label:'Trial', value:ss.trial, color:'var(--accent-blue)' },
    { label:'Grace Period', value:ss.grace, color:'var(--accent-yellow)' },
    { label:'Billing Retry', value:ss.billing_retry, color:'var(--accent-orange)' },
    { label:'Expired', value:ss.expired, color:'var(--text-muted)' },
    { label:'Cancelled', value:ss.cancelled, color:'var(--accent-red)' },
  ];
  $('#rc-status').innerHTML = statusItems.map(s => `
    <div class="rc-status-row">
      <div class="rc-status-label"><span class="rc-status-dot" style="background:${s.color};"></span>${s.label}</div>
      <div class="rc-status-val">${s.value}</div>
    </div>
  `).join('');

  // Transaction feed
  const txs = d.transactions || state.rc.transactions;
  const txIcons = { renewal:'ðŸ”„', trial_start:'ðŸ†“', initial_purchase:'ðŸ’³', cancellation:'âŒ', trial_converted:'âœ…', refund:'â†©ï¸', upgrade:'â¬†ï¸' };
  const txLabels = { renewal:'Renewal', trial_start:'Trial Started', initial_purchase:'New Purchase', cancellation:'Cancelled', trial_converted:'Trial Converted', refund:'Refund', upgrade:'Upgrade' };
  $('#rc-feed').innerHTML = `<div class="rc-feed-scroll">${txs.slice(0,15).map(tx => `
    <div class="rc-tx">
      <div class="rc-tx-row">
        <div class="rc-tx-icon">${txIcons[tx.event]||'ðŸ“‹'}</div>
        <div class="rc-tx-info">
          <div class="rc-tx-event">${txLabels[tx.event]||tx.event}</div>
          <div class="rc-tx-product">${tx.product} Â· ${tx.user} Â· ${tx.country}</div>
        </div>
        <div>
          <div class="rc-tx-amount ${tx.amount>0?'positive':tx.amount<0?'negative':'neutral'}">${tx.amount>0?'+':''}${tx.amount!==0?'$'+Math.abs(tx.amount).toFixed(2):'â€”'}</div>
          <div class="rc-tx-time">${tx.time}</div>
        </div>
      </div>
    </div>
  `).join('')}</div>`;
}

// â”€â”€ RENDER: Briefing Room â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBriefing() {
  renderBriefingSeats();
  renderBriefingTranscript();
  renderBriefingControls();
}

function renderBriefingSeats() {
  const el = $('#br-seats');
  if (!el) return;
  const cx = 50, cy = 48, rx = 32, ry = 28;
  const agents = state.agents.filter(a => a.admin !== false);
  const n = agents.length;
  const speakingAgent = _getMeetingSpeaker();

  el.innerHTML = agents.map((a, i) => {
    const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
    const x = cx + rx * Math.cos(angle);
    const y = cy + ry * Math.sin(angle);
    const isParticipant = state.meeting.participants.includes(a.id);
    const isSpeaking = speakingAgent === a.id;
    const isThinking = _meetingThinking === a.id;
    const statusClass = !state.meeting.active ? '' :
      isSpeaking ? 'speaking' : isThinking ? 'thinking' :
      isParticipant ? '' : 'idle';
    const avatarUrl = getAvatarDataUrl(a.id, 4);

    return `
      <div class="br-seat ${statusClass}" style="left:${x}%;top:${y}%;transform:translate(-50%,-50%);">
        <div class="seat-avatar" style="border-color:${isSpeaking ? a.color : 'transparent'};">
          <div class="speaking-ring" style="border-color:${a.color};"></div>
          <img src="${avatarUrl}" class="pixel-art" alt="${a.name}" style="width:48px;height:68px;">
        </div>
        <div class="seat-name" style="color:${a.color};">${a.name}</div>
        <div class="seat-role">${a.role}</div>
        ${state.meeting.active ? `<div class="seat-status" style="color:${
          isSpeaking ? a.color : isThinking ? 'var(--accent-yellow)' : 'var(--text-muted)'
        };">${isSpeaking ? 'SPEAKING' : isThinking ? 'THINKING...' : isParticipant ? 'LISTENING' : 'IDLE'}</div>` : ''}
      </div>
    `;
  }).join('');
}

function renderBriefingTranscript() {
  const el = $('#br-transcript-scroll');
  if (!el) return;

  if (state.meeting.messages.length === 0) {
    el.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:12px;">
        <div style="font-size:28px;">â¬¡</div>
        <div style="font-size:11px;color:var(--text-muted);text-align:center;line-height:1.6;">
          Start a meeting to see agents<br>discuss autonomously in real-time.
        </div>
      </div>
    `;
    return;
  }

  el.innerHTML = state.meeting.messages.map(m => {
    if (m.type === 'system') {
      return `<div class="br-msg system-msg"><div class="br-msg-body">â€” ${_esc(m.text)} â€”</div></div>`;
    }
    const ag = getAgent(m.agent);
    const isUser = m.agent === 'user';
    const avatarUrl = !isUser && ag ? getAvatarDataUrl(m.agent, 2) : '';
    return `
      <div class="br-msg ${isUser ? 'user-msg' : ''}">
        <div class="br-msg-header">
          ${isUser
            ? `<span class="br-msg-name" style="color:var(--accent-green);">YOU</span>`
            : `<img src="${avatarUrl}" class="pixel-art" style="width:24px;height:34px;flex-shrink:0;">
               <span class="br-msg-name" style="color:${ag?.color||'#fff'};">${ag?.name||m.agent}</span>`
          }
          ${m.type === 'action-item' ? '<span style="font-size:7px;color:var(--accent-yellow);letter-spacing:1px;background:rgba(255,215,64,.08);padding:1px 5px;border-radius:3px;">ACTION ITEM</span>' : ''}
          ${m.type === 'decision' ? '<span style="font-size:8px;color:var(--accent-green);font-weight:600;background:rgba(52,199,89,.1);padding:2px 6px;border-radius:4px;">DECISION</span>' : ''}
          <span class="br-msg-ts">${m.ts}</span>
        </div>
        <div class="br-msg-body">${_esc(m.text)}</div>
      </div>
    `;
  }).join('');
  el.scrollTop = el.scrollHeight;

  // Update counters
  const msgCount = state.meeting.messages.filter(m => m.type !== 'system').length;
  $('#br-msg-count').textContent = `${msgCount} message${msgCount!==1?'s':''}`;
  if (state.meeting.startedAt) {
    const elapsed = Math.floor((Date.now() - state.meeting.startedAt) / 1000);
    const mins = Math.floor(elapsed / 60);
    const secs = elapsed % 60;
    $('#br-duration').textContent = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
  }

  // Action items
  if (state.meeting.actionItems.length > 0) {
    $('#br-action-items').style.display = 'block';
    $('#br-action-list').innerHTML = state.meeting.actionItems.map(ai => {
      const ag = getAgent(ai.agent);
      return `
        <div class="br-action-item">
          <span class="action-agent" style="color:${ag?.color||'#fff'};">${ag?.name||ai.agent}</span>
          <span>${ai.text}</span>
        </div>
      `;
    }).join('');
  } else {
    $('#br-action-items').style.display = 'none';
  }

  // Topic display
  if (state.meeting.active) {
    $('.br-topic-label').textContent = 'ACTIVE BRIEFING';
    $('#br-topic-text').textContent = state.meeting.topic;
    $('#br-topic-text').style.color = 'var(--accent-green)';
  } else if (state.meeting.messages.length > 0) {
    $('.br-topic-label').textContent = 'MEETING CONCLUDED';
    $('#br-topic-text').style.color = 'var(--text-muted)';
  } else {
    $('.br-topic-label').textContent = 'AWAITING BRIEFING';
    $('#br-topic-text').textContent = 'No active meeting';
    $('#br-topic-text').style.color = 'var(--text-secondary)';
  }
}

function renderBriefingControls() {
  const active = state.meeting.active;
  $('#br-start-btn').style.display = active ? 'none' : '';
  $('#br-interject-btn').style.display = active ? '' : 'none';
  $('#br-end-btn').style.display = active ? '' : 'none';
  $('#br-input-bar').style.display = active ? 'flex' : 'none';
  $('#br-status').textContent = active ? 'IN SESSION' : 'STANDBY';
  $('#br-status').style.color = active ? 'var(--accent-green)' : 'var(--text-muted)';
}

// â”€â”€ Meeting Simulation Engine (Demo Mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _meetingThinking = null;
let _meetingTimeouts = [];
let _meetingDurationTimer = null;

function _getMeetingSpeaker() {
  if (!state.meeting.active || state.meeting.messages.length === 0) return null;
  const last = [...state.meeting.messages].reverse().find(m => m.type !== 'system' && m.agent !== 'user');
  return last?.agent || null;
}

// Meeting script generator â€” creates contextual multi-turn discussions using actual participants
function _generateMeetingScript(topic, type, participants) {
  // Map participants to roles: facilitator, analyst, creative, technical, extras
  const p = participants.map(id => getAgent(id)).filter(Boolean);
  if (p.length < 2) return [];
  const f = p[0]?.id; // facilitator
  const a = p[1]?.id; // second seat
  const b = p[2]?.id; // third seat (optional)
  const c = p[3]?.id; // fourth seat (optional)
  const pName = id => (getAgent(id)?.name || id).toUpperCase();

  const scripts = {
    strategy: [
      { agent: f, text: `Alright team, let's get into it. Today's agenda: ${topic}. I've blocked 25 minutes. ${pName(a)}, kick us off with your perspective.` },
      { agent: a, text: `I've been tracking this closely. Three things stand out: first, our positioning has shifted significantly. Second, the competitive landscape is consolidating. Third, there's an emerging gap that nobody's filling well.` },
      ...(b ? [{ agent: b, text: `That gap is exactly what I've been seeing too. Our highest-performing work this month leans into that opportunity. I think there's a real chance to own that space if we move now.` }] : []),
      ...(c ? [{ agent: c, text: `From a technical standpoint, we can support this if we invest in two key areas. I can have a prototype ready in 5 days that validates the approach.` }] : []),
      { agent: a, text: `Worth noting: the competition is underperforming in this area. If we execute well, we'd have a measurable advantage.` },
      { agent: f, text: `I like the alignment here. Let me check resources â€” does the timeline create any conflicts?`, type: 'question' },
      ...(c ? [{ agent: c, text: `No conflicts on my end. Current work ships Friday, new initiative starts Monday.` }] : []),
      { agent: f, text: `Good. Here's what I'm hearing as commitments:`, type: 'decision' },
      ...p.slice(1).map(agent => ({ agent: agent.id, text: `${pName(agent.id)} delivers on their workstream by end of next week`, type: 'action-item' })),
      { agent: f, text: `Strong meeting. Everyone has their marching orders. Let's reconvene Thursday to check progress.` },
    ],
    standup: [
      { agent: f, text: `Morning standup. Quick round â€” status and blockers. ${pName(a)}, you're up.` },
      { agent: a, text: `Main work item is 90% done, should ship by EOD. Running final checks now. No blockers.` },
      ...(b ? [{ agent: b, text: `My current project is performing well, ahead of target. One blocker: I need updated inputs from ${pName(a)} before I can finalize.` }] : []),
      ...(c ? [{ agent: c, text: `I can have that ready by noon. My analysis is 60% complete. Found some interesting patterns worth discussing in a strategy session.` }] : []),
      { agent: f, text: `Good flag. I'll schedule a follow-up. Any other blockers?` },
      ...p.slice(1).map(agent => ({ agent: agent.id, text: `${pName(agent.id)} delivers key workstream on schedule`, type: 'action-item' })),
      { agent: f, text: `Clean standup. Everyone's aligned. Back to work.` },
    ],
    review: [
      { agent: f, text: `Performance review for this cycle. Let's look at what worked, what didn't, and where we optimize. ${pName(a)}, pull up the metrics.` },
      { agent: a, text: `Here's the overview: task completion rate is up 23% from last period. Average response time improved significantly. The biggest efficiency gain came from recent infrastructure improvements that cascaded into faster cycles across the board.` },
      ...(b ? [{ agent: b, text: `On my side, our primary initiative exceeded projections by 15%. Where we underperformed: secondary projects haven't launched yet, and we're leaving opportunity on the table.` }] : []),
      ...(c ? [{ agent: c, text: `I can quantify that gap. Based on analysis, we're missing significant volume by not executing on our secondary priorities. At current rates, that's roughly 30-40 missed opportunities per month.` }] : []),
      { agent: f, text: `That's a meaningful gap. What's blocking the secondary work?` },
      ...(b ? [{ agent: b, text: `Bandwidth. The primary initiative consumed all my cycles. I need either dedicated time or help from the team on the research portion.` }] : []),
      { agent: f, text: `Let's restructure priorities for next cycle:`, type: 'decision' },
      ...p.slice(1).map(agent => ({ agent: agent.id, text: `${pName(agent.id)} rebalances priorities for next cycle`, type: 'action-item' })),
      { agent: f, text: `Strong review. Clear wins this cycle, and a solid plan for the next. Good work, everyone.` },
    ],
    incident: [
      { agent: f, text: `Incident response. ${topic}. ${p[1] ? pName(a) + ', what do we know?' : 'What do we know?'}` },
      { agent: a, text: `I've isolated the issue. It appears to be a misconfiguration causing cascading failures. Impact: approximately 15% of requests are affected.` },
      ...(b ? [{ agent: b, text: `I'm seeing downstream effects. Error rate spiked significantly in the last 45 minutes. External reports are starting to come in â€” no major escalation yet.` }] : []),
      ...(c ? [{ agent: c, text: `We need to get ahead of this on comms. I can draft a status update in 5 minutes.` }] : []),
      { agent: f, text: `Do it. ${pName(a)}, what's the fix timeline?` },
      { agent: a, text: `I have a fix ready. Low risk â€” config change, not code. I need a 2-minute window to deploy.` },
      { agent: f, text: `Deploy now.`, type: 'decision' },
      { agent: a, text: `Deploying... Rolling back to last known good state. Monitoring... Rates dropping. Back to baseline. Fix confirmed.` },
      ...p.slice(1).map(agent => ({ agent: agent.id, text: `${pName(agent.id)} delivers post-incident follow-up by EOD`, type: 'action-item' })),
      { agent: f, text: `Good response time. Incident contained. Let's make sure the post-mortem prevents recurrence.` },
    ],
    brainstorm: [
      { agent: f, text: `Brainstorm session: ${topic}. No bad ideas, let's go wide first and narrow later. Who wants to start?` },
      { agent: a, text: `I'll jump in. What if we flip our approach entirely? Instead of incremental improvements, we rethink the core value proposition. It changes the conversation from features to ecosystem.` },
      ...(b ? [{ agent: b, text: `Interesting angle. Data supports this â€” companies that make this shift command significantly higher valuations. But we'd need a distinct hook.` }] : []),
      ...(c ? [{ agent: c, text: `Our implementation is genuinely different. We're local-first, privacy-native, and highly modular. That's our hook: "Your infrastructure, your rules."` }] : []),
      { agent: a, text: `I love that framing. It captures both the privacy angle and the customization angle. Is that narrative resonating in the current market?` },
      ...(b ? [{ agent: b, text: `Massively. Recent regulations drove significant increase in demand for self-hosted options. We're positioned perfectly but underselling it.` }] : []),
      { agent: f, text: `Strong session. Let me capture the threads:`, type: 'decision' },
      ...p.slice(1).map(agent => ({ agent: agent.id, text: `${pName(agent.id)} develops their workstream from this brainstorm`, type: 'action-item' })),
      { agent: f, text: `Great energy. Let's reconvene in 48 hours with deliverables and pick a direction.` },
    ],
    planning: [
      { agent: f, text: `Sprint planning. Topic: ${topic}. We have a 2-week window. Let me pull up the backlog. ${pName(a)}, what's the priority stack?` },
      { agent: a, text: `Top of stack: our biggest force multiplier project. Second: the supporting infrastructure. Third: the refactor work. I can realistically ship the first two in this sprint. The refactor is multi-sprint.` },
      ...(b ? [{ agent: b, text: `From my side: we need the content initiative launched this cycle. I've got work outlined, but I need inputs from ${pName(a)} first. Also, the upcoming launch needs supporting work done before it goes live.` }] : []),
      ...(c ? [{ agent: c, text: `My priorities: research deliverable (2 days), deep-dive analysis (3 days), and dashboard setup (2 days). That fills my sprint. Additions would require deprioritizing something.` }] : []),
      { agent: f, text: `Let me map this out. Week 1: upstream deliverables flow downstream. Week 2: execution and launches. Dependencies look clean.` },
      { agent: f, text: `Sprint commitments locked:`, type: 'decision' },
      ...p.slice(1).map(agent => ({ agent: agent.id, text: `${pName(agent.id)} delivers sprint commitments on schedule`, type: 'action-item' })),
      { agent: f, text: `Tight sprint but achievable. Let's execute.` },
    ],
  };

  let script = scripts[type] || scripts.strategy;

  // Filter to only participating agents
  script = script.filter(m => !m.agent || participants.includes(m.agent));

  return script;
}

function startMeeting() {
  const topic = $('#br-modal-topic').value.trim();
  if (!topic) return;
  const type = $('#br-modal-type').value;

  // Get selected participants
  const participants = [];
  $$('.br-agent-toggle.selected').forEach(el => participants.push(el.dataset.id));
  if (participants.length < 2) {
    alert('Select at least 2 participants');
    return;
  }

  $('#br-modal').classList.remove('open');
  $('#br-modal-topic').value = '';

  // Initialize meeting
  state.meeting.active = true;
  state.meeting.topic = topic;
  state.meeting.messages = [];
  state.meeting.actionItems = [];
  state.meeting.startedAt = Date.now();
  state.meeting.participants = participants;

  // System message
  state.meeting.messages.push({
    id: Date.now(), agent: null, type: 'system',
    text: `Briefing started â€” ${topic}`, ts: ts(),
  });

  renderBriefing();

  // Start duration timer
  _meetingDurationTimer = setInterval(() => {
    if (state.meeting.active && state.activeView === 'briefing') {
      const elapsed = Math.floor((Date.now() - state.meeting.startedAt) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      $('#br-duration').textContent = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
    }
  }, 1000);

  // If connected to Gateway, send meeting start to lead agent
  if (state.connected && state.ws) {
    state.ws.send(JSON.stringify({
      type: 'message',
      agentId: participants[0], // lead agent
      text: `Start a meeting about: ${topic}. Type: ${type}. Participants: ${participants.join(', ')}. Use agent-send to engage other agents. Push all responses to the Command Center via canvas.eval: window.__openclaw_cc.meetingMessage({agent:'YOUR_ID', text:'YOUR_MESSAGE'})`,
    }));
  }

  // Demo mode: simulate the meeting
  if (!state.connected) {
    _simulateMeeting(topic, type, participants);
  }
}

function _simulateMeeting(topic, type, participants) {
  const script = _generateMeetingScript(topic, type, participants);
  _meetingTimeouts = [];

  let delay = 1500;
  script.forEach((line, i) => {
    // Thinking phase
    const thinkDelay = delay;
    const thinkDuration = 800 + Math.random() * 1500;

    _meetingTimeouts.push(setTimeout(() => {
      if (!state.meeting.active) return;
      _meetingThinking = line.agent;
      renderBriefingSeats();
      // Typing indicator
      const typingEl = $('#br-typing-area');
      const ag = getAgent(line.agent);
      if (typingEl && ag) {
        typingEl.innerHTML = `<div class="br-typing"><span style="color:${ag.color};">${ag.name}</span> is thinking...</div>`;
      }
    }, thinkDelay));

    // Message delivery
    const msgDelay = thinkDelay + thinkDuration;
    _meetingTimeouts.push(setTimeout(() => {
      if (!state.meeting.active) return;
      _meetingThinking = null;
      $('#br-typing-area').innerHTML = '';

      state.meeting.messages.push({
        id: Date.now() + i,
        agent: line.agent,
        text: line.text,
        type: line.type || 'message',
        ts: ts(),
      });

      if (line.type === 'action-item') {
        state.meeting.actionItems.push({
          agent: line.agent, text: line.text, ts: ts(),
        });
      }

      renderBriefing();

      // Also push to org structure comms
      window.__openclaw_cc.pushComms({
        from: line.agent,
        to: 'all',
        text: `[MEETING] ${line.text.substring(0, 80)}${line.text.length > 80 ? '...' : ''}`,
      });
    }, msgDelay));

    // Time between messages varies by length and type
    const readTime = Math.max(1500, line.text.length * 25);
    delay = msgDelay + readTime + Math.random() * 1000;
  });

  // Auto-end meeting after all messages
  _meetingTimeouts.push(setTimeout(() => {
    if (!state.meeting.active) return;
    endMeeting();
  }, delay + 2000));
}

function endMeeting() {
  // Clear all pending timeouts
  _meetingTimeouts.forEach(t => clearTimeout(t));
  _meetingTimeouts = [];
  _meetingThinking = null;
  if (_meetingDurationTimer) { clearInterval(_meetingDurationTimer); _meetingDurationTimer = null; }

  // Archive meeting
  const summary = {
    topic: state.meeting.topic,
    messages: [...state.meeting.messages],
    actionItems: [...state.meeting.actionItems],
    duration: Date.now() - state.meeting.startedAt,
    participants: [...state.meeting.participants],
    endedAt: Date.now(),
  };
  state.meeting.history.push(summary);
  _saveMeetingHistory();

  // End
  state.meeting.active = false;
  state.meeting.messages.push({
    id: Date.now(), agent: null, type: 'system',
    text: `Meeting concluded â€” ${state.meeting.actionItems.length} action item${state.meeting.actionItems.length!==1?'s':''} captured`,
    ts: ts(),
  });

  $('#br-typing-area').innerHTML = '';
  renderBriefing();

  // Notify
  _showToast({
    agent: state.meeting.participants[0] || state.agents[0]?.id || 'system', text: `Meeting concluded: ${state.meeting.topic}`,
    level: 'success', ts: ts(),
  });
}

function interjectInMeeting() {
  const input = $('#br-input');
  const text = input.value.trim();
  if (!text || !state.meeting.active) return;
  input.value = '';

  state.meeting.messages.push({
    id: Date.now(), agent: 'user', type: 'message',
    text, ts: ts(),
  });
  renderBriefingTranscript();
}

// Event listeners for briefing room
$('#br-start-btn').addEventListener('click', () => {
  const agentList = $('#br-modal-agents');
  const adminAgents = state.agents.filter(a => a.admin !== false);
  if (adminAgents.length < 2) {
    alert('Need at least 2 admin agents to start a briefing. Toggle admin on agents in their settings.');
    return;
  }
  agentList.innerHTML = adminAgents.map(a => `
    <button class="br-agent-toggle selected" data-id="${a.id}">
      <span class="toggle-dot" style="background:${a.color};"></span>
      <span class="toggle-name" style="color:${a.color};">${a.name}</span>
    </button>
  `).join('');
  agentList.querySelectorAll('.br-agent-toggle').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      btn.classList.toggle('selected');
    });
  });
  $('#br-modal').classList.add('open');
});

$('#br-end-btn').addEventListener('click', endMeeting);
$('#br-interject-btn').addEventListener('click', () => {
  $('#br-input').focus();
});
$('#br-input-send').addEventListener('click', interjectInMeeting);
$('#br-input').addEventListener('keydown', e => { if (e.key === 'Enter') interjectInMeeting(); });

// â”€â”€ RENDER ALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderAll() {
  renderAgentPills();
  renderOrgChart();
  renderWarChatter();
  renderChatAgentList();
  renderChat();
  renderCalendar();
  renderMarketing();
  renderTasks();
  renderCron();
  renderLogs();
  renderPrompts();
  renderVault();
  renderAnalytics();
  renderBriefing();
}

// â”€â”€ CHARACTER CUSTOMIZER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CLOTHES_COLORS = ['#34c759','#0a84ff','#ff9f0a','#bf5af2','#ff453a','#ffd60a',
  '#e8564a','#4a9de8','#56c47a','#e8a44a','#7a56c4','#c4567a',
  '#2a6b4a','#6b2a4a','#4a2a6b','#6b5a2a','#3a5c8a','#8a3a5c'];
const SHOE_COLORS = ['#2a1f14','#1a1a2e','#8b2020','#e8e8e8','#3a5c3a','#4a3060','#5a3a20','#1a3a5a'];

let _avEditingAgent = null;
let _avTempConfig = null;

function openAvatarCustomizer() {
  _avEditingAgent = state.agents[0]?.id;
  const sel = $('#av-agent-select');
  sel.innerHTML = state.agents.map(a =>
    `<option value="${a.id}" style="color:${a.color};">${a.name} â€” ${a.role}</option>`
  ).join('');
  sel.value = _avEditingAgent;
  sel.onchange = () => { _avEditingAgent = sel.value; _avTempConfig = {...state.avatarConfigs[_avEditingAgent]}; _populateCustomizer(); };

  _avTempConfig = {...state.avatarConfigs[_avEditingAgent]};
  _populateCustomizer();
  $('#avatar-modal').classList.add('open');
}

function _populateCustomizer() {
  const cfg = _avTempConfig;
  if (!cfg) return;

  // Skin tone swatches
  _renderSwatches('av-skin', SKIN_TONES, cfg.skin);
  // Hair color swatches
  _renderSwatches('av-hair-color', HAIR_COLORS, cfg.hairColor);
  // Clothes color
  _renderSwatches('av-clothes', CLOTHES_COLORS, cfg.clothes);
  // Pants color
  _renderSwatches('av-pants', CLOTHES_COLORS, cfg.pants);
  // Shoe color
  _renderSwatches('av-shoes', SHOE_COLORS, cfg.shoes);

  // Style pickers (numbered options)
  const styleLabels = {
    hair: ['Crop','Spiky','Long','Mohawk','Bowl','Pony','Wild','Buzz'],
    eyes: ['Dot','Wide','Happy','Focus','Star'],
    mouth: ['Smile','Flat',':3','Grin'],
    bodyType: ['Tee','Jacket','Tank'],
    accessory: ['None','Specs','Band','Scarf','Hat','Ring'],
  };

  ['hair','eyes','mouth','bodyType','accessory'].forEach(prop => {
    const el = $(`#av-${prop === 'bodyType' ? 'body' : prop}`);
    const labels = styleLabels[prop] || [];
    const max = parseInt(el?.dataset?.max || labels.length);
    if (!el) return;
    el.innerHTML = Array.from({length: max}, (_, i) =>
      `<div class="av-option ${cfg[prop] === i ? 'active' : ''}" data-val="${i}">${labels[i] || i}</div>`
    ).join('');
    el.querySelectorAll('.av-option').forEach(opt => {
      opt.addEventListener('click', () => {
        _avTempConfig[prop] = parseInt(opt.dataset.val);
        _populateCustomizer();
      });
    });
  });

  // Blush
  $('#av-blush').checked = cfg.blush || false;
  $('#av-blush').onchange = () => { _avTempConfig.blush = $('#av-blush').checked; _renderAvatarPreview(); };

  _renderAvatarPreview();
}

function _renderSwatches(elId, colors, current) {
  const el = $(`#${elId}`);
  if (!el) return;
  const prop = el.dataset.prop;
  el.innerHTML = colors.map(c =>
    `<div class="av-swatch ${c === current ? 'active' : ''}" style="background:${c};" data-color="${c}"></div>`
  ).join('');
  el.querySelectorAll('.av-swatch').forEach(sw => {
    sw.addEventListener('click', () => {
      _avTempConfig[prop] = sw.dataset.color;
      // Auto-darken pants when clothes change
      if (prop === 'clothes') {
        _avTempConfig.pants = _darkenHex(sw.dataset.color, 90);
      }
      _populateCustomizer();
    });
  });
}

function _renderAvatarPreview() {
  const url = renderAvatar(_avTempConfig, 6);
  $('#av-preview').innerHTML = `<img src="${url}" class="pixel-art" style="width:72px;height:102px;">`;
}

function randomizeAvatar() {
  const ag = getAgent(_avEditingAgent);
  const rng = _seeded(Date.now());
  _avTempConfig = {
    skin: _pick(rng, SKIN_TONES),
    hairColor: _pick(rng, HAIR_COLORS),
    hair: Math.floor(rng() * 8),
    eyes: Math.floor(rng() * 5),
    mouth: Math.floor(rng() * 4),
    accessory: Math.floor(rng() * 6),
    bodyType: Math.floor(rng() * 3),
    clothes: _pick(rng, CLOTHES_COLORS),
    pants: _pick(rng, CLOTHES_COLORS),
    shoes: _pick(rng, SHOE_COLORS),
    blush: rng() > 0.4,
  };
  _populateCustomizer();
}

function saveAvatar() {
  state.avatarConfigs[_avEditingAgent] = {..._avTempConfig};
  _saveAvatarConfigs();
  invalidateAvatarCache(_avEditingAgent);
  renderAll();
  // Flash success
  const ag = getAgent(_avEditingAgent);
  _showToast({agent: _avEditingAgent, text: `${ag?.name || _avEditingAgent}'s look updated!`, level: 'success', ts: ts()});
}

// â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
initAvatars();
renderAll();
dripChatter();

// Init chat â€” empty per agent
state.agents.forEach(a => {
  state.chatMessages[a.id] = state.chatMessages[a.id] || [];
  state.agentStatus[a.id] = state.agentStatus[a.id] || 'active';
});
renderChat();

// Try to connect to Gateway
if ((__agentInstallConfig?.source || __agentInstallConfig?.gatewayUrl || __agentInstallConfig?.hasToken) && state.gatewayUrl) {
  const parts = [`Gateway auto-configured from URL install link${__agentInstallConfig.source ? ` (${__agentInstallConfig.source})` : ''}`];
  if (__agentInstallConfig.authToken) parts.push('with token');
  _showToast({ text: parts.join(' '), level: 'success', ts: ts() });
}

if (state.gatewayUrl) {
  setTimeout(connectGateway, 500);
}

// Periodically refresh
setInterval(() => {
  renderOrgWires();
  renderAnalytics();
}, 30000);

// â”€â”€ ASYNC BOOT: IndexedDB recovery + backup timer â”€â”€
(async function asyncBoot() {
  const idbOk = await _storage.init();

  if (idbOk) {
    // Check if IDB has data that localStorage lost (browser cleanup, etc.)
    const meta = await _storage.idbGet('oc_meta');
    const lsAgents = localStorage.getItem('oc_agents');

    if (meta?.savedAt && !lsAgents) {
      // localStorage was wiped but IDB has data â€” recover!
      console.log('[Boot] localStorage empty but IDB has data â€” recovering...');
      _updateSaveIndicator('recovering');
      const recovered = await _storage.recoverFromIDB();
      if (recovered) {
        // Re-init chat arrays for recovered agents
        state.agents.forEach(a => {
          state.chatMessages[a.id] = state.chatMessages[a.id] || [];
          state.agentStatus[a.id] = state.agentStatus[a.id] || 'active';
        });
        renderAll();
        renderChat();
        _showToast({ text: 'âœ… Data recovered from IndexedDB backup', level: 'success', ts: ts() });
      }
    } else if (meta?.savedAt && lsAgents) {
      // Both have data â€” sync IDB with current localStorage state
      // (localStorage was faster on boot, so it's already loaded)
      // Just persist current state to IDB to ensure consistency
      await _storage.persistFullState();
    } else {
      // Fresh install or no IDB data yet â€” persist current state
      await _storage.persistFullState();
    }

    // Start automatic backup timer
    _storage.startBackupTimer();
    _updateSaveIndicator('saved');
  } else {
    // IDB not available â€” still functional via localStorage
    _updateSaveIndicator('saved');
    console.warn('[Boot] Running without IndexedDB â€” data is less durable');
  }

  // Set version label
  const vEl = $('#cc-version');
  if (vEl) vEl.textContent = `v${OC_VERSION}`;

  console.log(`[Boot] OpenClaw Command Center v${OC_VERSION} ready`);
})();

// â”€â”€ THEME TOGGLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('openclaw-theme', next);
  const btn = document.getElementById('theme-toggle');
  btn.textContent = next === 'dark' ? 'â—‘' : 'â—';
  btn.title = next === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
}

// Restore saved theme
(function() {
  const saved = localStorage.getItem('openclaw-theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
    const btn = document.getElementById('theme-toggle');
    if (btn) {
      btn.textContent = saved === 'dark' ? 'â—‘' : 'â—';
      btn.title = saved === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
    }
  }
})();
document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

console.log(`%c[OpenClaw Command Center] v${OC_VERSION} â€” Glass Panel Theme`, 'color:#0a84ff;font-weight:bold;');
console.log('%cStorage: Gateway (primary) â†’ IndexedDB â†’ localStorage Â· Auto-backup every 5min', 'color:#34c759;');
console.log('%cwindow.__openclaw_cc exposes 40+ methods', 'color:#34c759;');
console.log('%câ”€â”€â”€ AGENT MANAGEMENT â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .createAgent({name,role,model,color,skills,personality})  .editAgent(id,{...})  .removeAgent(id)  .getAgents()  .getModels()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ ORG STRUCTURE â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .addConnection(from,fromPort,to,toPort)  .removeConnection(id)  .getConnections(agentId?)  .getConnectedAgents(id)  .moveOrgNode(id,x,y)  .clearConnections()  .generateRoutingConfig(id)  .exportAllRoutingConfigs()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ COMMS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .pushComms({from,to,text})  .clearComms()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ AGENTS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .setAgentStatus(id,"busy"|"idle"|"active"|"error"|"offline")  .getAgentStatus(id)', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ TASKS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .addTask({})  .moveTask(id,"done")  .updateTask(id,{})  .deleteTask(id)  .getTasks({agent,status})  .clearTasks({})', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ CRON JOBS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .addCronJob({name,agents:[],schedule,message})  .updateCronJob(id,{})  .deleteCronJob(id)  .toggleCronJob(id)  .getCronJobs({agent,enabled})  .logCronRun(id,success,error)', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ ACTIVITY LOG â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .logActivity({type,agent,desc,detail})  .getActivityLog({agent,type,since})  .clearActivityLog({agent,type})', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ SYSTEM PROMPTS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .getPrompt(agentId)  .setPrompt(agentId,{identity,role,tools,personality,instructions})  .pushPrompt(agentId)  .pushAllPrompts()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ API VAULT â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .addSecret({name,envKey,fields:[{label,key,value}],note})  .getSecret("BASE.FIELD",agentId)  .listSecrets(agentId)  .setAllowList(id,[agents])  .deleteSecret(id)', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ CALENDAR â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .addCalEvent({})  .updateCalEvent(id,{})  .deleteCalEvent(id)  .getCalEvents({date,agent})  .clearCalEvents({})', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ CAMPAIGNS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .addCampaign({})  .updateCampaign(id,{})  .deleteCampaign(id)  .toggleCampaignTask(cid,idx)  .addCampaignTask(cid,text)  .removeCampaignTask(cid,idx)', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ CHAT â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .sendAgentMessage(id,text)  .getChatHistory(id)  .clearChat(id)', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ REVENUECAT â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .rcAddApp({id,name,icon})  .rcRemoveApp(id)  .rcSelectApp(id)  .rcSetTimeframe(tf)  .rcUpdateMetrics({mrr,revenue,...})  .rcPushTransaction({event,product,amount,...})  .rcUpdateProduct(id,{})  .rcGetMetrics()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ MEETINGS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .meetingMessage({agent,text,type})  .startMeetingProgrammatic({topic,participants})  .endMeetingProgrammatic()  .addActionItem({agent,text})  .getMeetingState()  .getMeetingHistory()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ AVATARS â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .getAvatarConfig(id)  .setAvatarConfig(id,{skin,hair,eyes,...})  .randomizeAvatarConfig(id)', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ OTHER â”€â”€â”€', 'color:#ff9f0a;');
console.log('%c  .notify({text,agent,level})  .switchView(view)  .selectDate(d)  .selectCampaign(i)  .selectChatAgent(id)  .getState()  .importState({})  .renderAll()', 'color:#8e8e93;');
console.log('%câ”€â”€â”€ GATEWAY PERSISTENCE PROTOCOL â”€â”€â”€', 'color:#0a84ff;');
console.log('%c  Outbound: state_sync (on save), state_request (on connect)', 'color:#8e8e93;');
console.log('%c  Inbound:  state_restore (gateway sends state), state_ack (write confirmed), state_conflict (merge needed)', 'color:#8e8e93;');
console.log('%c  Gateway writes to: ~/.openclaw/workspace/canvas/state/current.json', 'color:#8e8e93;');
console.log('%c  Recovery: Gateway â†’ IndexedDB â†’ localStorage â†’ Defaults', 'color:#8e8e93;');
</script>
</body>
</html>
